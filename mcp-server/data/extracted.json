{
  "documentation": [
    {
      "id": "faq",
      "title": "FAQ",
      "path": "FAQ.md",
      "content": "Q: The Calendar is not fully recognized / I get JavaScript errors like \"setOption is not a function\" or \"addEvents is not a function\".\n\nA: This may hapen, when not including the addon packages into Vaadin's whitelisting. Please check, if your 'application.properties' contain the property \"vaadin.whitelist\" and if it does, if the whitelist includes \"org.vaadin.stefan\".\n```\nvaadin.whitelisted-packages=com.vaadin,org.vaadin.stefan,some.other.addon,etc.etc.etc\n```\n\nPlease also see [Build problems / JS (client side) errors with V14+](https://github.com/stefanuebe/vaadin_fullcalendar/wiki/Known-Issues#build-problems--js-client-side-errors-v14) for more details. If the issue still occurs, please [check](https://github.com/stefanuebe/vaadin_fullcalendar/issues/), if there might be an open issue already or create a new one.\n\nQ: The `DatesRenderedEvent` is not fired when setting an option, that changes the view.\n\nA: I deactivated the forwarding of the datesRendered event from the client side when an option is set, since\nthat would lead otherwise to a huge amount of datesRendered events. When setting options before the client side\nis fully attached, the queueing messes up the event handling here.\n\nWhen needed, you can activate or deactivate that by using the method `allowDatesRenderEventOnOptionChange(boolean)`.\nBy default this value is `false`, simply set it to true to also receive date render events on setOption.\n",
      "category": "docs",
      "tags": [
        "faq",
        "datesrenderedevent"
      ]
    },
    {
      "id": "features",
      "title": "Features",
      "path": "Features.md",
      "content": "This page shows a summary of the most important features of the FullCalendar library, that this addon provides. It is\nnot a full list of all features. If you find any library features missing, please create a [feature request](https://github.com/stefanuebe/vaadin-fullcalendar/issues/new?template=BLANK_ISSUE).\n\n## FullCalendar features\n- adding / updating / removing calendar entries using a data provider like mechanism,\n- switching between shown intervals (next month, previous month, etc.),\n- goto a specific date or today,\n- switch the calendar view (month, basic views for days and weeks, agenda views for days and weeks, list views for day to year),\n- setting a locale to be used for displaying week days, formatting values, calculating the first day of the week, etc. (supported locales are provided as constant list)\n- setting the first day of week to be shown (overrides the locale setting),\n- limit max shown entries per day (except basic views)\n- activating day / week numbers / names to be links\n- setting a eventRender JS function from server side\n- setting business hours information (multiple entries possible)\n- creating recurring events\n- setting a client side timezone\n- optional Lumo theme\n- custom native js event handlers for entries\n\n- Event handling for\n    - clicking an empty time spot in the calendar,\n    - selecting a block of empty time spots in the calendar,\n    - clicking an entry,\n    - moving an entry via drag and drop (event is fired on drop + changed time),\n    - resizing an entry (event is fired after resize + changed time),\n    - view rendered (i. e. to update a label of the shown interval)\n    - clicking on limited entries link \"+ X more\"\n    - clicking on a day's or week's number link (when activated)\n\n- Model supports setting\n    - title,\n    - start / end / all day flag,\n    - color (html colors, like \"#f00\" or \"red\"),\n    - description (not shown via FC),\n    - editable / read only\n    - rendering mode (normal, background, inversed background)\n    - recurring data (day of week, start / end date and time)\n    - etc.\n\n## Scheduler features\nThe scheduler extension integrates the features of the commercial Scheduler plugin of the FullCalendar library.\n\n- adding / removing resources (hierarchies of resources are supported)\n- Link one or multiple resources with entries.\n- Activation of the Scheduler by method in the FullCalendarBuilder.\n- List of possible Scheduler based views (timeline).\n- List of possible Scheduler entries grouping.\n\n- Event handling for\n  - Timeslot clicked\n  - Timeslots slected\n  - Entry dropped",
      "category": "docs",
      "tags": [
        "features",
        "scheduler",
        "resource",
        "entry",
        "event"
      ]
    },
    {
      "id": "home",
      "title": "Home",
      "path": "Home.md",
      "content": "Welcome to the FullCalendar for Flow documentation. Here you will find different information about\nthe Flow integration of the [FullCalendar library](https://fullcalendar.io).\n\nFor general information about the project, please check to the \n[project's readme](https://github.com/stefanuebe/vaadin-fullcalendar).",
      "category": "docs",
      "tags": [
        "home"
      ]
    },
    {
      "id": "known-issues",
      "title": "Known-issues",
      "path": "Known-issues.md",
      "content": "## Known Issues\n\n### Multiline events drag & drop cause the scrollbar to lose position\nThe problem appears when you remove the events and add them back. When you remove all the events from the calendar it resizes itself. When the calendar has no events, it is much shorter which explains why the scroll position is changing.\n\nTake a look here for a workaround https://github.com/stefanuebe/vaadin_fullcalendar/issues/76\n\nAnother good way to fix it is to provide the resources/events as JSON feed and refetch the events instead of removing and adding them back.\n\n### Build problems / JS (client side) errors\nIt might be that the transitive dependencies are not resolved correctly. This mostly happens in Spring Boot due to its built-in class path scanning, which is adapted by Vaadin.\n\nPlease ensure that, if you are using the `vaadin.allowed-packages` property, it lists the addon's package `org.vaadin.stefan` (or simply `org.vaadin`).\n\nIf you are not using any allowed or blocking list in the properties and still have the issue, please check if you have added the `@EnableVaadin` annotation to your Spring application class. If that is the case, check if there are packages listed. If yes, add the package `org.vaadin.stefan` to it.\n\nIf the annotation is not added or added without any parameter and the issue occurs, please add the package `org.vaadin.stefan` plus other necessary packages that have to be scanned, as parameters.\n\nThis should enable Spring to analyze all relevant npm dependencies at runtime. Other CDI versions should work the same.\n\n### Entry cache limits\nThe calendar maintains an internal cache of entries limited to 10,000 items (LRU eviction). This is to prevent unbounded memory growth when using lazy-loaded entry providers with large datasets. If you need more entries cached, consider implementing a custom caching strategy.\n\n### Server-defined JavaScript callbacks\nThe addon uses `new Function()` to evaluate server-defined JavaScript callbacks (e.g., for entry render hooks). This is intentional and allows the server to define client-side behavior dynamically. See [FullCalendar Event Render Hooks](https://fullcalendar.io/docs/event-render-hooks) for the underlying feature.\n\n## Notes for Custom Subclasses\n\nWhen creating custom TypeScript/JavaScript subclasses of FullCalendar:\n\n1. **Prevent duplicate event handler registration**: Use a flag (e.g., `_tooltipInitialized`) to ensure event handlers are only registered once, even if `initCalendar()` is called multiple times.\n\n2. **Clean up resources**: If you add ResizeObservers or other resources, clean them up in `disconnectedCallback()` to prevent memory leaks.",
      "category": "docs",
      "tags": [
        "known-issues",
        "entry",
        "event"
      ]
    },
    {
      "id": "migration-guides",
      "title": "Migration-guides",
      "path": "Migration-guides.md",
      "content": "We know that migrations suck. Not only developers fear the appearance of a new major version but also every\nproduct or project manager of an application, that uses 3rd party software, knows, that it can be a stressful and time consuming horror to\nintegrate a new major version.\n\nUnfortunately this applies also for this addon. There will be breaking changes here and  there, that requires you to get back\ninto your code and review everything. Nevertheless, we hope, that this migration guide helps you as good as possible\nto get a detailed insight of what has changed and what needs to be done to get you back on track.\n\nIf we missed something or anything is unclear, please ping us on GitHub. We hope, that your upgrade goes through\nas smoothly as possible.\n\n## Index\n* [6.1 > 7.0](#migrating-from-61--70)\n* [4.1 > 6.0](#migrating-from-41--60)\n* [4.0 > 4.1](#migrating-from-40--41)\n* [3.x > 4.0](#migrating-from-3x--40)\n\n## Migrating from 6.1 > 7.0\nTo migrate to version 7 of the addon, you need to bump your Vaadin version to 25 and anything else, that Vaadin 25 \nrequires (like Java or Spring Boot).\n\nIf you have used any elemental.Json classes, then you need to convert those to their respective Jackson 3 counterparts,\nlike for instance `JsonArray` to `ArrayNode` or `JsonObject` to `ObjectNode`.\n\nAlso, you may need to update used methods, for instance `JsonUtils#ofJsonValue` is now `#ofJsonNode`.\n\n### Business hours reworked\nThe class `BusinessHours` has been reworked. The constructors have been removed and instead\nthere are now static methods to define new instance. The api also has been changed to allow a fluid definition\nstyle of business hours.\n\nReplace your constructors with a matching static construction variant and define start and end using\nthe respective fluent api methods `start/end` (optional)\n\n### Minor changes\nDeprecated APIs have been marked as `forRemoval` and will be removed with one of the next minor releases.\n\nThe FullCalendar theme variant `LUMO` has been renamed to `VAADIN`. If you referenced this somewhere, rename\nit accordingly.\n\n## Migrating from 4.1 > 6.0\nDepending on your Vaadin version you may need to update also other things, related to Vaadin core and Spring Boot.\nSteps to be taken there, will not be covered here.\n\n### Removed polymer\nSince Polymer has been removed from Vaadin 24, we decided to convert the JS elements to plain, HTML element based\nweb components. Thus, this version should work with Vaadin 23 and 24. \n\nFor most cases this should not affect your application. However, if you subclasses the javascript classes, you may need\nto adapt some of the changes. Any Polymer related feature needs to be converted to plain javascript. If you used\nproperties, you should still be able to set those via the Flow Java API, but you simply have to declare them as normal\nJS class fields. \n\nAlso please note, that the content of the component is now part of the light dom. This will most likely affect\nany custom stylings you may have defined. See the next part for details.\n\n### Styling\nSince the component is now part of the light dom, you have the advantages and disadvantages of it. \n\nAny custom styles you may have defined via overriding the JS class or via using the Java method `addCustomStyles` \ncan now be simply defined via plain css style files. So simply take your css snippets and move them to your global\ncss styles (however they are strucutred :) ).\n\nPlease be aware, that due to being part of the light dom, any other stylings may bleed into the FC now or vice versa.\nBut our experience showed, that the majority of our user base preferred the light dom variant, thus we decided to\ngo this way.\n\nAlso since we moved to a new major of the FC library, it might be, that css selectors have changed in their \nprovided styles and thus your custom styles might not work out of the box.\n\n### Folder structure and tags\nWe changed the folder structure and tag names a bit to better represent the Vaadin nature of this addon and to\nprevent potential naming conflicts. Therefore the the files will now be placed inside a folder named\n`vaadin-full-calendar`. The file names themselves have not changed.\n\nIf you subclasses one of the FC JavaScript classes, simply update the folder structure to be something like\n`@vaadin/flow-frontend/vaadin-full-calendar/full-calendar`. You may need to add the file suffix \".ts\".\n\nAdditionally we prefixed the element tag names with a `vaadin-`, so that the FC itself now has the tag \n`vaadin-full-calendar`. This is relevant, if you used the old tag names for styling or dom querying purposes.\nIn that case update the tag names.\n\n### TypeScript\nWe migrated the old JS files to TypeScript. But this process is not yet done and thus there are many things still in\nprogress (mainly the definition of custom types and some code refinement). \n\nNevertheless, for the normal use case, this has no effect. If you subclassed the JS classes, feel free to convert\nit to TypeScript, but be aware, we do not yet have any fancy TypeScript stuff. But it will come somewhere in future ;)\n\nThings to have in mind when migrating: We use protected and private modifiers of typescript now. Any underscores \nhave been removed and the methods / fields have become private or protected. For instance the `_initCalendar()` method\nis now named `initCalendar()`. This is one of the most important ones - if you have subclassed the FC, you most likely\nhave overridden this method and have to update your code. We recommend to use the `override` modifier, so that the \ncompiler marks any issues regarding such cases.\n\n#### Issues with webpack\nThere is a known issue with webpack, that will most likely lead to issues, when starting the application.\n\nCheck the \"Known Issues\" page for details (> Startup issue when using webpack (Vaadin 14-23)).\n\n### No more EagerInMemoryEntryProvider\nTo make maintenance of the client side a bit easier and less error prone, we decided to remove the \n`EagerInMemoryEntryProvider` and thus have the client side always be in \"lazy loading\" mode. This means, that there is \nno official way anymore to move all entries to the client side at once.\n\nOf course you still can override this behavior by using simple JS, but we do not recommend to do\nthat as all infrastructure is built around the fetching mechanisms.\n\nThe `LazyInMemoryEntryProvider` has been renamed to `InMemoryEntryProvider`. Rename all imports and class occurrences.\nAlso the static methods inside EntryProvider have been renamed from `lazyInMemoryFromItems` to `inMemoryFrom`.\n\nReplace any usage of the eager variant with the (now) default one. You also need to call `refreshAll`/`refreshItem` \nafter you changed the data in the provider. This behavior aligns to the behavior to the normal Vaadin data provider.\n\nThe `updateMethod` of the eager variant has no replacement in the default one, as items are not pushed to the client,\nbut fetched. When the client shall be updated, call the refresh methods instead.\n\nThere are also other methods, that where some variant of `Eager`. Simply replace them with the now default one and\ncheck, if refreshs are necessary in your use cases.\n\n#### Prefetch mode\nThere is now a prefetch mode, that allows fetching adjacent periods. This shall prevent flickering, when switching\nto the previous/next period. See the samples page for details.\n\n### Custom views\nUp to now custom views had to be created as a Java class but could only be registered via initial options. To\nmake life a bit easier here, the interface `CustomCalendarView` has been added plus methods to register those. \n\nIt is recommended to convert your views and use this new interface. While the old way should still work\nand lead to `AnonymousCustomCalendarView` instances, a warning will be printed onto the error console.\n\nCheck the `CustomCalendarView` docs for additional information. The relevant method is `getViewSettings()`.\n\nPlease note, that due to limitations of the FC library, views can only be set at initialization time.\n\n### Entry is \"static\" again, JsonItem is gone\nThis part describes a rare use case and should not be affecting most of the FC users.\n\nWith 4.x we tried to make the `Entry` structure more dynamic to allow easier definition of new properties and automate\nthe update mechanism a bit. Unfortunately the approach we took was not practicable in all use cases and we even had\nsome issues with proxying and mocking mechanisms.\n\nDue to that we decided to go back to the POJO approach as we had it prior to 4.x. This means, if you had extended\nthe `Entry` class to add properties using the `Key` mechanism, we are sorry, but you will have to convert your\nsubclass. \n\n#### Json annotations\nNevertheless, some ideas have survived this rollback. Especially automating the conversion and update process is still\nsomething we do not want to miss. To make life a bit easier, there are now annotations to mark class fields for\nautomated conversion and allow them to be updated. Check the `Entry` source code and annotations in the `json` \nsubpackage, if you want or need to use those annotations.\n\n### Deprecated methods have been removed\n#### Calendar Entry CRUD\nReplace Calendar Entry CRUD calls with `getEntryProvider().asInMemoryProvider()`, e.g. \n```java\n// before\ncalendar.addEntry(entry);\n\ncalendar.getEntryProvider().asInMemoryProvider().addEntry(entry)\n```\n\nWe know, this might be cumbersome for use cases, where you only use the in memory provider, but with having a cleaner\napi in mind this is a step we need to take. Sorry for the inconvenience.\n\n#### Entry Resource API\nResource methods in `Entry` are now more aligned to other Vaadin item api, so replace for instance `assignResources`\nwith `addResources`.\n\n#### Other changes\n* RenderingMode has been renamed to DisplayMode to align with the FC library and is a top class now. \n  Replace it and related methods respectively.\n* Entry's method `copy(Class<T>)` has been renamed to `copyAsType(Class<T>)`.\n* Entry's method `getResources` now may return `null`. Use `getOrCreateResources`. We wanted to have the names here being aligned to other namings in Entry.\n* `CalendarLocale` is now an enum. This should not affect you in most use cases.\n* The option \"week numbers within days\" is no longer available, week numbers are now always display inside days by the FC library. Simply remove any calls to that setting.\n* Since we used the javax @NotNull annotation a lot for better dx, but Vaadin 24 will no longer support that due to Spring Boot 3, we decided to add our own annotation to provide additional information without potential naming conflicts. \n\n\n## Migrating from 4.0 > 4.1\n### Entry Provider and old CRUD operations\n4.1 most important change is the introduction of EntryProviders. Please see the [examples](https://github.com/stefanuebe/vaadin_fullcalendar/wiki/FullCalendar-Examples#entry-providers) for details regarding the different new variants.\n\nBy default the FullCalendar uses an `EagerInMemoryEntryProvider`, which behaves the same way as the FullCalendar did before. This means, this should not be a breaking change for your application. Yet we recommend to change to either the `LazyInMemoryEntryProvider` or a callback variant to use the advantages of the new entry providers.\n\nPlease note, that the Entry CRUD API on the FullCalendar has been marked as deprecated. It is recommended to replace it with the respective API of the eager in memory provider, if you want to stay with that implementation. See the [examples page](https://github.com/stefanuebe/vaadin_fullcalendar/wiki/FullCalendar-Examples#in-memory-eager-loading) for an example on how that could look like.\n\n## Migrating from 3.x > 4.0\n### Introduction\n#### Timezones\nThe most breaking change when migrating from version 3.x to 4.0 will be that the server side got\nrid of any timezone inclusion regarding date times. You still may set a timezone for the calendar\nor set/get offsetted local date times, but the regular api is now always UTC based and we try to keep\nanything as clear as possible regarding whether a local date time represents a UTC time or a time with offset.\n\nPart of this change is\n* Getter and Setter of Entry start and end have changed in name and meaning\n* Timezones are not applied anymore to the server side times\n* Calendar and event time related api is also now UTC based (e.g. finding entries in a timespan)\n\n#### JsonItem\nWith this version also the foundation of the `Entry` type has changed to a more dynamic, automated way of handling and converting properties, when communicating with the client. This is done in a new class `JsonItem` which `Entry` now extends.\n\nIn theory, this should not break your code, unless you have extended the Entry class. In that case please have a look into the examples page or the implementation of Entry to get an idea what has changed. We hope, that we have covered now all basic properties of the client side FullCalendar items and that subclasses are not necessary anymore.\n\nIf you still need your subclass, you may have to overhaul the conversion part. For this case it is not really possible to foresee any implementation details and give advices on those, unfortunately.\n\n### Migration steps / manual in detail\n#### Timezone\nBefore heading into all UTC and timezone related changes, the first thing to mention is, that the Timezone class now\nhas some simple methods to apply or remove the offset of the timezone it represents from a local date time to create\nanother ((un)offsetted) local date time to help doing things manual. Just to keep in mind, when one of the following\nthings might seem to be a too breaking change.\n\n#### Entry start / end and timezone.\nIf are using the `Instant` based start / end api only, theoretically you do not need to change your code.\nPlease notify that `getStartUTC / getEndUTC` have been deprecated. Replace them at some point with `getStartAsInstant / getEndAsInstant`.\n\nIf are using the `LocalDateTime` based versions, you will most likely need to change your code as the `LocalDateTime` based `getStart / getEnd` and\n`setStart / setEnd` methods are now always referring to UTC and never to the timezones. If you want to set or get the date time including\nthe calendar timezone's offset, please use the newly introduced `getStartWithOffset / getEndWithOffset` and `setStartWithOffset / setEndWithOffset`.\nThey take care of adding/subtracting the timezone's offset - either from the assigned calendar or as parameter.\n\nSince some methods seem to do the same as before, it might feel a bit unnecessary to have the method names changed, but we wanted to assure, that it is always clear, what \"kind\" of date time the respective method is working with. Either with the default (UTC) or some explicit offset.\n\n```java\n// Reading and writing the UTC based backend\n\nTimezone calendarTimezone = ...;\nLocalDateTime utcBasedStartDate = ...\n\n// old\nentry.setStart(utcBasedStartDate, calendarTimezone);\n\n// new\nentry.setStart(utcBasedStartDate);\n```\n\n```java\n// Editing an existing entry inside an edit form\n\nDatePicker datePicker = ...\n\n// old\ndatePicker.setValue(entry.getStart());\n\n// ...value changed by date picker\n\nentry.setStart(datePicker.getValue());\n\n\n// new\ndatePicker.setValue(entry.getStartWithOffset());\n\n// ...value changed by date picker\n\nentry.setStartWithOffset(datePicker.getValue());\n```\n\nThe offset variants with the timezone parameter are intended to be used, when working on a new entry, that\nis not yet added to a calendar. Here the entry cannot access the calendar's timezone. In this case you should use these methods. In all\nother cases we recommend to let the entry handle the timezone conversion internally by using the offset variants without timezone parameter.\n\n```java\n// Creating a new entry and let the user fill it inside an edit form\nTimezone timezone = ...;\nDatePicker datePicker = ...\n\n// old\ndatePicker.setValue(entry.getStart(timezone));\n\n// ...value changed by date picker\n\nentry.setStart(datePicker.getValue(), timezone);\n\n\n// new\ndatePicker.setValue(entry.getStartWithOffset(timezone));\n\n// ...value changed by date picker\n\nentry.setStartWithOffset(datePicker.getValue(), timezone);\n```\n\nSummarized we recommend: when working with your backend (persisting, etc), use the UTC variants. When working with some kind\nof edit form, where the user can modify his/her entry based on the calendar's timezone, use the offset variants. For new entries, that have not yet been added to the calendar, use the offset variants with timezone parameter (in the .\n\n#### Entry related events date time\n##### Events and timezones\nAs with the entries also event times are now always UTC based. We tried to align the api the the entry's one in naming and behavior, so that the \"default\" date time is always UTC based, while the offset variant api provides the data with the calendar timezone's offset applied.\n\n```java\n// old\ncalendar.addTimeslotSelectedEvent(event -> {\n    Entry entry = new Entry()\n    entry.setStart(event.getStartDateTimeUTC());\n    entry.setEnd(event.getEndDateTimeUTC());\n\n    // if you need the offset variant, use for instance event.getStartDateTime();\n});\n\n// new\ncalendar.addTimeslotSelectedEvent(event -> {\n    Entry entry = new Entry()\n    entry.setStart(event.getStart());\n    entry.setEnd(event.getEnd());\n\n    // if you need the offset variant, use for instance event.getStartWithOffset();\n});\n```\n\n##### Renamed getters\nGetters in `TimeslotsSelectedEvent` have changed to be more aligned to the entry's and other events names to simplify the code to read a bit (e. g. from `getStartDateTime` to `getStart`). We added respective methods for getting the Instant and the offsetted variant.\n\n##### Removed getters in all-day related events\nSee chapter [**All-day behavior**](https://github.com/stefanuebe/vaadin_fullcalendar/wiki/FullCalendar-MigrationGuides#all-day-behavior) for details.\n\n#### Recurrence\n`setRecurring(boolean)` is gone. There is no replacement for this method, since recurrence is now detected automatically\nbased on if you have set any relevant recurrence property in the entry. See isRecurring() for details, which properties are relevant. This behavior has been taken over from the client side library.\n\n```java\n// old\nentry.setRecurring(recurring);\n\n// new\n// entry.setRecurring(recurring); // not needed anymore, is calculated automatically\n```\n\n`setRecurringStartDate / setRecurringEndDate` has lost the timezone parameter. Remove the timezone parameter. See chapter **All-day behavior** for details.\n\n```java\n// old\nentry.setRecurringStartDate(start.toLocalDate(), timezone);\n\n// new\nentry.setRecurringStartDate(start.toLocalDate());\n```\n\n#### All-day behavior\nThe displayment / interpretion of all-day entries and changing timezones has changed. In version 3.x an all-day entry was not bound to the day alone, but\nalso influenced by the timezone. This could lead to effects, that a holiday, which is on a specific day (e. g. New Year),\nspans two days, when switching the timezone. While it might somehow appear to be technically correct, it simply is not from the perspective of a calendar.\nA holiday - or in general an all-day event - is bound to the day, not the time. If you need a day spanning event, that\nis bound to the timezone and \"moves\", when changing the timezone, please create a time based event going over the whole\nday. With this change we align the server side behavior to the client side library and other big calendar providers (for instance Google Calendar).\n\nThis change also affects code at some points. You may have compilation errors for missing `Instant` or `LocalDateTime`\nbased methods, e. g. at `MoreLinkClickedEvent`. Those events provide a `LocalDate` based getter, which you\nshould use instead.\n\nOther events still may provide a date time based getter, where the returned value \"behaves\" now differently for all-day events\nas described above, e. g. all subclasses of `DateTimeEvent`, for instance the `TimeslotClickedEvent`. In 3.x when clicking\nthe 1st of March, the returned date may have been pointing to the 28th of February due to applied timezone\nconversion. Now the returned timestamp will always be the correct day at 00:00 UTC time. Simply ignore the\ntime part in this case or use the `LocalDate` getter.\n\n#### Accessing custom properties in eventDidMount or eventContent\nNot a required but a recommended change. If you have customized the appearance of your entries using one of the\ncallbacks `setEntryDidMount()` or `setEntryContent()` (or the respective client side variants) and you access\ncustom properties of an entry (for instance `description`), you should change the access to the newly introduced\n`getCustomProperty()` method. This method takes the custom property key and allows to define a fallback default value\nas second parameter.\n\n```java\n// set the custom property beforehand\nEntry someEntry = ...;\nsomeEntry.setCustomProperty(EntryCustomProperties.DESCRIPTION, \"some description\");\n\ncalendar.setEntryContentCallback(\"\" +\n    \"function(info) {\" +\n\n    // old\n    \"if(info.event.extendedProps && info.eventExtendedProps.customProperty && info.eventExtendedProps.customProperty.description) \"+\n    \"   console.log(info.event.extendedProps.customProperty.description);\" +\n    \"else \" +\n    \"   console.log('no description set');\" +\n\n    // new\n    \"   console.log(info.event.getCustomProperty('\" +EntryCustomProperties.DESCRIPTION+ \"', 'no description set'));\" + // get custom property with fallback\n\n    \"   /* ... do something with the event content ...*/\" +\n    \"   return info.el; \" +\n    \"}\"\n);\n```\n\nYou can use that method also in javascript subclasses of the FullCalendar. Please note, that this method is a custom javascript, which is added\nby us as soon as the client side `eventDidMount` or `eventContent` option has been set. Beforehand the method is not present\nand using it will lead to javascript errors.\n\n\n#### Deprecation\nSome methods have been deprecated due to typos or ambigious meaning. Please check any compiler warnings and apidocs\nregarding deprecated methods. They might be removed in any upcoming minor or major release without additional\nwarning.\n\n### Removed features\nIf you used a feature in your calendar, that an entry could have a different timezone for start and end:\nthis is not supported anymore out of the box. We know, that this is a step back regarding functionality,\nbut at this point we thing having a straight way of storing the times internally is a bigger and more\ncommon advantage, since this spares a lot of network overhead (entries do not need to be resend on\ntimezone change anymore). Implementing this would have taken too much time now without us knowing, if it is needed at all.\nInstead we wanted to bring you the new version as fast as possible.\n\nIf you need this feature again, please contact us and we will check how to bring it back in one or another way.",
      "category": "docs",
      "tags": [
        "migration-guides",
        "jsonarray",
        "arraynode",
        "jsonobject",
        "objectnode",
        "businesshours",
        "lumo",
        "vaadin",
        "eagerinmemoryentryprovider",
        "lazyinmemoryentryprovider",
        "inmemoryentryprovider",
        "eager",
        "customcalendarview",
        "anonymouscustomcalendarview",
        "entry",
        "key",
        "calendarlocale",
        "migration",
        "upgrade",
        "event"
      ]
    },
    {
      "id": "release-notes",
      "title": "Release-notes",
      "path": "Release-notes.md",
      "content": "## Index\n* [7.0.x](#70x)\n* [6.2.x](#62x)\n* [6.1.x](#61x)\n* [6.0.x](#60x)\n* [4.1.x](#41x)\n* [4.0.x](#40x)\n\n## 7.0.x\n[Details](https://github.com/stefanuebe/vaadin_fullcalendar/wiki/Release-notes-7.0)\n- updated to FullCalendar 6.1.20\n- increased required Vaadin version to 25\n- increased required Java version to 21\n- replaced elemental Json with Jackson 3, renamed some related methods\n- reworked BusinessHours\n- added `forRemoval` to deprecated API\n- renamed theme variant `LUMO` to `VAADIN` and integrated Aura into theming\n\n## 6.2.x\n[Details](https://github.com/stefanuebe/vaadin_fullcalendar/wiki/Release-notes-6.2)\n- added custom native event handlers for entries\n\n## 6.1.x\n[Details](https://github.com/stefanuebe/vaadin_fullcalendar/wiki/Release-notes-6.1)\n- added an optional Lumo theme for the addon\n\n## 6.0.x\n- updated to FullCalendar 6.1.6\n- Migrated from Polymer 3 to simple HTML Element based web component (no Lit nor Polymer)\n- Migrated source code from JavaScript to TypeScript (ongoing process, not yet finished)\n- Folder structures changed\n- Tag names prefixed with \"vaadin-\"\n- Content is now part of the light dom, thus styling will be easier\n- Client side eager loading removed, items will now always be fetched\n- Added prefetch mode to allow smoother transition between periods\n- Breaking changes regarding methods and fields (client side and server side). Also usage of private / protected modifiers in TS.\n- Added support for FC's \"multi-month\" views.\n- Added proper API for creating and registering custom views. Also added an internal handling of \"anonymous\" custom views created by initial options.\n- Deprecated code from previous versions has been removed\n- JsonItem has been removed, Entry is a \"normal field\" class again due to issues with proxying frameworks\n- setHeight has been minimalized to be more aligned with Vaadin standards. FC internal height settings / options are not\n  supported anymore. Calendar content will take only as much space as needed.\n- added type `RecurringTime` to allow setting an entry recurrence of more than 24h\n\n\nMinor changes:\n- getResources now may return null. Use getOrCreateResources.\n- CalendarLocale is now an enum. Use getLocale() to obtain the contained locale value.\n- week numbers within days is no longer available, weeknumbers are now always display inside days.\n- RenderingMode and alike namings have been named to DisplayMode / display to match the FC library naming. Also DisplayMode is now a top level class.\n- added resize observer to client side to automatically take care of resizes\n- added our own @NotNull annotation to allow support for Vaadin 23 and 24\n- Entry's method `copy(Class<T>)` has been renamed to `copyAsType(Class<T>)`.\n\nOther things that we may have overseen :)\n\nDue to lack of time, we have no release note details at this time. We tried to provide additional info as part of the migration page.\n\n## 4.1.x\n[Details](https://github.com/stefanuebe/vaadin_fullcalendar/wiki/Release-notes-4.1)\n- added EntryProvider, a data provider like callback based class to allow lazy loading entries based on the actual displayed timespan\n\n## 4.0.x\n[Details](https://github.com/stefanuebe/vaadin_fullcalendar/wiki/Release-notes-4.0)\n- introduced a new type JsonItem for creating item classes with dynamic property handling and automated conversion from and to json\n- integrated json item api into Entry types for dynamic type conversion. Due to that entries will not send all data to the client, when updating existing ones\n- changed date time handling on server side and communication to be always utc\n- entries are not resent to server anymore when changing timezone on server\n- entry data changes are now sent at once the the client\n- client side entries (\"event\") have now a getCustomProperty method inside eventDidMount or eventContent callbacks\n- removed official support of custom timezones for entries\n- renamed several methods\n- recurrence has some changes regarding enable recurrence and timezones\n",
      "category": "docs",
      "tags": [
        "release-notes",
        "lumo",
        "vaadin",
        "recurringtime",
        "migration",
        "upgrade",
        "entry",
        "event"
      ]
    },
    {
      "id": "samples",
      "title": "Samples",
      "path": "Samples.md",
      "content": "This page contains some samples to get you started with the FullCalendar addon. The samples are always based on the\nlatest version of the addon.\n\nSome samples use an in-memory entry provider when modifiying the calendar data to keep things simple. You may\nneed to adapt those parts, if you use a different entry provider.\n\nAlso we tried to keep things short. So you may see variables like `calendar`, `entry` or `entryProvider`\nwithout any declaration. In those cases these represent the basic types `FullCalendar`, `Entry` or `EntryProvider`.\n\nIf you find an outdated sample, please create an issue for that.\n\n## Creating a basic calendar instance and add an entry\n\nThe FullCalendar is a normal Vaadin component, that can be added to your view as any other component. By default it uses\nan eager loading in memory entry provider, with which you simply can add, update or remove calendar entries.\n\n```java\n// Create a new calendar instance and attach it to our layout\nFullCalendar calendar = FullCalendarBuilder.create().build();\ncalendar.setSizeFull();\ncontainer.add(calendar);\n\n// Create an initial sample entry\nEntry entry = new Entry();\nentry.setTitle(\"Some event\");\nentry.setColor(\"#ff3333\");\n\n// the given times will be interpreted as utc based - useful when the times are fetched from your database\nentry.setStart(LocalDate.now().withDayOfMonth(3).atTime(10, 0));\nentry.setEnd(entry.getStart().plusHours(2));\n\n// FC uses a data provider concept similar to the Vaadin default's one, with some differences\n// By default the FC uses a in-memory data provider, which is sufficient for most basic use cases.\ncalendar.getEntryProvider().asInMemory().addEntries(entry);\n```\n\n## Add, update or remove a calendar entry\n\nThis sample shows some basic CRUD functions using the in memory entry provider.\nWhen you use a callback entry provider, the add/remove methods are not available. Instead\nyou need to update your data structure and call the refresh methods. See details\nin the [EntryProvider](#Entry-providers) section.\n\n```java\n// ... create a form and binder to provide editable components to the user\nInMemoryEntryProvider<Entry> entryProvider = calendar.getEntryProvider().asInMemory();\n\nHorizontalLayout buttons = new HorizontalLayout();\nButton buttonSave;\nif (newInstance) {\n    buttonSave = new Button(\"Create\", e -> {\n        if (binder.validate().isOk()) {\n            // add the entry to the calendar instance and inform the client to update itself\n            entryProvider.addEntry(entry);\n            entryProvider.refreshAll();\n        }\n    });\n} else {\n    buttonSave = new Button(\"Save\", e -> {\n        if (binder.validate().isOk()) {\n            // update an existing entry in the client side\n            // this will only send changed data\n            entryProvider.refreshItem(entry);\n        }\n   });\n}\nbuttons.add(buttonSave);\n\nif (!newInstance) {\n    Button buttonRemove = new Button(\"Remove\", e -> {\n        entryProvider.removeEntry(entry);\n        entryProvider.refreshAll();\n    });\n    buttons.add(buttonRemove);\n}\n```\n\n## Calendar event handling\nThis sample shows how to react on calendar events, that are triggered by the user or the calendar lifecycle.\n\n```java\n/*\n * The day click event listener is called when a user clicks in an empty space inside of the\n * calendar. Depending of if the clicked point was a day or time slot the event will provide the\n * time details of the clicked point. With this info you can show a dialog to create a new entry.\n */\ncalendar.addTimeslotsSelectedListener((event) -> {\n// react on the selected timeslot, for instance create a new instance and let the user edit it\n    Entry entry = new Entry();\n   \n    entry.setStart(event.getStart()); // also event times are always utc based\n    entry.setEnd(event.getEnd());\n    entry.setAllDay(event.isAllDay());\n\n    entry.setColor(\"dodgerblue\");\n\n    // ... show an editor or do something else with the entry\n});\n\n/*\n * The entry click event listener is called when the user clicks on an existing entry.\n * The event provides the clicked event which might be then opened in a dialog.\n */\ncalendar.addEntryClickedListener((event) -> {\n    // react on the clicked entry, for instance let the user edit it\n    Entry entry = event.getEntry();\n\n    // ... show an editor or do something else with the entry\n});\n```\n\n## Entry providers\n\nEntry providers allow you to minimize the memory footprint by activating lazy loading for calendar entries. The only\nexception from that is the `EagerInMemoryEntryProvider`, which simulates the old behavior of the FullCalendar.\n\nThe following examples show the different types of `EntryProvider`s and how to use them. The eager variant is the way\nto get rid of the deprecated API in the `FullCalendar`.\n\n### In memory entry provider\n\nThe `InMemoryEntryProvider` caches all registered entries on the server side, but provides only a subset of them to\nthe client (i. e. the entries of the current shown period). This way you can use the CRUD API on the server side\nwithout the need of implementing it yourself. On the other hand the client will be kept free of unnecessary information.\n\n```java\n// load items from backend\nList<Entry> entryList = backend.streamEntries().collect(Collectors.toList());\n\n// init lazy loading provider based on given collection - does NOT use the collection as backend as ListDataProvider does\nLazyInMemoryEntryProvider<Entry> entryProvider = EntryProvider.lazyInMemoryFromItems(entryList);\n\n// set entry provider\ncalendar.setEntryProvider(entryProvider);\n\n// CRUD operations\n// to add\nEntry entry = new Entry();          // ... plus some init\nentryProvider.addEntries(entry);    // register in data provider\nentryProvider.refreshAll();         // call refresh to inform the client about the data change and trigger a refetch\n\n// after some change\nentryProvider.refreshItem(entry);   // call refresh to inform the client about the data change and trigger a refetch\n\n// to remove\nentryProvider.removeEntry(entry);\nentryProvider.refreshAll();         // call refresh to inform the client about the data change and trigger a refetch\n```\n\n### Using callbacks\n\nThe callback entry provider is a base implementation of the `EntryProvider` interface. It does care about how the\nbackend creates or stores the entry data, but only fetches the entries to show from it by passing a query. The backend\nis responsible for providing the entries and handle any changes to the data (e. g. due to calendar entry events).\n\n```java\n// the callback provider uses the given callback to fetch entries when necessary\nCallbackEntryProvider<Entry> entryProvider = EntryProvider.fromCallbacks(\n        query -> backend.streamEntries(query),\n        entryId -> backend.getEntry(entryId).orElse(null)\n);\n\n// set entry provider\ncalendar.setEntryProvider(entryProvider);\n\n// CRUD operations\n// to add\nEntry entry = new Entry();          // ... plus some init\nbackend.addEntry(entry);            // register in your backend\nentryProvider.refreshAll();         // call refresh to inform the client about the data change and trigger a refetch\n\n// after some change\nbackend.updateEntry(entry);         // inform your backend\nentryProvider.refreshItem(entry);   // call refresh to inform the client about the data change and trigger a refetch\n\n// to remove\nbackend.removeEntry(entry);         // remove from your backend\nentryProvider.refreshAll();   // call refresh to inform the client about the \n```\n\n### Custom implementation\n\nFeel free to create your own custom implementation, for instance to provide advanced internal caching on the server\nside. We recommend to extend the `AbstractEntryProvider` to start with.\n\nThe simples variant is similar to the callback variant, but with its own class:\n\n```java\nprivate static class BackendEntryProvider extends AbstractEntryProvider<Entry> {\n    private final EntryService service;\n\n    public BackendEntryProvider(EntryService service) {\n        this.service = service;\n    }\n\n    @Override\n    public Stream<Entry> fetch(@NonNull EntryQuery query) {\n        return service.streamEntries(query);\n    }\n\n    @Override\n    public Optional<Entry> fetchById(@NonNull String id) {\n        return service.getEntry(id);\n    }\n}\n```\n\n### Prefetch mode \nNormally an entry provider would only fetch data for the current period. Switching to an adjacent one could\nlead to flickering, since the calendar will most likely resize itself (because the now shown entries have a different\nsize, are on different days, the month is shorter or longer, etc).\n\nTo prevent that flickering, the calendar provides a feature called \"prefetch mode\". This by default activated feature \nensures, that the calendar will additionally fetch the previous and next period together with the current one. \nWhen switching to an adjacent period, the calender will not simply be empty, but show the prefetched entries to prevent\nvisual glitches. In the same time, the client will fetch the latest state for the current period and update it\nagain, so that the shown data is up-to-date. \n\nBe aware, that this feature leads to an increased amount of data transported between server and client, but in the same \ntime leads to a better user experience as the above mentioned flickering will be prevented.\n\nThe prefetch mode tries to obtain the necessary period based on the current view range unit. The supported units\nare \"day\", \"month\" and \"year\". If no range unit could be determined, a warning will show up. If the range unit\nis not supported, prefetch will not work (in this case the calendar behaves as if prefetch has been disabled).\n\nWe recomment to let this feature activated, unless you experience issues due to slow bandwidth or other network issues.\n\n```java\ncalendar.setPrefetchEnabled(false); // disables the prefetch feature\n```\n\n## Setting the calendar's dimensions\n\nYou may set the dimensions as with every other Vaadin component. The FC library also brings in some additional\nsettings for content height or an aspect ratio, that can be taken into account. These can be set\nvia the Options API.\n\nSee https://fullcalendar.io/docs/sizing for details.\n\n## Using timezones\nYou can set a timezone to the calendar, so that your UTC-based entries are automatically shown with the respective\ntimezone's offset at the client. \n\nPlease note, that this only affects the FullCalendar. Vaadin date pickers, that are for instance there to edit\ncalender entries in a form have to be configured respectively. \n\n```java\n// FC allows to show entries in a specifc timezone. Setting a timezone only affects the client side\n// and might be interesting, when editing those entries in some kind of edit form\n\nTimezone tzBerlinGermany = new Timezone(ZoneId.of(\"Europe/Berlin\"));\ncalendar.setTimezone(tzBerlinGermany); // will rerender the client side and show all times 1-2 hours \"later\".\n\n// We can also reset the timezone to default.\ncalendar.setTimezone(Timezone.UTC);\n\n// We can also read the browsers timezone, after the component has been attached to the client side.\n// There are other ways to obtain the browser's timezone, so you are not obliged to use the listener.\ncalendar.addBrowserTimezoneObtainedListener(event -> calendar.setTimezone(event.getTimezone()));\n\n// If you want to let the calendar obtain the browser time zone automatically, you may simply use the builder.\n// In that case as soon as the client connected, it will set it's timezone in the server side instance.\nFullCalendarBuilder.create().withAutoBrowserTimezone().build();\n\n// Entries use internally utc to define times. The LocalDateTime and Instant methods setStart/End have the same effect.\nentry.setStart(Instant.now()); // UTC\nentry.setEnd(LocalDateTime.now()); // UTC\n\n// Entry provides some additional convenience methods to handle the current calendar's timezone's offset, e.g. to allow easy\n// integration into edit forms.\ncalendar.setTimezone(tzBerlinGermany); // times are now 1-2 hours \"ahead\" (depending on daylight saving)\nentry.setStart(LocalDate.of(2000, 1, 1).atStartOfDay());\n\nLocalDateTime utcStart = entry.getStart(); // will be 2000-01-01, 00:00\nLocalDateTime offsetStart = entry.getStartWithOffset(); // will be 2000-01-01, 01:00\n\n// ... modify the offset start, for instance in a date picker\n// e.g. modifiedOffsetStart = offsetStart.plusHours(5);\nLocalDateTime modifiedOffsetStart = offsetStart.plusHours(5);\n\nentry.setStartWithOffset(modifiedOffsetStart); // automatically takes care of conversion back to utc\nutcStart = entry.getStart(); // will be 2000-01-01, 04:00\noffsetStart = entry.getStartWithOffset(); // will be 2000-01-01, 05:00\n```\n\n## Passing custom initial options in Java\n\nYou can fully customize the client side options in Java by passing a json object when creating the FullCalendar.\nPlease be aware, that some options are always set, regardless of the values you set. Please check the\nApiDocs of the `withInitialOptions` method (or respective constructors) for details\n\nThe following example shows the default initial options as they are set internally by the web component.\n\n```java\nimport org.vaadin.stefan.fullcalendar.JsonFactory;\n\n// ...\n\nObjectNode initialOptions = JsonFactory.createObject();\ninitialOptions.put(\"height\", \"100%\");\ninitialOptions.put(\"timeZone\", \"UTC\");\ninitialOptions.put(\"header\", false);\ninitialOptions.put(\"weekNumbers\", true);\ninitialOptions.put(\"eventLimit\", false); // pass an int value to limit the entries per day\ninitialOptions.put(\"navLinks\", true); \ninitialOptions.put(\"selectable\", true);\n\ncalendar = FullCalendarBuilder.create().withScheduler().withInitialOptions(initialOptions).build();\n```\n\n## Style the calendar\n\n### Vaadin Theming\nThe calendar provides a built-in Vaadin theme variant, that applies some styling from the current Vaadin theme, like\nsizes, colors, etc. It is active by default. \n\nPlease note, that there might be parts, that have been forgotten or not looking as expected. \nAlso any additional custom stylings may override the Vaadin stylings. If you find anything, that looks suspicious,\nplease create an issue. \n\nTo remove the Vaadin theme, simply remove the theme variant, as you would do with other Vaadin components. Please note,\nthat the overall styling still may affect your calendar component in some ways.\n\n```java\ncalendar.removeThemeVariant(FullCalendarVariant.VAADIN);\n```\n\n### Global / custom styles\n\nThe FullCalendar client element is part of the light dom and thus can be styles via plain css. For any details\non styling the FullCalendar please refer to the FC docs (regarding css properties, classes, etc.).\n\nThe styles can be defined as you are used to using the Vaadin theme mechanism.\n\nSample styles.css, that utilizes custom css properties from Lumo.\n\n```css\n/* change the border color of the fc in a global way*/\n.fc {\n    --fc-border-color: #ddd;\n}\n\n/* change the border color of the fc for dark themes*/\n[theme~=\"dark\"] .fc {\n    --fc-border-color: #333;\n}\n\n/* change the appearance of the week and day number to a more button like style when hovering */\n.fc a:is(.fc-daygrid-week-number, .fc-daygrid-day-number) {\n    background: transparent;\n    font-size: 12px;\n    transition: background 200ms ;\n    border-radius: 3px;\n}\n\n.fc a:is(.fc-daygrid-week-number, .fc-daygrid-day-number):hover {\n    background: var(--lumo-primary-color-10pct);\n    text-decoration: none;\n}\n\n.fc a.fc-daygrid-day-number {\n    padding-left: 6px;\n    padding-right: 6px;\n}\n```\n\n## Show the current shown time interval (e. g. month) with Vaadin components\n\nYou can use the \"dates rendered event\" to show details about the current shown period in separate elements instead\nof the built-in FullCalendar header.\n\n```java\nprivate void init() {\n    // The element that should show the current interval.\n    HasText intervalLabel = new Span();\n\n    // combo box to select a view for the calendar, like \"monthly\", \"weekly\", ...\n    ComboBox<CalendarView> viewBox = new ComboBox<>(\"\", CalendarViewImpl.values());\n    viewBox.addValueChangeListener(e -> {\n        CalendarView value = e.getValue();\n        calendar.changeView(value == null ? CalendarViewImpl.DAY_GRID_MONTH : value);\n    });\n    viewBox.setValue(CalendarViewImpl.DAY_GRID_MONTH);\n\n    /*\n     * The view rendered listener is called when the view has been rendererd on client side\n     * and FC is aware of the current shown interval. Might be accessible more directly in\n     * future.\n     */\n    calendar.addDatesRenderedListener(event -> {\n        LocalDate intervalStart = event.getIntervalStart();\n        CalendarView cView = viewBox.getValue();\n\n        String formattedInterval = ... // format the intervalStart based on cView. See the demos for examples.\n\n        intervalLabel.setText(formattedInterval);\n    });\n}\n```\n\n## Creating a background entry\nA background entry is an entry, that is rendered behind all other entries. It is not clickable and\nhas no tooltip. It is useful for marking a time range, e. g. for marking a vacation.\n\n```java\nEntry entry = new Entry();\n// ... setup entry details\n        \nentry.setDisplayMode(DisplayMode.BACKGROUND);\ncalendar.addEntry(entry);\n```\n\n## Adding business hours\nYou can define business hours for each day of the week to provide visual feedback to the user, when someone is available\nor not. If you don't define any business hours, the calendar will assume, that the business hours are from 0:00 to 24:00 for each day.\n\nNon-business hours are grayed out in the calendar.\n\n```java\n// Single instance for \"normal\" business week (mo-fr)\ncalendar.setBusinessHours(BusinessHours.businessWeek().start(LocalTime.of(9, 0)).end(LocalTime.of(17, 0)));\n\n// Multiple instances\ncalendar.setBusinessHours(\n    BusinessHours.businessWeek().start(9).end(17),\n    BusinessHours.of(DayOfWeek.SATURDAY).start(10).end(14)\n);\n\n// Single instance for \"each day from 9am to midnight\"\ncalendar.setBusinessHours(BusinessHours.allDays().start(9));\n```\n\n## Using the Scheduler\nThe scheduler is a commercial plugin of the FullCalendar library, that provides some additional features like\nresource related calendar entries and additional views.  \n\n### Activating the Scheduler\n\n```java\nFullCalendar calendar = FullCalendarBuilder.create().withScheduler().build();\n// scheduler options\n((Scheduler) calendar).setSchedulerLicenseKey(\"YourFullCalendarSchedulerKey\");\n```\n\n### Adding a resource to a calendar and link it with entries\n```java\nResource resource = new Resource(null, s, color);\ncalendar.addResource(resource);\n\n// When we want to link an entry with a resource, we need to use ResourceEntry\n// (a subclass of Entry)\nResourceEntry entry = new ResourceEntry(null, title, start.atStartOfDay(), start.plusDays(days).atStartOfDay(), true, true, color, \"Some description...\");\nentry.setResource(resource);\ncalendar.addEntry(entry);\n```\n\n### Handling change of an entry's assigned resource by drag and drop\n```java\ncalendar.addEntryDroppedListener(event -> {\n    event.applyChangesOnEntry();\n\n    Entry entry = event.getEntry();\n\n    if(entry instanceof ResourceEntry) {\n        Set<Resource> resources = ((ResourceEntry) entry).getResources();\n        if(!resources.isEmpty()) {\n            // do something with the resource info\n        }\n    }\n});\n```\n\n### Switching to a timeline view\n```java\ncalendar.changeView(SchedulerView.TIMELINE_DAY);\n```\n\n### Activate vertical resource view\n```java\ncalendar.setGroupEntriesBy(GroupEntriesBy.RESOURCE_DATE);\n```\n\n### Creating a resource based background entry\n```java\nResourceEntry entry = new ResourceEntry();\n// ... setup entry details, including addResource()\n\nentry.setDisplayMode(DisplayMode.BACKGROUND);\ncalendar.addEntry(entry);\n```\n\n### Creating hierarchical resources\n```java\n// Create a parent resource. When adding the sub resources first before adding the parent to the calendar,\n// the sub resources are registered automatically on client side and server side.\n\nResource parent = new Resource();\nparent.addChildren(new Resource(), new Resource(), new Resource());\n\ncalendar.addResource(parent); // will add the resource and also it's children to server and client\n\n// add new resources to already registered parents\nResource child = new Resource()\nparent.addChild(child);\ncalendar.addResource(child); // this will update the client side\n\n// or remove them from already registered ones\ncalendar.removeResource(child); \nparent.removeChild(child); \n```\n\n### Making a resource entry draggable between resources\n```java\n// activate for the client to have an entry being draggable between resources\nresourceEntry.setResourceEditableOnClientSide(true);\n\n// update the entry on the client side, if it is already added to the calendar\ncalendar.refreshAll();\n```\n\n## Using tippy.js for description tooltips\nBy default the calendar does not provide tooltips for entries. However, you can easily integrate any type of\ntooltip mechanism or library, for instance by simply applying an html title or using a matured tooltip library\nlike tippy.js.\n\nThis sample shows how to easy integrate tippy.js into a custom subclass of FullCalendar to show an entry's description\nas a tooltip when hovering the entry inside the FC. Please customize the example as needed.\n\n1. Create a new TypeScript file inside the frontend folder of your project. It needs to extend either FullCalendar or\n   FullCalendarScheduler. This example utilized FullCalendarScheduler. If you want to use the normal FC, simply remove\n   all the -Scheduler parts. You may also have a simply JavaScript file, in that case you need to change the\n   following script a bit.\n\nfull-calendar-with-tooltips.ts\n\n```typescript\nimport {FullCalendarScheduler} from 'Frontend/generated/jar-resources/vaadin-full-calendar/full-calendar-scheduler';\nimport tippy from 'tippy.js';\n\n\nexport class FullCalendarWithTooltip extends FullCalendarScheduler {\n    private _tooltipInitialized: boolean = false;\n\n    initCalendar() {\n        super.initCalendar();\n\n        // Prevent duplicate event handler registration on re-initialization\n        if (this._tooltipInitialized) {\n            return;\n        }\n        this._tooltipInitialized = true;\n\n        this.calendar!.setOption(\"eventDidMount\", e => {\n            this.initTooltip(e);\n        });\n    }\n\n    initTooltip(e: any) {\n        if (e.event.title && !e.isMirror) {\n            e.el.addEventListener(\"mouseenter\", () => {\n                let tooltip = e.event.getCustomProperty(\"description\", e.event.title);\n\n                e.el._tippy = tippy(e.el, {\n                    theme: 'light',\n                    content: tooltip,\n                    trigger: 'manual'\n                });\n\n                e.el._tippy.show();\n            })\n\n            e.el.addEventListener(\"mouseleave\", () => {\n                if (e.el._tippy) {\n                    e.el._tippy.destroy();\n                }\n            })\n        }\n    }\n}\n\ncustomElements.define(\"full-calendar-with-tooltip\", FullCalendarWithTooltip);\n\n```\n\n2. Now create a simple JavaClass, that utilizes your js file. This Java class also imports the needed CSS files.\n\n```java\n@Tag(\"full-calendar-with-tooltip\")\n@JsModule(\"./full-calendar-with-tooltip.js\")\n@CssImport(\"tippy.js/dist/tippy.css\")\n@CssImport(\"tippy.js/themes/light.css\")\npublic class FullCalendarWithTooltip extends FullCalendarScheduler {\n\n    public FullCalendarWithTooltip() {\n    }\n}\n```\n\nAs shown in the subclass sample, you may also use the FullCalendarBuilder to create your custom class.\n\n## Customize the entry content\n\nFC allows you to modify the content of an entry. The given string will be interpreted as js function on client side\nand attached as `eventContent` callback. See https://fullcalendar.io/docs/content-injection (\"...a function\") for\ndetails.\n\n```java\ncalendar.setEntryDidMountCallback(\"\"\"\n        function(info) {\n            info.el.id = \"entry-\" + info.event.id;\n        }\n        \"\"\");\n\n```\n\nInside the javascript callback you may access the entry's default properties or custom ones, that\nyou can set beforehand, using the custom property api (e. g.`setCustomProperty(String, Object)`).\nIn the callback you can access the custom property in a similar way, using `getCustomProperty(key)`\nor `getCustomProperty(key, defaultValue)`.\n\nPlease be aware, that the entry content callback has to be set before the client side is attached. Setting it afterwards\nhas no effect.\n\nAlso make sure, that your callback function does not contain any harmful code or allow cross side scripting.\n\n```java\n// set the custom property beforehand\nentry.setCustomProperty(Entry.EntryCustomProperties.DESCRIPTION, \"some description\");\n\n// use the custom property\ncalendar = FullCalendarBuilder.create()\n        .withEntryContent(\n                \"function(info) {\" +\n                        \"   let entry = info.event;\" +\n                        \"   console.log(entry.title);\" + // standard property\n                        \"   console.log(entry.getCustomProperty('\" + Entry.EntryCustomProperties.DESCRIPTION+ \"'));\" + // custom property\n                        \"   /* ... do something with the event content ...*/\" +\n                        \"   return info.el; \" +\n                        \"}\"\n        )\n        // ... other settings\n        .build();\n\n// or use the custom property in the entryDidMountCallback\n```\n\n## Use native javascript events for entries\nSometimes the available events are not enough. For that purpose, we added native event listeners for calendar entries. \nThese allow you to setup JavaScript events for each entry, e.g. a mouse over event handler. Inside these event handlers \nyou may also access the created entry dom element.\n\nCustom native event handlers are added to the FullCalender object. They will then be applied to each created\nentry object (using the entryDidMount callback).\n\nTo add an event handler, simply call the method `addEntryNativeEventListener` on the calendar. The first parameter\nis the JavaScript event name (e.g. \"mouseover\"), the second parameter is the callback, that shall be used for\nthat event. Please be aware, that we do NOT check or sanitize the given JavaScript. It is up to you to prevent\nmalicious code from being sent to your users.\n\nInside the event callback, you may access the entryDidMount argument object, that contains additional information\nabout the current entry. See the official docs (https://fullcalendar.io/docs/event-render-hooks)\nfor more details about which details it provide.\n\n```java\nFullCalendar calendar = new FullCalendar();\n\n// ... other configurations\n\n// write the js event, the current entry info and the current entry's element to the browser console.\ncalendar.addEntryNativeEventListener(\"mouseover\", \"e => console.warn(e, info.event, info.el)\");\n\nadd(calendar);\n```\n\nPlease be aware, that due to the design of the used library, these event handlers have to be setup before the\ncalendar is initialized on the client side.\n\nThis sample will change the element style, when the mouse moves over it and changes back, when leaving the element.\n\n```java\ncalendar.addEntryNativeEventListener(\"mouseover\", \"e => info.el.style.opacity = '0.5'\");\ncalendar.addEntryNativeEventListener(\"mouseout\", \"e => info.el.style.opacity = ''\");\n```\n\nYou can also access the client side dom to utilize other elements, like the parents. With this you may for instance\ncall a server side method.\n\nThe following sample shows, how a client callable method in the current view, containing the FullCalendar object, can\nbe called, when right clicking the entry. With this info you can for instance open a custom popup as a context menu.\n\n```java\n@Route(...)\npublic void MyCalendarView extends VerticalLayout {\n    public MyCalendarView() {\n\n        FullCalendar calender = new FullCalendar();\n        // adds a contextmenu / right client event listener, that calls our openContextMenu. \n        // \"this\" is the fc object, \"this.el\" is the Flow element and \"this.el.parentElement\" is our current view.\n        // This hierarchy access may changed, when you nest the FC into other containers. \n\n        calendar.addEntryNativeEventListener(\"contextmenu\",\n                \"e => this.el.parentElement.$server.openContextMenu(info.event, e.clientX, e.clientY)\");\n\n        add(calender);\n    }\n\n    @ClientCallable\n    public void openContextMenu(JsonObject e, int pointerX, int pointerY) {\n        System.out.println(e);\n        System.out.println(pointerX);\n        System.out.println(pointerY);\n    }\n} \n```\n\nYou can combine the event handlers with a custom entryDidMount callback, if you want additional customizations\nof the entries. The FC will take care of combining the event handlers and you EDM callback\n```java\ncalendar.setEntryDidMountCallback(\"\"\"\n       function(info) {\n           console.warn(\"my custom callback\");\n       }\"\"\");\n\ncalendar.addEntryNativeEventListener(\"mouseover\", \"e => info.el.style.opacity = '0.5'\");\ncalendar.addEntryNativeEventListener(\"mouseout\", \"e => info.el.style.opacity = ''\");\n```\n\nThe following sample shows how to utilize the entryDidMount callback, the native event handlers and the\n[Popup addon](https://vaadin.com/directory/component/popup) to show a context menu. In this sample, the context\nmenu is based on a ListBox.\n\n```java\n@Route(...)\npublic void MyCalendarView extends VerticalLayout {\n\n    private Popup popup;\n   \n    public MyCalendarView() {\n\n        FullCalendar calender = new FullCalendar();\n        // adds a contextmenu / right client event listener, that calls our openContextMenu. \n        // \"this\" is the fc object, \"this.el\" is the Flow element and \"this.el.parentElement\" is our current view.\n        // This hierarchy access may changed, when you nest the FC into other containers. \n\n        calendar.addEntryNativeEventListener(\"contextmenu\",\n                \"e => {\" +\n                        \"   e.preventDefault(); \" +\n                        \"   this.el.parentElement.$server.openContextMenu(info.event.id);\" +\n                        \"}\");\n\n        // by default, the entry element has no id attribute. Therefore we have to add it ourselves, using the \n        // entry id, that is by default an auto generated UUID\n        calendar.setEntryDidMountCallback(\"\"\"\n                function(info) {\n                    info.el.id = \"entry-\" + info.event.id;\n                }\"\"\");\n\n    }\n\n    @ClientCallable\n    public void openContextMenu (String id){\n        initPopup(); // init the popp\n\n        popup.removeAll(); // remove old content\n\n\n        // setup the context menu\n        // (side note: the list box shows a checkmark, when selecting an item, therefore you may want to use a different \n        // component for a real application or hide the checkmark with CSS)\n        ListBox<String> listBox = new ListBox<>();\n        listBox.setItems(\"Option A\", \"Option B\", \"Option C\");\n        listBox.addValueChangeListener(event -> {\n            Notification.show(\"Selected \" + event.getValue());\n            popup.hide();\n        });\n\n        popup.add(listBox);\n        popup.setFor(\"entry-\" + id);\n\n        popup.show();\n    }\n\n    private void initPopup () {\n        if (popup == null) {\n            popup = new Popup();\n            popup.setFocusTrap(true);\n            add(popup);\n        }\n    }\n} \n```\n\n## Creating a subclass of FullCalendar for custom mods\nThe FullCalendar itself is just a simple Vaadin component on the server and client side, that can be extended\nand customized beyond the default behavior - be aware, that anything you do here is on your own risk and that\nsupport for this use case is limited. \n\nThe client side has the following methods, that you can override / extend to customize the behavior. There are\nothers, but they should normally not be overridden - except for you know what you do ;) \n\n* connectedCallback() - called when the component is attached to the dom\n* initCalendar() - called when the calendar is initialized - only called once\n* createInitOptions(initialOptions) - called when the calendar is initialized. You can modify the initial options here.\n* createEventHandlers() - called when the calendar is initialized. You can modify the event handlers here.\n\nBe aware, that during `connectedCallback()` and before calling `initCalendar()` no internal calendar\nobject is available. Calling `this.calendar` will automatically infer `initCalendar()` and thus can lead\nto unwanted side effects. Therefore, if you want to set options, add entries or do other things with the\ncalendar object, do it after `super.initCalendar()` has been called.\n\nIf you want to modifiy options, that are passed into the calendar object, you can extend the method\n`createInitOptions(initialOptions)` and return a modified options object.\n\nIf you want to modify or extend the event handlers, you can override the method `createEventHandlers()`-\n\nWe recommend to use the `override` modifier on overridden methods to make sure, that the method is\nalways up-to-date.\n\n1. Create a custom web component\n   Create a custom component, that extends FullCalendar or FullCalendarScheduler.\n\n\n```typescript\nimport {FullCalendar} from '@vaadin/flow-frontend/vaadin-full-calendar/full-calendar';\n\nexport class MyFullCalendar extends FullCalendar {\n    connectedCallback() {\n        super.connectedCallback();\n\n        // do something with this.calendar\n        // ...\n    }\n\n    initCalendar() {\n        super.initCalendar();\n\n        // do something with this.calendar\n        // ...\n    }\n\n    createInitOptions(initialOptions) {\n        let options = super.createInitOptions(initialOptions);\n        // modify the initial options\n        // attention: this.calendar is not available here!\n        // ...\n\n        return options;\n    }\n\n    createEventHandlers() {\n        // modify the event handlers\n        // attention: this.calendar is not available here!\n        // ...\n\n        return super.createEventHandlers();\n    }\n}\n\ncustomElements.define(\"my-full-calendar\", MyFullCalendar);\n```\n\n2. Create a subclass of FullCalendar\n\n```java\nimport com.vaadin.flow.component.Tag;\nimport com.vaadin.flow.component.dependency.JsModule;\nimport org.vaadin.stefan.fullcalendar.FullCalendar;\n\n@Tag(\"my-full-calendar\")\n@JsModule(\"./my-full-calendar.js\")\npublic class MyFullCalendar extends FullCalendar {\n\n    public MyFullCalendar() {\n    }\n}\n```\n\n3. Use this class in your code\n\n```java\ncalendar = new MyFullCalendar();\n```\n\nYou can even use the FullCalendarBuilder to create your custom class. Be aware, that your\ncustom class needs to provide all constructors, that the extended FullCalendar has.\n\n```java\ncalendar = FullCalendarBuilder.create().withCustomType(MyFullCalendar.class).build();\n```   \n\n## Entry data utilities\n\n### Handling data changes in events\n\nWhen an event occurs, you may want to check or apply the event's changes against the related calendar item.\n\nYou may either do this manually or use the provided utility functions, that are part of the `EntryDataEvent` classe\n(and subclasses).\n\nIt might come in handy, that you get changes from an event in form of an `Entry` object instead of the different\nchanged values of the event itself.\n\nTo do so, you can simply call the method `createCopyBasedOnChanges()` method, that the `EntryDataEvent` provides.\nThis will create complete copy of the entry but with the changes of the event applied. This copy will not be added to\nthe calendar and is simply intended for data checks.\n\nTo apply any incoming changes to the related `Entry`, the event class provides the method `applyChangesOnEntry()`.\nThis will override the entry with the event data, but not automatically update the client side. This is up to you\nto do with an `refreshItem()` or `refreshAll()` call. Also any backend updates (except for the in memory provider)\nneeds to be handled by your logic.\n\n```java\n// directly apply the changes\ncalendar.addEntryDroppedListener(event -> {\n    event.applyChangesOnEntry(); // includes now the allDay attribute if sent by client\n});\n\n// create a copy to do some business logic checks\ncalendar.addEntryDroppedListener(event -> {\n    Entry copy = event.createCopyBasedOnChanges();\n\n    if(copy.getStartAsLocalDate().isBefore(someRequiredMinimalDate) /* do some background checks on the changed data */) {\n        event.applyChangesOnEntry();\n        event.getSource().getEntryProvider().refreshItem(event.getEntry()); // refresh the entry to update the UI\n    }\n});\n```\n\n### Create a temporary copy\n\nThe `Entry` class provides a copy API, that allows you to create a copy of an entry or from a given entry. With this you\ncan easily create temporary instances for an edit dialog without needing to write a lot of \"get-set\" calls. This is\nuseful, when your binders work with the `setBean` api\n\nPlease be aware, that this api is considered \"experimental\" and might not work in every special use case or with every\ncustom property key.\n\n```java\nEntry tmpEntry = entry.copy(); // create a temporary copy\n// you may also call copyAsType to allow the copy to be of a different type\n\nBinder<Entry> binder = new Binder<>();\n\n// ... init binder\n\nbinder.setBean(tmpEntry); // you can of course also use the read/writeBean api\n\n// modify the bound fields\n\nif (binder.validate().isOk()) {\n    entry.copyFrom(tmpEntry); // this will overwrite the entry with the values of the tmpEntry\n    // ... update the backend as needed, e.g. by calling refreshItem on the entry provider\n}\n```\n\nAlternatively you can use the copy API in a JPA fashion, where new instances are created on changes.\n\n```java\nEntry tmpEntry = entry.copy(); // create a temporary copy\n\n// ... modify the temporary copy\n\n// return a new copy at the end without changing the initial entry\nreturn tmpEntry.copy();\n```",
      "category": "docs",
      "tags": [
        "samples",
        "fullcalendar",
        "entry",
        "entryprovider",
        "eagerinmemoryentryprovider",
        "inmemoryentryprovider",
        "abstractentryprovider",
        "entrydataevent",
        "scheduler",
        "resource",
        "event"
      ]
    },
    {
      "id": "scheduler-license",
      "title": "Scheduler-license",
      "path": "Scheduler-license.md",
      "content": "The FullCalendar Scheduler library has a different license model then the basic FullCalendar.\n\nFor more details please visit https://fullcalendar.io/license and https://fullcalendar.io/docs/plugin-index\n\n**This addon does not provide any commercial license for the Scheduler. The license model of MIT does only affect the additional files of this addon, not the used original files.**\n\n## Activating the Scheduler - [Example](https://github.com/stefanuebe/vaadin_fullcalendar/wiki/FullCalendar-Scheduler-Examples#activating-the-scheduler)\n\nBy default the scheduler is not active, when you use a FullCalendar instance. To have an instance with scheduler activated, use the `.withScheduler(...)` method of the `FullCalendarBuilder`.\n\nThis method will throw an exception, if the scheduler extension is not on the class path.\n\nTo link a resource with entries, use the Entry subclass `ResourceEntry`.",
      "category": "docs",
      "tags": [
        "scheduler-license",
        "fullcalendarbuilder",
        "resourceentry",
        "scheduler",
        "resource",
        "entry",
        "event"
      ]
    },
    {
      "id": "release-notes-detail-release-notes-4.0",
      "title": "New base type JsonItem for calendar items",
      "path": "release-notes-detail/Release-notes-4.0.md",
      "content": "This page gives you an overview of the major changes, that came with the release of [FullCalendar for Flow, version 4.0](https://vaadin.com/directory/component/full-calendar-flow).\n\nIf you are going to update from 3.x, please also have a look into the [migration guide](https://github.com/stefanuebe/vaadin_fullcalendar/wiki/FullCalendar-MigrationGuides#migrating-from-3x--40).\n\nIf you are new to the FullCalendar or want to see, what might have changed in code, please visit our [examples](https://github.com/stefanuebe/vaadin_fullcalendar/wiki/FullCalendar-Examples).\n\n# New base type JsonItem for calendar items\nWith this major version we introduced a new based type for calendar items (e.g. `Entry`). JsonItem provides a dynamic property approach, that allows defining properties via keys. Those keys provide details and rules for the automatic conversion of items from and to json.\n\nCurrently the Entry and it's subclasses implement JsonItem. Other implementations will follow in future.\n\nSee the [examples page](https://github.com/stefanuebe/vaadin_fullcalendar/wiki/FullCalendar-Examples#use-the-low-level-jsonitem-api-to-modify-a-calendar-item) for some details.\n\n# Date Time communication changed to UTC based\n\nWhile internally entries stored time values as UTC already beforehand, the communication was always based on the calendar's timezone. This led to the issue, that on a timezone change, the entries had to be resent. While this might be no problem for some use cases, other scenarios could lead to a freezing UI, when having many entries and switching the timezone.\n\nTo improve the performance here and unify the transport of times, we decided to introduce this breaking change and let the communication always be UTC based.\n\nThis means also, that custom timezones for Entries are not supported anymore as they have been before. If you used that feature, you may need to catch that missing feature in your edit forms and displayment. We apologize for that inconvenience.\n\nAlso the behavior of all day entries regarding timezones has changed. All day entries are now no longer affected by timezones.\n\nPlease see the [migration guide](https://github.com/stefanuebe/vaadin_fullcalendar/wiki/FullCalendar-MigrationGuides#migrating-from-3x--40) for more details.\n\n# Changed entry data is now sent at once\nIn 3.x the server instance did not check, if you already sent some data to the client. Instead, it fired a java script call for every entry CRUD call. This means, that for instance calling `addEntry()` 20 times, the server called the respective client side api 20 times and also the calendar hat to rerender 20 times.\n\nStarting with 4.0.x those server side data changes are collected internally and sent at once. This means, you can call the CRUD api as often as you want in a request - there will only be one call on the client side (or to be more concrete maximal 3  one for add, update and remove respectively - this may be also change in future for a more optimal handling).\n\n# Custom properties on the client side\n\nWhen you customize the entry content via setEntryContent or setEntryDidMount, you may now access custom properties via a dedicated getter instead of traversing through multiple properties.\n\nSee the [example page](https://github.com/stefanuebe/vaadin_fullcalendar/wiki/FullCalendar-Examples#customize-the-entry-content) for details.\n\n# Recurrence\nThere are minor changes to recurrence, that most likely will need your attention regarding compiler issues. See [this chapter](https://github.com/stefanuebe/vaadin_fullcalendar/wiki/FullCalendar-MigrationGuides#recurrence) for details.\n\n- renamed several methods\n- recurrence has some changes regarding enable recurrence and timezones\n\n# Other\nSome methods have become deprecated. Please check the compiler warnings and try to replace them soon.",
      "category": "docs",
      "tags": [
        "release-notes-4.0",
        "entry",
        "migration",
        "upgrade",
        "event"
      ]
    },
    {
      "id": "release-notes-detail-release-notes-4.1",
      "title": "Release-notes-4.1",
      "path": "release-notes-detail/Release-notes-4.1.md",
      "content": "This page gives you an overview of the major changes, that came with the release of [FullCalendar for Flow, version 4.1](https://vaadin.com/directory/component/full-calendar-flow).\n\nPlease also have a look on our [migration guide](https://github.com/stefanuebe/vaadin_fullcalendar/wiki/FullCalendar-MigrationGuides#migrating-from-40--41) and our [examples](https://github.com/stefanuebe/vaadin_fullcalendar/wiki/FullCalendar-Examples).\n\n## Entry Provider\nWith 4.1 we introduced a new way of providing calendar items. Up to now the official supported way was to register all known entries to the server side, which itself would push it then to the client. This means that both, the server and the client, needed to keep all the data in memory.\n\nWith the newly introduces `EntryProvider` we provide a way of providing entries similar to the common Vaadin `DataProvider`. When using an `EntryProvider`, the client will control via parameters, which entries are to be fetched to the client. The server on the otherside only needs to create and provide the entries, that are requested.\n\n### In memory variants\nOf course, it is up to the server side, how and when the entries are created. Beside the base interface we also introduced the sub interface `InMemoryEntryProvider`, which comes in two pre-implemented variants\n* EagerInMemoryEntryProvider\n* LazyInMemoryEntryProvider\n\nThe eager variant is an exception to the above described behavior of the `EntryProvider`. While it implements the `EntryProvider` interface, it behaves like the old way the FullCalendar transported entries to the client: it pushes them itself. So if you still want to have all entries on the client available at any time (e. g. when your application operats in a scope with a slow network access), you can use this instance.\n\nThe lazy variant is a mixture between the old and the new way. It acts a bit like the common `ListDataProvider`, where all known entries are cached on the server side, but only the necessary ones are fetched from the client.\n\n### Initial EntryProvider on FullCalendar\nWith this update the FullCalendar itself does not cache any entries directly, but uses an `EntryProvider` for all cases. A new FullCalendar is initialized with an instance of the `EagerInMemoryEntryProvider`. This shall prevent any breaking changes for updating applications. Yet we recommend to change to a different `EntryProvider` due to the advantages of fetching only the necessary entries.\n\n### Entry CRUD operations on FullCalendar\nAll entry CRUD operations (e. g. `addEntries()`) are therefore delegated to the calendar's provider, when that provider supports those methods. For that, the provider has to be at least an `InMemoryEntryProvider`. If you want to use the `update` api, it needs to be the `EagerInMemoryEntryProvider`, since for the lazy variant the update api is not necessary any more as updating the client side is handled by the `refresh` api.\n\nBe aware, that any calls to the CRUD operations will lead to an exception, if you don't use the correct data provider.\n\n### Callback Entry Provider\nFor easy integration of using a callback based variant we introduced the `CallbackEntryProvider`. You can simply create an instance by calling `EntryProvider.fromCallbacks()`.\n\n### Custom implemenation\nIf none of the predefined variants fits your needs, you are of course free to implement your own version. In that case we recommend to extend the `AbstractEntryProvider` as a starting point.\n\n## Info on missing offset api for recurrence\nWith 4.0.x the date time api for entries has changed. You might have seen, that the recurring start / end time variants do not provide an offset variant. This is due to an [issue in the native FullCalendar library](https://github.com/fullcalendar/fullcalendar/issues/5273). As soon as the issue has been fixed, we try to add the respective api.\n\n## Deprecation\nSome methods have become deprecated, especially the CRUD operations in the `FullCalendar`. We recommend to replace them with the respective replacements, since they might be removed with the next major release.\n\n\n ",
      "category": "docs",
      "tags": [
        "release-notes-4.1",
        "entryprovider",
        "dataprovider",
        "inmemoryentryprovider",
        "listdataprovider",
        "eagerinmemoryentryprovider",
        "callbackentryprovider",
        "abstractentryprovider",
        "fullcalendar",
        "migration",
        "upgrade",
        "entry",
        "event"
      ]
    },
    {
      "id": "release-notes-detail-release-notes-6.0",
      "title": "Release-notes-6.0",
      "path": "release-notes-detail/Release-notes-6.0.md",
      "content": "Nothing to see here, check migration page for 6.0.",
      "category": "docs",
      "tags": [
        "release-notes-6.0",
        "migration",
        "upgrade"
      ]
    },
    {
      "id": "release-notes-detail-release-notes-6.1",
      "title": "Release-notes-6.1",
      "path": "release-notes-detail/Release-notes-6.1.md",
      "content": "With 6.1, the (for now experimental) Lumo theme has been added to the addon. This theme slightly changes\nthe appearance of the calendar to align more with other Vaadin components' Lumo styles.\n\nTo use it, simply apply the respective theme variant to your calendar instance. It also works with custom\nsubclasses of the calendar. Please be aware, that changing Lumo variables or overriding FC styles also affect\nthis theme.\n\n```java\ncalendar.addThemeVariant(FullCalendarVariant.LUMO);\n```\n\nMajor changes:\n* the today marker is now shown as a badge instead of having a background color\n* header font sizes reduced\n* selection colors aligned with Grid selection\n* using the lumo prime color as the default color for events (that have no own color); the default color of background events is not changed at the moment\n* applying several other lumo colors, sizes and spaces to different parts of the calendar",
      "category": "docs",
      "tags": [
        "release-notes-6.1"
      ]
    },
    {
      "id": "release-notes-detail-release-notes-6.2",
      "title": "Release-notes-6.2",
      "path": "release-notes-detail/Release-notes-6.2.md",
      "content": "With 6.2 custom native event handlers for entries have been added. These allow you to setup JavaScript events for\neach entry, e.g. a mouse over event handler. Inside these event handlers you may also access the created entry dom\nelement.\n\nCustom native event handlers are added to the FullCalender object. They will then be applied to each created\nentry object (using the entryDidMount callback).\n\nTo add an event handler, simply call the method `addEntryNativeEventListener` on the calendar. The first parameter\nis the JavaScript event name (e.g. \"mouseover\"), the second parameter is the callback, that shall be used for\nthat event. Please be aware, that we do NOT check or sanitize the given JavaScript. It is up to you to prevent\nmalicious code from being sent to your users.\n\nInside the event callback, you may access the entryDidMount argument object, that contains additional information\nabout the current entry. See the official docs (https://fullcalendar.io/docs/event-render-hooks) \nfor more details about which details it provide.\n\n```java\nFullCalendar calendar = new FullCalendar();\n\n// ... other configurations\n\n// write the js event, the current entry info and the current entry's element to the browser console.\ncalendar.addEntryNativeEventListener(\"mouseover\", \"e => console.warn(e, info.event, info.el)\");\n\nadd(calendar);\n```\n\nPlease be aware, that due to the design of the used library, these event handlers have to be setup before the\ncalendar is initialized on the client side.\n\nYou can combine the event handlers with a custom entryDidMount callback, if you want additional customizations\nof the entries. The FC will take care of combining the event handlers and you EDM callback",
      "category": "docs",
      "tags": [
        "release-notes-6.2",
        "entry",
        "event"
      ]
    },
    {
      "id": "release-notes-detail-release-notes-7.0",
      "title": "Release-notes-7.0",
      "path": "release-notes-detail/Release-notes-7.0.md",
      "content": "This page gives you an overview of the major changes, that came with the release of \n[FullCalendar for Flow, version 7.0](https://vaadin.com/directory/component/full-calendar-flow).\n\nThe main change in version 7.0 is the Vaadin 25 support, which includes the new requirement\nfor at least Java 21 and, if used, Spring Boot 4. \n\nAlso the used FullCalendar version has been increased to 6.1.20.\n\n## Major code changes\nSince element Json is gone and Jackson 3 is the new player on the field, json related things have been\nreworked to use Jackson types instead of elemental Json ones. Some method names have changed to align better with \nthe handled types.\n\n## Theming\nThe FullCalendar theme variant `LUMO` has been renamed to `VAADIN` to cover all themes at once. This should\naffect you only, when you have explicitly removed the theme variant.\n\nThe Vaadin theming now covers Lumo and Aura and applies the respective styles to the calendar. As before,\nthere might be variables or cases, where the styling is not applied correctly or missing - in this case\nplease open a github issue.\n\n## Other\nThe class `BusinessHours` has been reworked. The constructors have been removed and instead\nthere are now static methods to define new instance. The api also has been changed to allow a fluent definition\nstyle of business hours.\n\nDeprecated APIs have been marked as `forRemoval` and will be removed with one of the next minor releases.",
      "category": "docs",
      "tags": [
        "release-notes-7.0",
        "lumo",
        "vaadin",
        "businesshours"
      ]
    }
  ],
  "classes": [
    {
      "name": "BeanProperties",
      "packageName": "org.vaadin.stefan.fullcalendar",
      "fullName": "org.vaadin.stefan.fullcalendar.BeanProperties",
      "description": "@author Stefan Uebe",
      "type": "class",
      "methods": [
        {
          "name": "read",
          "description": "Reads the field of the given type (and its superclasses). Any field, that has a valid bean-styled\ngetter (\"get\" or \"is\", alternative a method named like the field) will be included in the set.<br>\nSetters are optional. If no setter is available, invoking the setter will lead to an\nUnsupportedOperationException.",
          "returnType": "<T> Set<BeanProperties<T>>",
          "parameters": [
            {
              "type": "Class<T>",
              "name": "type"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": true
        },
        {
          "name": "getSetter",
          "description": "",
          "returnType": "Optional<Setter<T, Object>>",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "getName",
          "description": "",
          "returnType": "String",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "isJsonIgnored",
          "description": "Returns whether this field should be ignored for JSON serialization.",
          "returnType": "boolean",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "isJsonUpdateAllowed",
          "description": "Returns whether this field can be updated from JSON.",
          "returnType": "boolean",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "getJsonName",
          "description": "Returns the JSON property name for this field.",
          "returnType": "String",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "getConverter",
          "description": "Returns the cached converter instance for this field, if any.",
          "returnType": "<V, E> JsonItemPropertyConverter<V, E>",
          "parameters": [],
          "annotations": [
            "SuppressWarnings"
          ],
          "isPublic": true,
          "isStatic": false
        }
      ],
      "fields": [],
      "constructors": [],
      "annotations": [
        "Getter"
      ],
      "isPublic": true,
      "source": "addon"
    },
    {
      "name": "BrowserTimezoneObtainedEvent",
      "packageName": "org.vaadin.stefan.fullcalendar",
      "fullName": "org.vaadin.stefan.fullcalendar.BrowserTimezoneObtainedEvent",
      "description": "This event gets fired when the client side reported the browser's timezone to the server. Since this is\ndone after the element has been attached to the client, it will be fired after all UI attach events.",
      "type": "class",
      "extends": "ComponentEvent<FullCalendar>",
      "methods": [],
      "fields": [],
      "constructors": [
        {
          "description": "Creates a new event using the given source and indicator whether the\nevent originated from the client side or the server side.",
          "parameters": [
            {
              "type": "FullCalendar",
              "name": "source"
            },
            {
              "type": "boolean",
              "name": "fromClient"
            },
            {
              "type": "Timezone",
              "name": "timezone"
            }
          ],
          "annotations": [],
          "isPublic": true
        }
      ],
      "annotations": [
        "ToString",
        "Getter"
      ],
      "isPublic": true,
      "source": "addon"
    },
    {
      "name": "BusinessHours",
      "packageName": "org.vaadin.stefan.fullcalendar",
      "fullName": "org.vaadin.stefan.fullcalendar.BusinessHours",
      "description": "Definition of business hours for a calendar instance.\n<p>\n    Use one of the static methods to define the days of week. You can define the range per day using the #start\n    and #end methods or leave them, to let the business hours range from the start of the day to its end.\n</p>",
      "type": "class",
      "methods": [
        {
          "name": "getEnd",
          "description": "Returns the end time. If none has been set, the returned time will be LocalTime#MAX.",
          "returnType": "LocalTime",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "getStart",
          "description": "Returns the start time. If none has been set, the returned time will be LocalTime#MIN.",
          "returnType": "LocalTime",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "getDayOfWeeks",
          "description": "Returns the days of week for business. Empty if there are no business days.",
          "returnType": "Set<DayOfWeek>",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "convertToClientSideDow",
          "description": "Converts the given day of the week to the correct client side number (handles sundays differently).",
          "returnType": "int",
          "parameters": [
            {
              "type": "DayOfWeek",
              "name": "dayOfWeek"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": true
        }
      ],
      "fields": [
        {
          "name": "ALL_DAYS",
          "type": "Set<DayOfWeek>",
          "description": "",
          "annotations": [],
          "isPublic": true,
          "isStatic": true,
          "isFinal": true
        },
        {
          "name": "DEFAULT_BUSINESS_WEEK",
          "type": "Set<DayOfWeek>",
          "description": "",
          "annotations": [],
          "isPublic": true,
          "isStatic": true,
          "isFinal": true
        }
      ],
      "constructors": [],
      "annotations": [
        "ToString",
        "EqualsAndHashCode"
      ],
      "isPublic": true,
      "source": "addon"
    },
    {
      "name": "CalendarLocale",
      "packageName": "org.vaadin.stefan.fullcalendar",
      "fullName": "org.vaadin.stefan.fullcalendar.CalendarLocale",
      "description": "A list of all supported locales.",
      "type": "enum",
      "methods": [
        {
          "name": "valueOf",
          "description": "Returns a matching instead for the given locale or empty, if no match has been found.",
          "returnType": "Optional<CalendarLocale>",
          "parameters": [
            {
              "type": "Locale",
              "name": "locale"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": true
        },
        {
          "name": "getAvailableLocales",
          "description": "Get all available locales as an array of Locale.",
          "returnType": "Locale[]",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": true
        },
        {
          "name": "getDefaultLocale",
          "description": "Returns the default locale. This is by default the system language. If the system language is not supported\nby the calender, english will be used instead.\n<p>\nThis value is used as a fallback in different places, if no locale could be\ndetermined from the browser (or that should not be used).",
          "returnType": "Locale",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": true
        },
        {
          "name": "setDefault",
          "description": "Sets the default locale. This is by default the system language. If the system language is not supported\nby the calender, english will be used instead.\n<p>\nThis value is used as a fallback in different places, if no locale could be\ndetermined from the browser (or that should not be used).",
          "returnType": "void",
          "parameters": [
            {
              "type": "CalendarLocale",
              "name": "locale"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": true
        }
      ],
      "fields": [],
      "constructors": [],
      "annotations": [],
      "isPublic": true,
      "source": "addon"
    },
    {
      "name": "CalendarView",
      "packageName": "org.vaadin.stefan.fullcalendar",
      "fullName": "org.vaadin.stefan.fullcalendar.CalendarView",
      "description": "Defines a possible view for the calendar.",
      "type": "interface",
      "extends": "ClientSideValue",
      "methods": [],
      "fields": [],
      "constructors": [],
      "annotations": [],
      "isPublic": true,
      "source": "addon"
    },
    {
      "name": "CalendarViewImpl",
      "packageName": "org.vaadin.stefan.fullcalendar",
      "fullName": "org.vaadin.stefan.fullcalendar.CalendarViewImpl",
      "description": "Basic enumeration of possible calendar views.",
      "type": "enum",
      "implements": [
        "CalendarView"
      ],
      "methods": [],
      "fields": [],
      "constructors": [],
      "annotations": [
        "RequiredArgsConstructor",
        "Getter"
      ],
      "isPublic": true,
      "source": "addon"
    },
    {
      "name": "ClientSideValue",
      "packageName": "org.vaadin.stefan.fullcalendar",
      "fullName": "org.vaadin.stefan.fullcalendar.ClientSideValue",
      "description": "Marks a class as a client side setting, which returns client side representation for an instance of this class.\nAn enumeration for instance would return a client side parseable version of the server side enum instance,\ne.g. RenderingMode.INVERSE_BACKGROUND.getClientSideName() // returns \"inverse-background\"",
      "type": "interface",
      "methods": [],
      "fields": [],
      "constructors": [],
      "annotations": [],
      "isPublic": true,
      "source": "addon"
    },
    {
      "name": "CustomCalendarView",
      "packageName": "org.vaadin.stefan.fullcalendar",
      "fullName": "org.vaadin.stefan.fullcalendar.CustomCalendarView",
      "description": "Interface for custom calendar views. This is used to create custom views for the calendar.\n@author Stefan Uebe",
      "type": "interface",
      "extends": "CalendarView",
      "methods": [
        {
          "name": "getClientSideValue",
          "description": "",
          "returnType": "String",
          "parameters": [],
          "annotations": [
            "Override"
          ],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "getViewSettings",
          "description": "",
          "returnType": "ObjectNode",
          "parameters": [],
          "annotations": [
            "Override"
          ],
          "isPublic": true,
          "isStatic": false
        }
      ],
      "fields": [],
      "constructors": [],
      "annotations": [],
      "isPublic": true,
      "source": "addon"
    },
    {
      "name": "DateEvent",
      "packageName": "org.vaadin.stefan.fullcalendar",
      "fullName": "org.vaadin.stefan.fullcalendar.DateEvent",
      "description": "An abstract class for date events, that are not directly entry related. They are always whole day events.",
      "type": "class",
      "extends": "ComponentEvent<FullCalendar>",
      "methods": [],
      "fields": [],
      "constructors": [
        {
          "description": "New instance. Awaits the date as iso string (e.g. \"2018-10-23\").",
          "parameters": [
            {
              "type": "FullCalendar",
              "name": "source"
            },
            {
              "type": "boolean",
              "name": "fromClient"
            },
            {
              "type": "String",
              "name": "dateString"
            }
          ],
          "annotations": [],
          "isPublic": true
        }
      ],
      "annotations": [
        "ToString",
        "Getter"
      ],
      "isPublic": true,
      "source": "addon"
    },
    {
      "name": "DateTimeEvent",
      "packageName": "org.vaadin.stefan.fullcalendar",
      "fullName": "org.vaadin.stefan.fullcalendar.DateTimeEvent",
      "description": "An abstract class for date events, that are not directly entry related.",
      "type": "class",
      "extends": "ComponentEvent<FullCalendar>",
      "methods": [
        {
          "name": "getDateTimeAsInstant",
          "description": "The utc based date time related to this event. For day slots the time will be at start of the day.",
          "returnType": "Instant",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "getDateTimeWithOffset",
          "description": "The date time related to this event including the calendar timezone's offset.\nFor day slots the time will be at start of the day and ignore the timezone.",
          "returnType": "LocalDateTime",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "getDate",
          "description": "Returns only the date part of the contained local date time. This method is intended to be used on\nall day entry related events.",
          "returnType": "LocalDate",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        }
      ],
      "fields": [],
      "constructors": [
        {
          "description": "New instance. Awaits the date (time) as iso string (e.g. \"2018-10-23\" or \"2018-10-23T13:30\").",
          "parameters": [
            {
              "type": "FullCalendar",
              "name": "source"
            },
            {
              "type": "boolean",
              "name": "fromClient"
            },
            {
              "type": "String",
              "name": "dateString"
            },
            {
              "type": "boolean",
              "name": "allDay"
            }
          ],
          "annotations": [],
          "isPublic": true
        }
      ],
      "annotations": [
        "ToString",
        "Getter"
      ],
      "isPublic": true,
      "source": "addon"
    },
    {
      "name": "DatesRenderedEvent",
      "packageName": "org.vaadin.stefan.fullcalendar",
      "fullName": "org.vaadin.stefan.fullcalendar.DatesRenderedEvent",
      "description": "Occurs when a new set of dates has been rendered.. Provides information about the shown timespan.\n<br><br>\nThe values are always daybased, regardless of the current view.\n<br><br>\nCalled after registered ViewSkeletonRenderedEvent listeners.",
      "type": "class",
      "extends": "ViewRenderEvent",
      "methods": [],
      "fields": [],
      "constructors": [
        {
          "description": "Creates a new event using the given source and indicator whether the\nevent originated from the client side or the server side.",
          "parameters": [
            {
              "type": "FullCalendar",
              "name": "source"
            },
            {
              "type": "boolean",
              "name": "fromClient"
            }
          ],
          "annotations": [],
          "isPublic": true
        }
      ],
      "annotations": [
        "ToString",
        "Getter",
        "DomEvent"
      ],
      "isPublic": true,
      "source": "addon"
    },
    {
      "name": "DayNumberClickedEvent",
      "packageName": "org.vaadin.stefan.fullcalendar",
      "fullName": "org.vaadin.stefan.fullcalendar.DayNumberClickedEvent",
      "description": "Occurs when number links are active and a user clicked on a day's number.",
      "type": "class",
      "extends": "DateEvent",
      "methods": [],
      "fields": [],
      "constructors": [
        {
          "description": "New instance. Awaits the date (time) as iso string (e.g. \"2018-10-23\" or \"2018-10-23T13:30\").",
          "parameters": [
            {
              "type": "FullCalendar",
              "name": "source"
            },
            {
              "type": "boolean",
              "name": "fromClient"
            }
          ],
          "annotations": [],
          "isPublic": true
        }
      ],
      "annotations": [
        "ToString",
        "DomEvent"
      ],
      "isPublic": true,
      "source": "addon"
    },
    {
      "name": "Delta",
      "packageName": "org.vaadin.stefan.fullcalendar",
      "fullName": "org.vaadin.stefan.fullcalendar.Delta",
      "description": "Represents a delta between two times. A delta can contain negative values if the first date is later then the second one.",
      "type": "class",
      "methods": [
        {
          "name": "applyOn",
          "description": "Applies this delta instance on the given local date time by adding all day and time related delta values.",
          "returnType": "LocalDateTime",
          "parameters": [
            {
              "type": "LocalDateTime",
              "name": "dateTime"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "applyOn",
          "description": "Applies this delta instance on the given local date by adding all day related delta values. Time values are ignored.",
          "returnType": "LocalDate",
          "parameters": [
            {
              "type": "LocalDate",
              "name": "date"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "applyOn",
          "description": "Applies this delta instance on the given instant by adding all day and time related delta values.",
          "returnType": "Instant",
          "parameters": [
            {
              "type": "Instant",
              "name": "instant"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        }
      ],
      "fields": [],
      "constructors": [
        {
          "description": "Creates a new instance.",
          "parameters": [
            {
              "type": "int",
              "name": "years"
            },
            {
              "type": "int",
              "name": "months"
            },
            {
              "type": "int",
              "name": "days"
            },
            {
              "type": "int",
              "name": "hours"
            },
            {
              "type": "int",
              "name": "minutes"
            },
            {
              "type": "int",
              "name": "seconds"
            }
          ],
          "annotations": [],
          "isPublic": true
        }
      ],
      "annotations": [
        "EqualsAndHashCode",
        "ToString",
        "Getter"
      ],
      "isPublic": true,
      "source": "addon"
    },
    {
      "name": "DisplayMode",
      "packageName": "org.vaadin.stefan.fullcalendar",
      "fullName": "org.vaadin.stefan.fullcalendar.DisplayMode",
      "description": "Constants for rendering of an entry.",
      "type": "enum",
      "implements": [
        "ClientSideValue"
      ],
      "methods": [
        {
          "name": "getClientSideValue",
          "description": "",
          "returnType": "String",
          "parameters": [],
          "annotations": [
            "Override"
          ],
          "isPublic": true,
          "isStatic": false
        }
      ],
      "fields": [],
      "constructors": [],
      "annotations": [],
      "isPublic": true,
      "source": "addon"
    },
    {
      "name": "Entry",
      "packageName": "org.vaadin.stefan.fullcalendar",
      "fullName": "org.vaadin.stefan.fullcalendar.Entry",
      "description": "",
      "type": "class",
      "methods": [
        {
          "name": "getCalendar",
          "description": "Returns the calendar instance of this entry. Is empty when not yet added to a calendar.",
          "returnType": "Optional<FullCalendar>",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "setCalendar",
          "description": "",
          "returnType": "void",
          "parameters": [
            {
              "type": "FullCalendar",
              "name": "calendar"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "toJson",
          "description": "Converts the given instance to a json object representing its inner state. This json is intended to be\ntransported to and interpreted by the client and thus should not be modified manually, except for concrete\nreasons.",
          "returnType": "ObjectNode",
          "parameters": [],
          "annotations": [
            "SuppressWarnings"
          ],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "updateFromJson",
          "description": "Updates this instance with the given json object. Only fields, that are updateable will be overwritten.\nThrows an exception, when the given json object has not the same id as this instance.",
          "returnType": "void",
          "parameters": [
            {
              "type": "ObjectNode",
              "name": "jsonObject"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "updateFromJson",
          "description": "Updates this instance with the given json object. Only fields, that are updateable will be overwritten.\nBased on the boolean parameter, the id will be either ignored (false) or has to be the same as this instance's one\n(true), otherwise an exception will be thrown",
          "returnType": "void",
          "parameters": [
            {
              "type": "ObjectNode",
              "name": "jsonObject"
            },
            {
              "type": "boolean",
              "name": "requiresMatchingId"
            }
          ],
          "annotations": [
            "SuppressWarnings"
          ],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "copy",
          "description": "Creates a copy of this instance. Collection, Map and Array values are copied (but their values are taken\nas they are, so no deep copy).",
          "returnType": "<T extends Entry> T",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "copyAsType",
          "description": "Creates a copy of this instance. Collection, Map and Array values are copied (but their values are taken\nas they are, so no deep copy).\n<p></p>\nPlease make sure, that both types are compatible in their properties. Any property, that exists in the source\nbut not the target type might lead to an exception. Also the target type must have a public constructor, taking\nthe id as the parameter.",
          "returnType": "<T extends Entry> T",
          "parameters": [
            {
              "type": "Class<T>",
              "name": "targetType"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "copyFrom",
          "description": "",
          "returnType": "void",
          "parameters": [
            {
              "type": "Entry",
              "name": "source"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "copyFrom",
          "description": "",
          "returnType": "void",
          "parameters": [
            {
              "type": "Entry",
              "name": "source"
            },
            {
              "type": "boolean",
              "name": "ignoreId"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "copy",
          "description": "Copies all values from source to target (except for the id). When the boolean is set to false,\nboth objects have to be of the <b>same</b> type. Otherwise it is up to the developer to guarantee,\nthat the target can take all properties of the source.<br>\nProperties without a setter are ignored.",
          "returnType": "void",
          "parameters": [
            {
              "type": "Entry",
              "name": "source"
            },
            {
              "type": "Entry",
              "name": "target"
            },
            {
              "type": "boolean",
              "name": "ignoreTypeDifference"
            }
          ],
          "annotations": [
            "SuppressWarnings"
          ],
          "isPublic": true,
          "isStatic": true
        },
        {
          "name": "toJsonWithIdOnly",
          "description": "Converts this instance to a json object, that only contains the id. This still represents\nthis item but without any data.",
          "returnType": "ObjectNode",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "getStartAsInstant",
          "description": "Returns the entry's start as an Instant. The contained time is the same as when calling\n#getStart().",
          "returnType": "Instant",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "getStartAsLocalDate",
          "description": "Returns the entry's start date.",
          "returnType": "LocalDate",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "getStartWithTimezone",
          "description": "Returns the start time as a zoned date time using this entry's start time zone. By default this is\nthe calendar's timezone or, if no calendar is set yet, UTC.\n<p></p>\nCalling ZonedDateTime#toLocalDateTime() returns the time including the offset as LocalDateTime.",
          "returnType": "ZonedDateTime",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "getStartWithOffset",
          "description": "Returns the start time as a local date time after applying the timezone's offset to\nthe utc based start date (#getStart()). By default the timezone is\nthe calendar's timezone or, if no calendar is set yet, UTC.\n<p></p>\nTo get a OffsetDateTime please use #getStartWithTimezone() and call\nZonedDateTime#toOffsetDateTime()",
          "returnType": "LocalDateTime",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "getStartWithOffset",
          "description": "Returns the start time as a local date time after applying the timezone's offset to\nthe utc based start date (#getStart()).\n<p></p>\nThis method is intended to be used for new entrys that have not yet been added to the\ncalender and thus have no reference to its timezone.\n<p></p>\nTo get a OffsetDateTime please use #getStartWithTimezone() and call\nZonedDateTime#toOffsetDateTime()",
          "returnType": "LocalDateTime",
          "parameters": [
            {
              "type": "Timezone",
              "name": "timezone"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "setStart",
          "description": "Sets the entry's start. The given date time will be interpreted as the UTC start time of this entry.",
          "returnType": "void",
          "parameters": [
            {
              "type": "LocalDateTime",
              "name": "start"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "setStart",
          "description": "Sets the entry's start. The given instant will be interpreted as the UTC start time of this entry.",
          "returnType": "void",
          "parameters": [
            {
              "type": "Instant",
              "name": "start"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "setStart",
          "description": "Sets the given local date as start using the start of the day as time (utc based).",
          "returnType": "void",
          "parameters": [
            {
              "type": "LocalDate",
              "name": "start"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "setStartWithTimezone",
          "description": "Sets the entry's start based on the zoned date time instance. The given date time will be converted to UTC.\n<p></p>\nFor instance, when passing an instance with ...T01:00 and the timezone is Europe/Berlin in winter,\nthe resulting start time will be ...T00:00.\n<p></p>",
          "returnType": "void",
          "parameters": [
            {
              "type": "ZonedDateTime",
              "name": "startWithTimezone"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "setStartWithOffset",
          "description": "Sets the entry's start. The given date time will be interpreted as having the offset of the\nstart time zone applied. The time will be converted to UTC.\n<p></p>\nFor instance, when passing an instance with ...T01:00 and the timezone is Europe/Berlin in winter,\nthe resulting start time will be ...T00:00.\n<p></p>\nThis method is intended to be used in cases where the start time is edited in relation to\nthe current time zone (like a calendar entry editor).\n<p></p>",
          "returnType": "void",
          "parameters": [
            {
              "type": "LocalDateTime",
              "name": "startWithTimezone"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "setStartWithOffset",
          "description": "Sets the entry's start. The given date time will be interpreted as having the offset of the\ngiven time zone applied. The time will be converted to UTC.\n<p></p>\nFor instance, when passing an instance with ...T01:00 and the timezone is Europe/Berlin in winter,\nthe resulting start time will be ...T00:00.\n<p></p>\nThis method is intended to be used in cases where entry is not yet added to the calender and thus\ncannot use its timezone to interpret the offset.\n<p></p>",
          "returnType": "void",
          "parameters": [
            {
              "type": "LocalDateTime",
              "name": "startWithTimezone"
            },
            {
              "type": "Timezone",
              "name": "timezone"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "clearStart",
          "description": "Clears the current start time. Convenience method to prevent unnecessary casting when using\nsetStart(null).",
          "returnType": "void",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "getEndAsInstant",
          "description": "Returns the entry's end as an Instant. The contained time is the same as when calling\n#getEnd().",
          "returnType": "Instant",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "getEndAsLocalDate",
          "description": "Returns the entry's end date.",
          "returnType": "LocalDate",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "getEndWithTimezone",
          "description": "Returns the end time as a zoned date time using this entry's end time zone. By default this is\nthe calendar's timezone or, if no calendar is set yet, UTC.\n<p></p>\nCalling ZonedDateTime#toLocalDateTime() returns the time including the offset as LocalDateTime.",
          "returnType": "ZonedDateTime",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "getEndWithOffset",
          "description": "Returns the end time as a local date time after applying the timezone's offset to\nthe utc based end date (#getEnd()). By default the timezone is\nthe calendar's timezone or, if no calendar is set yet, UTC.\n<p></p>\nTo get a OffsetDateTime please use #getEndWithTimezone() and call\nZonedDateTime#toOffsetDateTime()",
          "returnType": "LocalDateTime",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "getEndWithOffset",
          "description": "Returns the end time as a local date time after applying the timezone's offset to\nthe utc based end date (#getEnd()).\n<p></p>\nThis method is intended to be used for new entrys that have not yet been added to the\ncalender and thus have no reference to its timezone.\n<p></p>\nTo get a OffsetDateTime please use #getEndWithTimezone() and call\nZonedDateTime#toOffsetDateTime()",
          "returnType": "LocalDateTime",
          "parameters": [
            {
              "type": "Timezone",
              "name": "timezone"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "setEnd",
          "description": "Sets the entry's end. The given date time will be interpreted as the UTC end time of this entry.",
          "returnType": "void",
          "parameters": [
            {
              "type": "LocalDateTime",
              "name": "end"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "setEnd",
          "description": "Sets the entry's end. The given instant will be interpreted as the UTC end time of this entry.",
          "returnType": "void",
          "parameters": [
            {
              "type": "Instant",
              "name": "end"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "setEnd",
          "description": "Sets the given local date as end using the end of the day as time (utc based).",
          "returnType": "void",
          "parameters": [
            {
              "type": "LocalDate",
              "name": "end"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "setEndWithTimezone",
          "description": "Sets the entry's end based on the zoned date time instance. The given date time will be converted to UTC.\n<p></p>\nFor instance, when passing an instance with ...T01:00 and the timezone is Europe/Berlin in winter,\nthe resulting end time will be ...T00:00.\n<p></p>",
          "returnType": "void",
          "parameters": [
            {
              "type": "ZonedDateTime",
              "name": "endWithTimezone"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "setEndWithOffset",
          "description": "Sets the entry's end. The given date time will be interpreted as having the offset of the\nend time zone applied. The time will be converted to UTC.\n<p></p>\nFor instance, when passing an instance with ...T01:00 and the timezone is Europe/Berlin in winter,\nthe resulting end time will be ...T00:00.\n<p></p>\nThis method is intended to be used in cases where the end time is edited in relation to\nthe current time zone (like a calendar entry editor).\n<p></p>",
          "returnType": "void",
          "parameters": [
            {
              "type": "LocalDateTime",
              "name": "endWithTimezone"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "setEndWithOffset",
          "description": "Sets the entry's end. The given date time will be interpreted as having the offset of the\ngiven time zone applied. The time will be converted to UTC.\n<p></p>\nFor instance, when passing an instance with ...T01:00 and the timezone is Europe/Berlin in winter,\nthe resulting end time will be ...T00:00.\n<p></p>\nThis method is intended to be used in cases where entry is not yet added to the calender and thus\ncannot use its timezone to interpret the offset.\n<p></p>",
          "returnType": "void",
          "parameters": [
            {
              "type": "LocalDateTime",
              "name": "endWithTimezone"
            },
            {
              "type": "Timezone",
              "name": "timezone"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "clearEnd",
          "description": "Clears the current end time. Convenience method to prevent unnecessary casting when using\nsetEnd(null).",
          "returnType": "void",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "moveStartEnd",
          "description": "Moves the entry by the given delta. Negative deltas will result in moving the entry to the past.",
          "returnType": "void",
          "parameters": [
            {
              "type": "Delta",
              "name": "delta"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "moveStart",
          "description": "Moves the entry's start by the given delta without modifying the end.\nNegative deltas will result in moving the start to the past.",
          "returnType": "void",
          "parameters": [
            {
              "type": "Delta",
              "name": "delta"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "moveEnd",
          "description": "Moves the entry's end by the given delta without modifying the start.\nNegative deltas will result in moving the end to the past.",
          "returnType": "void",
          "parameters": [
            {
              "type": "Delta",
              "name": "delta"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "getStartTimezone",
          "description": "Returns the timezone which is used on the client side. It is used to convert the internal utc timestamp\nto the client side timezone. By default UTC.",
          "returnType": "Timezone",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "getEndTimezone",
          "description": "Returns the timezone which is used on the client side. It is used to convert the internal utc timestamp\nto the client side timezone. By default UTC.",
          "returnType": "Timezone",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "getOrCreateClassNames",
          "description": "Returns the set of class names or creates a new, empty one, if none exists yet. The returned set is\nthe same as used internally, therefore any changes to it will be reflected to the client side on the\nnext refresh.",
          "returnType": "Set<String>",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "assignClassName",
          "description": "Assign an additional className to this entry. Already assigned classNames will be kept.\n\n@deprecated use #addClassNames(String...)",
          "returnType": "void",
          "parameters": [
            {
              "type": "String",
              "name": "className"
            }
          ],
          "annotations": [
            "Deprecated"
          ],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "assignClassNames",
          "description": "Assign additional classNames to this entry. Already assigned classNames will be kept.\n\n@deprecated use #addClassNames(String...)",
          "returnType": "void",
          "parameters": [
            {
              "type": "String...",
              "name": "classNames"
            }
          ],
          "annotations": [
            "Deprecated"
          ],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "assignClassNames",
          "description": "Assign additional classNames to this entry. Already assigned classNames will be kept.\n\n@deprecated use #addClassNames(Collection)",
          "returnType": "void",
          "parameters": [
            {
              "type": "Collection<String>",
              "name": "classNames"
            }
          ],
          "annotations": [
            "Deprecated"
          ],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "addClassNames",
          "description": "Adds css class names to this entry. Duplicates will automatically be filtered out.",
          "returnType": "void",
          "parameters": [
            {
              "type": "String...",
              "name": "classNames"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "addClassNames",
          "description": "Adds css class names to this entry. Duplicates will automatically be filtered out.",
          "returnType": "void",
          "parameters": [
            {
              "type": "Collection<String>",
              "name": "classNames"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "unassignClassName",
          "description": "Unassigns the given className from this entry.\n\n@deprecated use #removeClassNames(String...)",
          "returnType": "void",
          "parameters": [
            {
              "type": "String",
              "name": "className"
            }
          ],
          "annotations": [
            "Deprecated"
          ],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "unassignClassNames",
          "description": "Unassigns the given classNames from this entry.\n\n@deprecated use #removeClassNames(String...)",
          "returnType": "void",
          "parameters": [
            {
              "type": "String...",
              "name": "classNames"
            }
          ],
          "annotations": [
            "Deprecated"
          ],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "unassignClassNames",
          "description": "Unassigns the given classNames from this entry.\n\n@deprecated use #removeClassNames(Collection)",
          "returnType": "void",
          "parameters": [
            {
              "type": "Collection<String>",
              "name": "classNamesToRemove"
            }
          ],
          "annotations": [
            "Deprecated"
          ],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "unassignAllClassNames",
          "description": "Unassigns all classNames from this entry.\n\n@deprecated use #removeClassNames()",
          "returnType": "void",
          "parameters": [],
          "annotations": [
            "Deprecated"
          ],
          "isPublic": true,
          "isStatic": false
        }
      ],
      "fields": [
        {
          "name": "DESCRIPTION",
          "type": "String",
          "description": "",
          "annotations": [],
          "isPublic": true,
          "isStatic": true,
          "isFinal": true
        }
      ],
      "constructors": [
        {
          "description": "Creates a new editable instance with a generated id.",
          "parameters": [],
          "annotations": [],
          "isPublic": true
        },
        {
          "description": "Creates a new entry with the given id. Null will lead to a generated id.\n<br><br>\nPlease be aware, that the ID needs to be unique in the calendar instance. Otherwise it can lead to\nunpredictable results.",
          "parameters": [
            {
              "type": "String",
              "name": "id"
            }
          ],
          "annotations": [],
          "isPublic": true
        }
      ],
      "annotations": [
        "FieldNameConstants",
        "EqualsAndHashCode",
        "lombok",
        "Getter"
      ],
      "isPublic": true,
      "source": "addon"
    },
    {
      "name": "EntryChangedEvent",
      "packageName": "org.vaadin.stefan.fullcalendar",
      "fullName": "org.vaadin.stefan.fullcalendar.EntryChangedEvent",
      "description": "An event, that occur, when a entry has been changed on the client side.\n<br><br>\nYou can apply the changes to the referred entry by calling the method #applyChangesOnEntry().",
      "type": "class",
      "extends": "EntryDataEvent",
      "methods": [],
      "fields": [],
      "constructors": [
        {
          "description": "New instance. Awaits the changed data object.",
          "parameters": [
            {
              "type": "FullCalendar",
              "name": "source"
            },
            {
              "type": "boolean",
              "name": "fromClient"
            },
            {
              "type": "ObjectNode",
              "name": "jsonObject"
            }
          ],
          "annotations": [],
          "isPublic": true
        }
      ],
      "annotations": [
        "ToString"
      ],
      "isPublic": true,
      "source": "addon"
    },
    {
      "name": "EntryClickedEvent",
      "packageName": "org.vaadin.stefan.fullcalendar",
      "fullName": "org.vaadin.stefan.fullcalendar.EntryClickedEvent",
      "description": "Occurs when an entry has been clicked on the client side.\n<br><br>\nClient side event: eventClick",
      "type": "class",
      "extends": "EntryDataEvent",
      "methods": [],
      "fields": [],
      "constructors": [
        {
          "description": "New instance. Awaits the id of the clicked entry.",
          "parameters": [
            {
              "type": "FullCalendar",
              "name": "source"
            },
            {
              "type": "boolean",
              "name": "fromClient"
            }
          ],
          "annotations": [],
          "isPublic": true
        }
      ],
      "annotations": [
        "ToString",
        "DomEvent"
      ],
      "isPublic": true,
      "source": "addon"
    },
    {
      "name": "EntryDataEvent",
      "packageName": "org.vaadin.stefan.fullcalendar",
      "fullName": "org.vaadin.stefan.fullcalendar.EntryDataEvent",
      "description": "Extended entry event type, that provides also additional client side entry data, that can be interpreted on the\nserver side.",
      "type": "class",
      "extends": "EntryEvent",
      "methods": [
        {
          "name": "applyChangesOnEntry",
          "description": "Applies the contained changes on the referring entry and returns this instance.",
          "returnType": "Entry",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "createCopyBasedOnChanges",
          "description": "Creates a copy based on the referenced entry and the received data.",
          "returnType": "<R extends Entry> R",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        }
      ],
      "fields": [],
      "constructors": [
        {
          "description": "New instance. Awaits the changed data object.",
          "parameters": [
            {
              "type": "FullCalendar",
              "name": "source"
            },
            {
              "type": "boolean",
              "name": "fromClient"
            },
            {
              "type": "ObjectNode",
              "name": "jsonObject"
            }
          ],
          "annotations": [],
          "isPublic": true
        }
      ],
      "annotations": [
        "ToString",
        "Getter"
      ],
      "isPublic": true,
      "source": "addon"
    },
    {
      "name": "EntryDroppedEvent",
      "packageName": "org.vaadin.stefan.fullcalendar",
      "fullName": "org.vaadin.stefan.fullcalendar.EntryDroppedEvent",
      "description": "Occurs when an entry time has changed by drag and drop.\n<br><br>\nYou can apply the changes to the referred entry by calling the method #applyChangesOnEntry().\n<br><br>\nClient side name: eventDrop",
      "type": "class",
      "extends": "EntryTimeChangedEvent",
      "methods": [],
      "fields": [],
      "constructors": [
        {
          "description": "New instance. Awaits the changed data object for the entry plus the json object for the delta information.",
          "parameters": [
            {
              "type": "FullCalendar",
              "name": "source"
            },
            {
              "type": "boolean",
              "name": "fromClient"
            }
          ],
          "annotations": [],
          "isPublic": true
        }
      ],
      "annotations": [
        "ToString",
        "DomEvent"
      ],
      "isPublic": true,
      "source": "addon"
    },
    {
      "name": "EntryEvent",
      "packageName": "org.vaadin.stefan.fullcalendar",
      "fullName": "org.vaadin.stefan.fullcalendar.EntryEvent",
      "description": "Simple event that occurred for a specific calendar item.",
      "type": "class",
      "extends": "ComponentEvent<FullCalendar>",
      "methods": [],
      "fields": [],
      "constructors": [
        {
          "description": "New instance. Awaits the entry id.",
          "parameters": [
            {
              "type": "FullCalendar",
              "name": "source"
            },
            {
              "type": "boolean",
              "name": "fromClient"
            },
            {
              "type": "String",
              "name": "entryId"
            }
          ],
          "annotations": [],
          "isPublic": true
        }
      ],
      "annotations": [
        "ToString",
        "Getter"
      ],
      "isPublic": true,
      "source": "addon"
    },
    {
      "name": "EntryMouseEnterEvent",
      "packageName": "org.vaadin.stefan.fullcalendar",
      "fullName": "org.vaadin.stefan.fullcalendar.EntryMouseEnterEvent",
      "description": "Occurs when the user mouses over an entry\n<br><br>\nClient side event: eventMouseEnter",
      "type": "class",
      "extends": "EntryDataEvent",
      "methods": [],
      "fields": [],
      "constructors": [
        {
          "description": "New instance.",
          "parameters": [
            {
              "type": "FullCalendar",
              "name": "source"
            },
            {
              "type": "boolean",
              "name": "fromClient"
            }
          ],
          "annotations": [],
          "isPublic": true
        }
      ],
      "annotations": [
        "ToString",
        "DomEvent"
      ],
      "isPublic": true,
      "source": "addon"
    },
    {
      "name": "EntryMouseLeaveEvent",
      "packageName": "org.vaadin.stefan.fullcalendar",
      "fullName": "org.vaadin.stefan.fullcalendar.EntryMouseLeaveEvent",
      "description": "Occurs when the user mouses out of an entry\n<br><br>\nClient side event: eventMouseLeave",
      "type": "class",
      "extends": "EntryDataEvent",
      "methods": [],
      "fields": [],
      "constructors": [
        {
          "description": "New instance.",
          "parameters": [
            {
              "type": "FullCalendar",
              "name": "source"
            },
            {
              "type": "boolean",
              "name": "fromClient"
            }
          ],
          "annotations": [],
          "isPublic": true
        }
      ],
      "annotations": [
        "ToString",
        "DomEvent"
      ],
      "isPublic": true,
      "source": "addon"
    },
    {
      "name": "EntryResizedEvent",
      "packageName": "org.vaadin.stefan.fullcalendar",
      "fullName": "org.vaadin.stefan.fullcalendar.EntryResizedEvent",
      "description": "Occurs when an entry time has changed by resizing.\n<br><br>\nYou can apply the changes to the referred entry by calling the method #applyChangesOnEntry().\n<br><br>\nClient side name: eventResize",
      "type": "class",
      "extends": "EntryTimeChangedEvent",
      "methods": [],
      "fields": [],
      "constructors": [
        {
          "description": "New instance. Awaits the changed data object for the entry plus the json object for the delta information.",
          "parameters": [
            {
              "type": "FullCalendar",
              "name": "source"
            },
            {
              "type": "boolean",
              "name": "fromClient"
            }
          ],
          "annotations": [],
          "isPublic": true
        }
      ],
      "annotations": [
        "ToString",
        "DomEvent"
      ],
      "isPublic": true,
      "source": "addon"
    },
    {
      "name": "EntryTimeChangedEvent",
      "packageName": "org.vaadin.stefan.fullcalendar",
      "fullName": "org.vaadin.stefan.fullcalendar.EntryTimeChangedEvent",
      "description": "This specialized version of the entry changed event gives additional information about the changed time as\na delta instance.\n<br><br>\nYou can apply the changes to the referred entry by calling the method #applyChangesOnEntry().",
      "type": "class",
      "extends": "EntryChangedEvent",
      "methods": [],
      "fields": [],
      "constructors": [
        {
          "description": "New instance. Awaits the changed data object for the entry plus the json object for the delta information.",
          "parameters": [
            {
              "type": "FullCalendar",
              "name": "source"
            },
            {
              "type": "boolean",
              "name": "fromClient"
            },
            {
              "type": "ObjectNode",
              "name": "jsonEntry"
            },
            {
              "type": "ObjectNode",
              "name": "jsonDelta"
            }
          ],
          "annotations": [],
          "isPublic": true
        }
      ],
      "annotations": [
        "ToString",
        "Getter"
      ],
      "isPublic": true,
      "source": "addon"
    },
    {
      "name": "FullCalendar",
      "packageName": "org.vaadin.stefan.fullcalendar",
      "fullName": "org.vaadin.stefan.fullcalendar.FullCalendar",
      "description": "",
      "type": "class",
      "extends": "Component",
      "implements": [
        "HasStyle",
        "HasSize",
        "HasTheme"
      ],
      "methods": [
        {
          "name": "allowDatesRenderEventOnOptionChange",
          "description": "Sets a property to allow or disallow (re-)rendering of dates, when an option changes. When allowed,\neach option will fire a dates rendering event, which can lead to multiple rendering events, even if only\none is needed.",
          "returnType": "void",
          "parameters": [
            {
              "type": "boolean",
              "name": "allow"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "next",
          "description": "Moves to the next interval (e. g. next month if current view is monthly based).",
          "returnType": "void",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "previous",
          "description": "Moves to the previous interval (e. g. previous month if current view is monthly based).",
          "returnType": "void",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "today",
          "description": "Moves to the current interval (e. g. current month if current view is monthly based).",
          "returnType": "void",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "setEntryProvider",
          "description": "Sets the entry provider for this instance. The previous entry provider will be removed and the\nclient side will be updated.\n<p></p>\nBy default a new full calendar is initialized with an InMemoryEntryProvider.",
          "returnType": "void",
          "parameters": [
            {
              "type": "EntryProvider<? extends Entry>",
              "name": "entryProvider"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "getEntryProvider",
          "description": "Returns the entry provider of this calendar. Never null.",
          "returnType": "<R extends Entry, T extends EntryProvider<R>> T",
          "parameters": [],
          "annotations": [
            "SuppressWarnings"
          ],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "isInMemoryEntryProvider",
          "description": "Indicates, if the entry provider is a in memory provider.",
          "returnType": "boolean",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "getCachedEntryFromFetch",
          "description": "Returns an entry with the given id from the last fetched set of entries. Returns an empty instance,\nwhen there was no fetch yet or the id is unknown.\n<p></p>\nUses InMemoryEntryProvider#getEntryById(String) when the eager in memory provider is used.\n<p></p>\nThis method is an internal method, intended to be used by entry based events only. Do not use it for\nany other purpose as the implementation or scope may change in future.",
          "returnType": "Optional<Entry>",
          "parameters": [
            {
              "type": "String",
              "name": "id"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "changeView",
          "description": "Change the view of the calendar (e. g. from monthly to weekly)",
          "returnType": "void",
          "parameters": [
            {
              "type": "CalendarView",
              "name": "view"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "getCurrentViewName",
          "description": "The name of the current view.",
          "returnType": "String",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "getCurrentView",
          "description": "The current view of this isntance. Empty, if the current view could not be matched with one of the predefined\nviews (e.g. in case of a custom view).",
          "returnType": "Optional<CalendarView>",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "gotoDate",
          "description": "Switch to the interval containing the given date (e. g. to month \"October\" if the \"15th October ...\" is passed).",
          "returnType": "void",
          "parameters": [
            {
              "type": "LocalDate",
              "name": "date"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "scrollToTime",
          "description": "Programatically scroll the current view to the given time in the format `hh:mm:ss.sss`, `hh:mm:sss` or `hh:mm`. For example, '05:00' signifies 5 hours.",
          "returnType": "void",
          "parameters": [
            {
              "type": "String",
              "name": "duration"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "scrollToTime",
          "description": "Programatically scroll the current view to the given time in the format `hh:mm:ss.sss`, `hh:mm:sss` or `hh:mm`. For example, '05:00' signifies 5 hours.",
          "returnType": "void",
          "parameters": [
            {
              "type": "LocalTime",
              "name": "duration"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "setOption",
          "description": "Sets a option for this instance. Passing a null value removes the option.\n<br><br>\nPlease be aware that this method does not check the passed value. Explicit setter\nmethods should be prefered (e.g. #setLocale(Locale)).",
          "returnType": "void",
          "parameters": [
            {
              "type": "Option",
              "name": "option"
            },
            {
              "type": "Object",
              "name": "value"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "setOption",
          "description": "Sets an option for this instance. Passing a null value removes the option. The third parameter\nmight be used to explicitly store a \"more complex\" variant of the option's value to be returned\nby #getOption(Option). It is always stored when not equal to the value except for null.\nIf it is equal to the value or null it will not be stored (old version will be removed from internal cache).\n<br><br>\nExample:\n<pre>\n// sends a client parseable version to client and stores original in server side\ncalenda",
          "returnType": "void",
          "parameters": [
            {
              "type": "Option",
              "name": "option"
            },
            {
              "type": "Object",
              "name": "value"
            },
            {
              "type": "Object",
              "name": "valueForServerSide"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "setOption",
          "description": "Sets an option for this instance. Passing a null value removes the option.\n<br><br>\nPlease be aware that this method does not check the passed value. Explicit setter\nmethods should be prefered (e.g. #setLocale(Locale)).\n<br><br>\nFor a full overview of possible options have a look at the FullCalendar documentation\n(<a href='https://fullcalendar.io/docs'>https://fullcalendar.io/docs</a>).",
          "returnType": "void",
          "parameters": [
            {
              "type": "String",
              "name": "option"
            },
            {
              "type": "Object",
              "name": "value"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "setOption",
          "description": "Sets an option for this instance. Passing a null value removes the option. The third parameter\nmight be used to explicitly store a \"more complex\" variant of the option's value to be returned\nby #getOption(Option). It is always stored when not equal to the value except for null.\nIf it is equal to the value or null it will not be stored (old version will be removed from internal cache).\n<br><br>\nPlease be aware that this method does not check the passed value. Explicit setter\nmethods should be pre",
          "returnType": "void",
          "parameters": [
            {
              "type": "String",
              "name": "option"
            },
            {
              "type": "Object",
              "name": "value"
            },
            {
              "type": "Object",
              "name": "valueForServerSide"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "setFirstDay",
          "description": "Sets the first day of a week to be shown by the calendar. Per default sunday.\n<br><br>\n<b>Note:</b> FC works internally with 0 for sunday. This method converts SUNDAY to\nthis number before passing it to the client.",
          "returnType": "void",
          "parameters": [
            {
              "type": "DayOfWeek",
              "name": "firstDay"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "setHeight",
          "description": "Sets the calendar's height to a fixed amount of pixels.\n\n@deprecated Use #setHeight(String) or #setHeight(float, Unit) instead",
          "returnType": "void",
          "parameters": [
            {
              "type": "int",
              "name": "heightInPixels"
            }
          ],
          "annotations": [
            "Deprecated"
          ],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "setHeightByParent",
          "description": "Sets the calendar's height to be calculated from parents height. Please be aware, that a block parent with\nrelative height (e. g. 100%) might not work properly. In this case use flex layout or set a fixed height for\nthe parent or the calendar.\n@deprecated Use #setHeight(String) or #setHeight(float, Unit) instead",
          "returnType": "void",
          "parameters": [],
          "annotations": [
            "Deprecated"
          ],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "setHeightAuto",
          "description": "Sets the calendar's height to be calculated automatically. In current implementation this means by the calendars\nwidth-height-ratio.\n@deprecated Use #setHeight(String) or #setHeight(float, Unit) instead",
          "returnType": "void",
          "parameters": [],
          "annotations": [
            "Deprecated"
          ],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "setHeight",
          "description": "",
          "returnType": "void",
          "parameters": [
            {
              "type": "String",
              "name": "height"
            }
          ],
          "annotations": [
            "Override"
          ],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "setTimeslotsSelectable",
          "description": "Set if timeslots might be selected by the user. Please see also documentation of #addTimeslotsSelectedListener(ComponentEventListener).",
          "returnType": "void",
          "parameters": [
            {
              "type": "boolean",
              "name": "selectable"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "setWeekNumbersVisible",
          "description": "Should the calendar show week numbers (when available for the current view)?",
          "returnType": "void",
          "parameters": [
            {
              "type": "boolean",
              "name": "weekNumbersVisible"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "setWeekNumbersWithinDays",
          "description": "Determines the styling for week numbers in Month and DayGrid views.\n\n@deprecated this functionality is no longer supported, thus you can remove the call",
          "returnType": "void",
          "parameters": [
            {
              "type": "boolean",
              "name": "weekNumbersWithinDays"
            }
          ],
          "annotations": [
            "Deprecated"
          ],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "getLocale",
          "description": "Returns the current set locale.",
          "returnType": "Locale",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "setLocale",
          "description": "Sets the locale to be used. If invoked for the first time it will load additional language scripts.",
          "returnType": "void",
          "parameters": [
            {
              "type": "Locale",
              "name": "locale"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "setNowIndicatorShown",
          "description": "If true is passed then the calendar will show a indicator for the current time, depending on the view.",
          "returnType": "void",
          "parameters": [
            {
              "type": "boolean",
              "name": "shown"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "setNumberClickable",
          "description": "When true is passed the day / week numbers (or texts) will become clickable by the user and fire an event\nfor the clicked day / week.",
          "returnType": "void",
          "parameters": [
            {
              "type": "boolean",
              "name": "clickable"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "setEntryClassNamesCallback",
          "description": "The given string will be interpreted as JS function on the client side\nand attached to the calendar as the eventClassNames callback. It must be a valid JavaScript function.\n<br><br>\nA ClassName Input for adding classNames to the outermost event element. If supplied as a callback function, it is called every time the associated event data changes.\n<br><br>\n<b>Note: </b> Please be aware, that there is <b>NO</b> content parsing, escaping, quoting or\nother security mechanism applied on this string, ",
          "returnType": "void",
          "parameters": [
            {
              "type": "String",
              "name": "s"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "setEntryDidMountCallback",
          "description": "The given string will be interpreted as JS function on the client side\nand attached to the calendar as the eventDidMount callback. It must be a valid JavaScript function.\n<br><br>\nCalled right after the element has been added to the DOM. If the event data changes, this is <b>NOT</b> called again.\n<br><br>\n<b>Note: </b> Please be aware, that there is <b>NO</b> content parsing, escaping, quoting or\nother security mechanism applied on this string, so check it yourself before passing it to the clien",
          "returnType": "void",
          "parameters": [
            {
              "type": "String",
              "name": "s"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "addEntryNativeEventListener",
          "description": "Adds a native, client side / java script event listener, that will be added for all entries, when they\nare mounted. The first parameter is the java script event name (for instance \"click\" or \"mouseover\"), the\nsecond parameter is the javascript callback (e.g. \"e => console.warn(e)\" or \"e => alert('Hello')\").\n<br><br>\nThis method does NOT check, if you pass valid event names or callbacks. It will also NOT sanitize the given\ncontent, but pass it to the client as it is. <b>Be careful to not provide ",
          "returnType": "void",
          "parameters": [
            {
              "type": "String",
              "name": "eventName"
            },
            {
              "type": "String",
              "name": "eventCallback"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "setEntryWillUnmountCallback",
          "description": "The given string will be interpreted as JS function on the client side\nand attached to the calendar as the eventWillUnmount callback. It must be a valid JavaScript function.\n<br><br>\nCalled right before the element will be removed from the DOM.\n<br><br>\n<b>Note: </b> Please be aware, that there is <b>NO</b> content parsing, escaping, quoting or\nother security mechanism applied on this string, so check it yourself before passing it to the client.\n<br><br>",
          "returnType": "void",
          "parameters": [
            {
              "type": "String",
              "name": "s"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "setEntryContentCallback",
          "description": "The given string will be interpreted as JS function on the client side\nand attached to the calendar as the \"eventContent\" callback. It must be a valid JavaScript function.\n<br><br>\nCalled right after the element has been added to the DOM.\n<b>Note: </b> Please be aware, that there is <b>NO</b> content parsing, escaping, quoting or\nother security mechanism applied on this string, so check it yourself before passing it to the client.\n<br><br>",
          "returnType": "void",
          "parameters": [
            {
              "type": "String",
              "name": "s"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "setBusinessHours",
          "description": "Sets the business hours for this calendar instance. You may pass multiple instances for different configurations.\nPlease be aware, that instances with crossing days or times are handled by the client side and may lead\nto unexpected results.",
          "returnType": "void",
          "parameters": [
            {
              "type": "BusinessHours...",
              "name": "hours"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "removeBusinessHours",
          "description": "Removes the business hours for this calendar instance.",
          "returnType": "void",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "setSnapDuration",
          "description": "Sets the snap duration for this calendar instance.<p>\nThe default is '00:30'",
          "returnType": "void",
          "parameters": [
            {
              "type": "String",
              "name": "duration"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "setSlotMinTime",
          "description": "Sets the min time for this calendar instance. This is the first time slot that will be displayed for each day.<p>\nThe default is '00:00:00'",
          "returnType": "void",
          "parameters": [
            {
              "type": "LocalTime",
              "name": "slotMinTime"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "getFixedWeekCount",
          "description": "Returns the fixedWeekCount. By default true.",
          "returnType": "boolean",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "setFixedWeekCount",
          "description": "Determines the number of weeks displayed in a month view.\nIf true, the calendar will always be 6 weeks tall.\nIf false, the calendar will have either 4, 5, or 6 weeks, depending on the month.",
          "returnType": "void",
          "parameters": [
            {
              "type": "boolean",
              "name": "fixedWeekCount"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "setSlotMaxTime",
          "description": "Sets the max time for this calendar instance. This is the last time slot that will be displayed for each day<p>\nThe default is '24:00:00'",
          "returnType": "void",
          "parameters": [
            {
              "type": "LocalTime",
              "name": "slotMaxTime"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "getTimezone",
          "description": "Returns the current timezone of this calendar. Entries will be displayed related to this timezone.\nDoes not affect the server side times of entries, only their client side displayment.",
          "returnType": "Timezone",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "setTimezone",
          "description": "Sets the timezone the calendar shall show. Does not affect the entries directly but only their client side displayment.",
          "returnType": "void",
          "parameters": [
            {
              "type": "Timezone",
              "name": "timezone"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "getEntryDurationEditable",
          "description": "Returns the editable flag. By default true.",
          "returnType": "boolean",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "setEntryDurationEditable",
          "description": "Allow events durations to be editable through resizing.\n<p>\nThis option can be overridden with org.vaadin.stefan.fullcalendar.Entry#setDurationEditable(Boolean)",
          "returnType": "void",
          "parameters": [
            {
              "type": "boolean",
              "name": "editable"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "getEntryResizableFromStart",
          "description": "Returns the editable flag. By default false.",
          "returnType": "boolean",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "setEntryResizableFromStart",
          "description": "Whether the user can resize an event from its starting edge.",
          "returnType": "void",
          "parameters": [
            {
              "type": "boolean",
              "name": "editable"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "getEntryStartEditable",
          "description": "Returns the editable flag. By default true.",
          "returnType": "boolean",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "setEntryStartEditable",
          "description": "Allow events start times to be editable through dragging.\n<p>\nThis option can be overridden with org.vaadin.stefan.fullcalendar.Entry#setStartEditable(Boolean)",
          "returnType": "void",
          "parameters": [
            {
              "type": "boolean",
              "name": "editable"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        }
      ],
      "fields": [
        {
          "name": "FC_CLIENT_VERSION",
          "type": "String",
          "description": "",
          "annotations": [],
          "isPublic": true,
          "isStatic": true,
          "isFinal": true
        },
        {
          "name": "DEFAULT_TIMED_EVENT_DURATION",
          "type": "int",
          "description": "",
          "annotations": [],
          "isPublic": true,
          "isStatic": true,
          "isFinal": true
        },
        {
          "name": "DEFAULT_DAY_EVENT_DURATION",
          "type": "int",
          "description": "",
          "annotations": [],
          "isPublic": true,
          "isStatic": true,
          "isFinal": true
        }
      ],
      "constructors": [
        {
          "description": "Creates a new instance without any settings beside the default locale (CalendarLocale#getDefaultLocale()).\n<p></p>\nUses InMemoryEntryProvider by default.",
          "parameters": [],
          "annotations": [],
          "isPublic": true
        },
        {
          "description": "Creates a new instance.\n<br><br>\nExpects the default limit of entries shown per day. This does not affect basic or\nlist views. This value has to be set here and cannot be modified afterwards due to\ntechnical reasons of FC. If set afterwards the entry limit would overwrite settings\nand would show the limit also for basic views where it makes no sense (might change in future).\nPassing a negative number disabled the entry limit (same as passing no number at all).\n<br><br>\nSets the locale to Calenda",
          "parameters": [
            {
              "type": "int",
              "name": "entryLimit"
            }
          ],
          "annotations": [],
          "isPublic": true
        },
        {
          "description": "Creates a new instance with custom initial options. This allows a full override of the default\ninitial options, that the calendar would normally receive. Theoretically you can set all options,\nas long as they are not based on a client side variable (as for instance \"plugins\" or \"locales\").\nComplex objects are possible, too, for instance for view-specific settings.\nPlease refer to the official FC documentation regarding potential options.\n<br><br>\nClient side event handlers, that are technically ",
          "parameters": [
            {
              "type": "ObjectNode",
              "name": "initialOptions"
            }
          ],
          "annotations": [],
          "isPublic": true
        }
      ],
      "annotations": [
        "Tag",
        "CssImport",
        "JsModule",
        "NpmPackage",
        "NpmPackage",
        "NpmPackage",
        "NpmPackage",
        "NpmPackage",
        "NpmPackage",
        "NpmPackage",
        "NpmPackage",
        "NpmPackage",
        "NpmPackage"
      ],
      "isPublic": true,
      "source": "addon"
    },
    {
      "name": "FullCalendarBuilder",
      "packageName": "org.vaadin.stefan.fullcalendar",
      "fullName": "org.vaadin.stefan.fullcalendar.FullCalendarBuilder",
      "description": "This class can be used to create FullCalendar instances via a fluent builder api. Every method returns\nan immutable builder instance.",
      "type": "class",
      "methods": [
        {
          "name": "build",
          "description": "Builds the FullCalendar with the settings of this instance. Depending on some settings the returned\ninstance might be a subclass of FullCalendar.",
          "returnType": "<T extends FullCalendar> T",
          "parameters": [],
          "annotations": [
            "SuppressWarnings"
          ],
          "isPublic": true,
          "isStatic": false
        }
      ],
      "fields": [],
      "constructors": [],
      "annotations": [],
      "isPublic": true,
      "source": "addon"
    },
    {
      "name": "FullCalendarVariant",
      "packageName": "org.vaadin.stefan.fullcalendar",
      "fullName": "org.vaadin.stefan.fullcalendar.FullCalendarVariant",
      "description": "Themevariants for the FullCalendar. Use FullCalendar#addThemeVariants(FullCalendarVariant...) to\napply them.",
      "type": "enum",
      "methods": [],
      "fields": [],
      "constructors": [],
      "annotations": [
        "Getter"
      ],
      "isPublic": true,
      "source": "addon"
    },
    {
      "name": "JsonFactory",
      "packageName": "org.vaadin.stefan.fullcalendar",
      "fullName": "org.vaadin.stefan.fullcalendar.JsonFactory",
      "description": "Factory to create new objects. Wraps the current json framework.",
      "type": "class",
      "methods": [
        {
          "name": "factory",
          "description": "Returns the factory instance, that is used to create json nodes.",
          "returnType": "JsonNodeFactory",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": true
        },
        {
          "name": "createArray",
          "description": "Creates an empty array node.",
          "returnType": "ArrayNode",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": true
        },
        {
          "name": "createObject",
          "description": "Creates an empty object node.",
          "returnType": "ObjectNode",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": true
        },
        {
          "name": "create",
          "description": "Creates a number node with the given double.",
          "returnType": "NumericNode",
          "parameters": [
            {
              "type": "double",
              "name": "value"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": true
        },
        {
          "name": "create",
          "description": "Creates a number node with the given integer.",
          "returnType": "NumericNode",
          "parameters": [
            {
              "type": "int",
              "name": "value"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": true
        },
        {
          "name": "create",
          "description": "Creates a number node with the given long.",
          "returnType": "NumericNode",
          "parameters": [
            {
              "type": "long",
              "name": "value"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": true
        },
        {
          "name": "create",
          "description": "Creates a string node with the given text.",
          "returnType": "StringNode",
          "parameters": [
            {
              "type": "String",
              "name": "value"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": true
        },
        {
          "name": "create",
          "description": "Creates a boolean node with the value.",
          "returnType": "BooleanNode",
          "parameters": [
            {
              "type": "boolean",
              "name": "value"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": true
        },
        {
          "name": "createNull",
          "description": "Creates a node, that represents a null value.",
          "returnType": "NullNode",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": true
        }
      ],
      "fields": [],
      "constructors": [],
      "annotations": [],
      "isPublic": true,
      "source": "addon"
    },
    {
      "name": "JsonPropertyConverter",
      "packageName": "org.vaadin.stefan.fullcalendar",
      "fullName": "org.vaadin.stefan.fullcalendar.JsonPropertyConverter",
      "description": "Converts a server side value to a json value and (optionally) vice versa.",
      "type": "interface",
      "methods": [],
      "fields": [],
      "constructors": [],
      "annotations": [],
      "isPublic": true,
      "source": "addon"
    },
    {
      "name": "JsonUtils",
      "packageName": "org.vaadin.stefan.fullcalendar",
      "fullName": "org.vaadin.stefan.fullcalendar.JsonUtils",
      "description": "JsonUtils used for internally handling conversion of objects sent to or received from the client side.",
      "type": "class",
      "methods": [
        {
          "name": "toJsonNode",
          "description": "Converts the given object to a json value. Can be null.",
          "returnType": "JsonNode",
          "parameters": [
            {
              "type": "Object",
              "name": "value"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": true
        },
        {
          "name": "toJsonNode",
          "description": "Converts the given object to a json value. Can be null. The given custom converter is applied, when\nthere is no default conversion found for the given value. Can be null to convert it to a simple string.",
          "returnType": "JsonNode",
          "parameters": [
            {
              "type": "Object",
              "name": "value"
            },
            {
              "type": "SerializableFunction<Object, JsonNode>",
              "name": "customConverter"
            }
          ],
          "annotations": [
            "SuppressWarnings"
          ],
          "isPublic": true,
          "isStatic": true
        },
        {
          "name": "isCollectable",
          "description": "Returns true, if this value would be converted to a json array (or iterable like) for the client, like\nany Java iterable, stream, array, map or iterator.",
          "returnType": "boolean",
          "parameters": [
            {
              "type": "Object",
              "name": "value"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": true
        },
        {
          "name": "formatClientSideTimeString",
          "description": "",
          "returnType": "String",
          "parameters": [
            {
              "type": "Object",
              "name": "value"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": true
        },
        {
          "name": "formatClientSideDateString",
          "description": "",
          "returnType": "String",
          "parameters": [
            {
              "type": "Object",
              "name": "value"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": true
        },
        {
          "name": "formatClientSideDateTimeString",
          "description": "",
          "returnType": "String",
          "parameters": [
            {
              "type": "Object",
              "name": "value"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": true
        },
        {
          "name": "parseClientSideDate",
          "description": "Parses a date string sent from the client side.",
          "returnType": "LocalDate",
          "parameters": [
            {
              "type": "String",
              "name": "dateString"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": true
        },
        {
          "name": "parseClientSideDateTime",
          "description": "Parses a date string sent from the client side. Will be converted to a UTC.",
          "returnType": "LocalDateTime",
          "parameters": [
            {
              "type": "String",
              "name": "dateTimeString"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": true
        },
        {
          "name": "parseClientSideTime",
          "description": "Parses a time string sent from the client side. Will be converted to a UTC.",
          "returnType": "LocalTime",
          "parameters": [
            {
              "type": "String",
              "name": "timeString"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": true
        },
        {
          "name": "ofJsonNode",
          "description": "Shortcut method for #ofJsonNode(JsonNode, SerializableFunction, Collection, Class). Reads a json value object and\ntries to parse it to a Java object.\n<p></p>\nMost basic types are automatically converted. Since Json objects represent a more complex structure, the\ngiven callback can be used to convert them to their Java representation. This method converts them automatically\ninto a Map, using #convertObjectToMap(tools.jackson.databind.node.ObjectNode, Class).\n<p></p>\nJson arrays are automatically ",
          "returnType": "<T> T",
          "parameters": [
            {
              "type": "JsonNode",
              "name": "jsonValue"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": true
        },
        {
          "name": "ofJsonNode",
          "description": "Shortcut method for #ofJsonNode(JsonNode, SerializableFunction, Collection, Class). Reads a json value object and\ntries to parse it to a Java object.\n<p></p>\nMost basic types are automatically converted. Since Json objects represent a more complex structure, the\ngiven callback can be used to convert them to their Java representation. This method converts them automatically\ninto a Map, using #convertObjectToMap(tools.jackson.databind.node.ObjectNode, Class).\n<p></p>\nJson arrays are converted to t",
          "returnType": "<T> T",
          "parameters": [
            {
              "type": "JsonNode",
              "name": "jsonValue"
            },
            {
              "type": "Class<? extends Collection>",
              "name": "convertArrayToType"
            }
          ],
          "annotations": [
            "SuppressWarnings"
          ],
          "isPublic": true,
          "isStatic": true
        },
        {
          "name": "convertObjectToMap",
          "description": "Simple method, that converts a json object to a map. Calls #ofJsonNode(JsonNode, Class) for each\nread value.",
          "returnType": "Map<String, Object>",
          "parameters": [
            {
              "type": "ObjectNode",
              "name": "object"
            },
            {
              "type": "Class<? extends Collection>",
              "name": "convertArrayToType"
            }
          ],
          "annotations": [
            "SuppressWarnings"
          ],
          "isPublic": true,
          "isStatic": true
        }
      ],
      "fields": [],
      "constructors": [],
      "annotations": [],
      "isPublic": true,
      "source": "addon"
    },
    {
      "name": "MoreLinkClickedEvent",
      "packageName": "org.vaadin.stefan.fullcalendar",
      "fullName": "org.vaadin.stefan.fullcalendar.MoreLinkClickedEvent",
      "description": "This event is fired when a user clicks the \"+x more\" link in the calendar (which occurs when the max\nentries per day are exceeded).",
      "type": "class",
      "extends": "MultipleEntriesDataEvent",
      "methods": [],
      "fields": [],
      "constructors": [],
      "annotations": [
        "ToString",
        "Getter",
        "DomEvent"
      ],
      "isPublic": true,
      "source": "addon"
    },
    {
      "name": "MultipleEntriesDataEvent",
      "packageName": "org.vaadin.stefan.fullcalendar",
      "fullName": "org.vaadin.stefan.fullcalendar.MultipleEntriesDataEvent",
      "description": "Extended multple entries event type, that provides also additional client side entry data, that can be\ninterpreted on the server side.",
      "type": "class",
      "extends": "MultipleEntriesEvent",
      "methods": [],
      "fields": [],
      "constructors": [
        {
          "description": "New instance. Awaits the changed data object.",
          "parameters": [
            {
              "type": "FullCalendar",
              "name": "source"
            },
            {
              "type": "boolean",
              "name": "fromClient"
            },
            {
              "type": "ArrayNode",
              "name": "jsonObjects"
            }
          ],
          "annotations": [],
          "isPublic": true
        }
      ],
      "annotations": [
        "ToString",
        "Getter"
      ],
      "isPublic": true,
      "source": "addon"
    },
    {
      "name": "MultipleEntriesEvent",
      "packageName": "org.vaadin.stefan.fullcalendar",
      "fullName": "org.vaadin.stefan.fullcalendar.MultipleEntriesEvent",
      "description": "Simple event that occurred for multiple calendar items.",
      "type": "class",
      "extends": "ComponentEvent<FullCalendar>",
      "methods": [
        {
          "name": "getEntries",
          "description": "Returns the entries for which this event occurred. Never null nor empty.",
          "returnType": "Collection<Entry>",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        }
      ],
      "fields": [],
      "constructors": [
        {
          "description": "New instance. Awaits the entry id.",
          "parameters": [
            {
              "type": "FullCalendar",
              "name": "source"
            },
            {
              "type": "boolean",
              "name": "fromClient"
            },
            {
              "type": "Collection<String>",
              "name": "entryIds"
            }
          ],
          "annotations": [],
          "isPublic": true
        }
      ],
      "annotations": [
        "ToString",
        "Getter"
      ],
      "isPublic": true,
      "source": "addon"
    },
    {
      "name": "RecurringTime",
      "packageName": "org.vaadin.stefan.fullcalendar",
      "fullName": "org.vaadin.stefan.fullcalendar.RecurringTime",
      "description": "A simple time class, that allows times above 24 hours, since the FC allows recurring times to \"bleed\" into the\nnext day. Basically a simple variant of Duration with a specific purpose.",
      "type": "class",
      "methods": [
        {
          "name": "toLocalTime",
          "description": "Converts this recurring time to a local time. Be careful, as LocalTime does not support times of 24h or\nabove and thus such an instance will lead to an exception.",
          "returnType": "LocalTime",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "toDuration",
          "description": "Converts this instance to a Duration instance.",
          "returnType": "Duration",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "toFormattedString",
          "description": "Returns this instance as a formatted string. The pattern is always \"HH:mm\".",
          "returnType": "String",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "isValidLocalTime",
          "description": "",
          "returnType": "boolean",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "equals",
          "description": "",
          "returnType": "boolean",
          "parameters": [
            {
              "type": "LocalTime",
              "name": "localTime"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "isAfter",
          "description": "",
          "returnType": "boolean",
          "parameters": [
            {
              "type": "RecurringTime",
              "name": "recurringTime"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "isBefore",
          "description": "",
          "returnType": "boolean",
          "parameters": [
            {
              "type": "RecurringTime",
              "name": "recurringTime"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "isAfter",
          "description": "",
          "returnType": "boolean",
          "parameters": [
            {
              "type": "LocalTime",
              "name": "recurringTime"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "isBefore",
          "description": "",
          "returnType": "boolean",
          "parameters": [
            {
              "type": "LocalTime",
              "name": "recurringTime"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "equals",
          "description": "",
          "returnType": "boolean",
          "parameters": [
            {
              "type": "Object",
              "name": "o"
            }
          ],
          "annotations": [
            "Override"
          ],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "hashCode",
          "description": "",
          "returnType": "int",
          "parameters": [],
          "annotations": [
            "Override"
          ],
          "isPublic": true,
          "isStatic": false
        }
      ],
      "fields": [],
      "constructors": [],
      "annotations": [
        "Getter"
      ],
      "isPublic": true,
      "source": "addon"
    },
    {
      "name": "TimeslotClickedEvent",
      "packageName": "org.vaadin.stefan.fullcalendar",
      "fullName": "org.vaadin.stefan.fullcalendar.TimeslotClickedEvent",
      "description": "This event occurs when an empty timeslot in the calendar has clicked. Empty means the empty space itself, not that there\nis not yet another entry located at this timeslot.\n<br><br>\nClient side event: dateClick.",
      "type": "class",
      "extends": "DateTimeEvent",
      "methods": [],
      "fields": [],
      "constructors": [
        {
          "description": "New instance. Awaits the clicked date (time) as iso string (e.g. \"2018-10-23\" or \"2018-10-23T13:30\").",
          "parameters": [
            {
              "type": "FullCalendar",
              "name": "source"
            },
            {
              "type": "boolean",
              "name": "fromClient"
            }
          ],
          "annotations": [],
          "isPublic": true
        }
      ],
      "annotations": [
        "ToString",
        "DomEvent"
      ],
      "isPublic": true,
      "source": "addon"
    },
    {
      "name": "TimeslotsSelectedEvent",
      "packageName": "org.vaadin.stefan.fullcalendar",
      "fullName": "org.vaadin.stefan.fullcalendar.TimeslotsSelectedEvent",
      "description": "Occurs when the user selects one or multiple timeslots on the calendar. The selected timeslots may contain\nentries.\n<br><br>\nClient side event: select",
      "type": "class",
      "extends": "ComponentEvent<FullCalendar>",
      "methods": [
        {
          "name": "getStartAsInstant",
          "description": "Returns the entry's start as an Instant. The contained time is the same as when calling\n#getStart().",
          "returnType": "Instant",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "getEndAsInstant",
          "description": "Returns the entry's end as an Instant. The contained time is the same as when calling\n#getEnd().",
          "returnType": "Instant",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "getStartWithOffset",
          "description": "Returns the start time as a local date time after applying the timezone's offset to\nthe utc based start date (#getStart()). By default the timezone is\nthe calendar's timezone or, if no calendar is set yet, UTC.\n<p></p>",
          "returnType": "LocalDateTime",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "getEndWithOffset",
          "description": "Returns the end time as a local date time after applying the timezone's offset to\nthe utc based end date (#getEnd()). By default the timezone is\nthe calendar's timezone or, if no calendar is set yet, UTC.",
          "returnType": "LocalDateTime",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "getStartDate",
          "description": "Returns the start of the event as local date.",
          "returnType": "LocalDate",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "getEndDate",
          "description": "Returns the end of the event as local date.",
          "returnType": "LocalDate",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        }
      ],
      "fields": [],
      "constructors": [
        {
          "description": "New instance. Awaits the selected dates (time) as iso string (e.g. \"2018-10-23\" or \"2018-10-23T13:30\").",
          "parameters": [
            {
              "type": "FullCalendar",
              "name": "source"
            },
            {
              "type": "boolean",
              "name": "fromClient"
            }
          ],
          "annotations": [],
          "isPublic": true
        }
      ],
      "annotations": [
        "ToString",
        "Getter",
        "DomEvent"
      ],
      "isPublic": true,
      "source": "addon"
    },
    {
      "name": "Timezone",
      "packageName": "org.vaadin.stefan.fullcalendar",
      "fullName": "org.vaadin.stefan.fullcalendar.Timezone",
      "description": "Represents a timezone, that is usable by the calendar. The timezone is identified by a zone id and a client side\nrepresentation. The client side representation may differ from the zone id.",
      "type": "class",
      "implements": [
        "ClientSideValue"
      ],
      "methods": [
        {
          "name": "getAvailableZones",
          "description": "Returns all available timezones. This arrayy bases on all constants of this class plus all available zone ids\nreturned by ZoneId#getAvailableZoneIds().",
          "returnType": "Timezone[]",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": true
        },
        {
          "name": "getClientSideValue",
          "description": "Returns the client side value of this instance.",
          "returnType": "String",
          "parameters": [],
          "annotations": [
            "Override"
          ],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "applyTimezone",
          "description": "Creates a zoned date time based on this timezone interpreting the given local date time as UTC time.\nPassing ...T00:00 to a GMT+1 instance will result in local date time ...T01:00+01:00\n<p></p>\nFor the UTC instance this method will not modify anything. Passing null will return null.",
          "returnType": "ZonedDateTime",
          "parameters": [
            {
              "type": "LocalDateTime",
              "name": "localDateTime"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "removeTimezone",
          "description": "Creates a UTC zoned date time by interpreting the given local date time as a timestamp of this time zone.\nPassing ...T01:00 to a GMT+1 instance will result in local date time ...T00:00Z\n<p></p>\nFor the UTC instance this method will not modify anything.. Passing null will return null.",
          "returnType": "ZonedDateTime",
          "parameters": [
            {
              "type": "LocalDateTime",
              "name": "localDateTime"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "applyTimezoneOffset",
          "description": "Creates a local date time based by apply the zone offset of this timezone onto the given local date time.\nAny offset modifies like daylight saving will be based on the given local date time.\nPassing ...T00:00 to a GMT+1 instance will result in local date time ...T01:00\n<p></p>\nFor the UTC instance this method will not modify anything, but return a new local date time instance.\nPassing null will return null.",
          "returnType": "LocalDateTime",
          "parameters": [
            {
              "type": "LocalDateTime",
              "name": "localDateTime"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "removeTimezoneOffset",
          "description": "Creates a local date time based by removing the zone offset of this timezone from the given local date time.\nAny offset modifies like daylight saving will be based on the given local date time.\nPassing ...T01:00 to a GMT+1 instance will result in local date time ...T00:00\n<p></p>\nFor the UTC instance this method will not modify anything, but return a new local date time instance.\nPassing null will return null.",
          "returnType": "LocalDateTime",
          "parameters": [
            {
              "type": "LocalDateTime",
              "name": "localDateTime"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "asZonedDateTime",
          "description": "Converts the given local date time to a zoned date time without changing the time itself other then.\nPassing null will return null.\n#applyTimezone(LocalDateTime) or #removeTimezone(LocalDateTime).",
          "returnType": "ZonedDateTime",
          "parameters": [
            {
              "type": "LocalDateTime",
              "name": "localDateTime"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "convertToInstant",
          "description": "Applies the rules of this timezone on the given local date and creates an instant at the start\nof the given day. Please check the additional documentation on\njava.time.zone.ZoneRules#getOffset(LocalDateTime)",
          "returnType": "Instant",
          "parameters": [
            {
              "type": "LocalDate",
              "name": "date"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "convertToInstant",
          "description": "Applies the rules of this timezone on the given local date time and creates an instant. Please check\nthe additional documentation on java.time.zone.ZoneRules#getOffset(LocalDateTime)",
          "returnType": "Instant",
          "parameters": [
            {
              "type": "LocalDateTime",
              "name": "dateTime"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "convertToLocalDateTime",
          "description": "Applies the rules of this timezone on the given instant and creates a local date time.",
          "returnType": "LocalDateTime",
          "parameters": [
            {
              "type": "Instant",
              "name": "instant"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "convertToLocalDate",
          "description": "Applies the rules of this timezone on the given instant and creates a local date.",
          "returnType": "LocalDate",
          "parameters": [
            {
              "type": "Instant",
              "name": "instant"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "toString",
          "description": "",
          "returnType": "String",
          "parameters": [],
          "annotations": [
            "Override"
          ],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "equals",
          "description": "",
          "returnType": "boolean",
          "parameters": [
            {
              "type": "Object",
              "name": "o"
            }
          ],
          "annotations": [
            "Override"
          ],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "hashCode",
          "description": "",
          "returnType": "int",
          "parameters": [],
          "annotations": [
            "Override"
          ],
          "isPublic": true,
          "isStatic": false
        }
      ],
      "fields": [
        {
          "name": "ZONE_ID_UTC",
          "type": "ZoneId",
          "description": "",
          "annotations": [],
          "isPublic": true,
          "isStatic": true,
          "isFinal": true
        },
        {
          "name": "UTC",
          "type": "Timezone",
          "description": "",
          "annotations": [],
          "isPublic": true,
          "isStatic": true,
          "isFinal": true
        }
      ],
      "constructors": [
        {
          "description": "Creates a new instance based on the given zone id. The zone id is also used as client side representation.",
          "parameters": [
            {
              "type": "ZoneId",
              "name": "zoneId"
            }
          ],
          "annotations": [],
          "isPublic": true
        },
        {
          "description": "Creates a new instance based on the given zone id and client side value.",
          "parameters": [
            {
              "type": "ZoneId",
              "name": "zoneId"
            },
            {
              "type": "String",
              "name": "clientSideValue"
            }
          ],
          "annotations": [],
          "isPublic": true
        }
      ],
      "annotations": [],
      "isPublic": true,
      "source": "addon"
    },
    {
      "name": "ViewRenderEvent",
      "packageName": "org.vaadin.stefan.fullcalendar",
      "fullName": "org.vaadin.stefan.fullcalendar.ViewRenderEvent",
      "description": "Basic event for view render events. Provides information about the shown timespan.\n<br><br>\nThe values are always daybased, regardless of the current view.",
      "type": "class",
      "extends": "ComponentEvent<FullCalendar>",
      "methods": [
        {
          "name": "getName",
          "description": "Same as #getViewName()\n@deprecated use #getViewName() instead",
          "returnType": "String",
          "parameters": [],
          "annotations": [
            "Deprecated"
          ],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "getCalendarView",
          "description": "The calendar view of this event. Empty, if the view name could not be matched with one of the predefined\nviews (e.g. in case of a custom view).",
          "returnType": "Optional<CalendarView>",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        }
      ],
      "fields": [],
      "constructors": [
        {
          "description": "Creates a new event using the given source and indicator whether the\nevent originated from the client side or the server side.",
          "parameters": [
            {
              "type": "FullCalendar",
              "name": "source"
            },
            {
              "type": "boolean",
              "name": "fromClient"
            },
            {
              "type": "ObjectNode",
              "name": "eventData"
            }
          ],
          "annotations": [],
          "isPublic": true
        }
      ],
      "annotations": [
        "ToString",
        "Getter"
      ],
      "isPublic": true,
      "source": "addon"
    },
    {
      "name": "ViewSkeletonRenderedEvent",
      "packageName": "org.vaadin.stefan.fullcalendar",
      "fullName": "org.vaadin.stefan.fullcalendar.ViewSkeletonRenderedEvent",
      "description": "Occurs after a view's non-date-related DOM structure has been rendered. Provides information about the shown timespan.\n<br><br>\nThe values are always daybased, regardless of the current view.\n<br><br>\nCalled before registered DatesRenderedEvent listeners.",
      "type": "class",
      "extends": "ViewRenderEvent",
      "methods": [],
      "fields": [],
      "constructors": [
        {
          "description": "Creates a new event using the given source and indicator whether the\nevent originated from the client side or the server side.",
          "parameters": [
            {
              "type": "FullCalendar",
              "name": "source"
            },
            {
              "type": "boolean",
              "name": "fromClient"
            }
          ],
          "annotations": [],
          "isPublic": true
        }
      ],
      "annotations": [
        "ToString",
        "Getter",
        "DomEvent"
      ],
      "isPublic": true,
      "source": "addon"
    },
    {
      "name": "WeekNumberClickedEvent",
      "packageName": "org.vaadin.stefan.fullcalendar",
      "fullName": "org.vaadin.stefan.fullcalendar.WeekNumberClickedEvent",
      "description": "Occurs when number links are active and a user clicked on a week's number.",
      "type": "class",
      "extends": "DateEvent",
      "methods": [],
      "fields": [],
      "constructors": [
        {
          "description": "New instance. Awaits the date (time) as iso string (e.g. \"2018-10-23\" or \"2018-10-23T13:30\").",
          "parameters": [
            {
              "type": "FullCalendar",
              "name": "source"
            },
            {
              "type": "boolean",
              "name": "fromClient"
            }
          ],
          "annotations": [],
          "isPublic": true
        }
      ],
      "annotations": [
        "ToString",
        "DomEvent"
      ],
      "isPublic": true,
      "source": "addon"
    },
    {
      "name": "DayOfWeekItemConverter",
      "packageName": "org.vaadin.stefan.fullcalendar.converters",
      "fullName": "org.vaadin.stefan.fullcalendar.converters.DayOfWeekItemConverter",
      "description": "@author Stefan Uebe",
      "type": "class",
      "extends": "Entry>",
      "implements": [
        "JsonItemPropertyConverter<Set<DayOfWeek>",
        "T>"
      ],
      "methods": [
        {
          "name": "supports",
          "description": "",
          "returnType": "boolean",
          "parameters": [
            {
              "type": "Object",
              "name": "type"
            }
          ],
          "annotations": [
            "Override"
          ],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "toClientModel",
          "description": "",
          "returnType": "JsonNode",
          "parameters": [
            {
              "type": "Set<DayOfWeek>",
              "name": "serverValue"
            },
            {
              "type": "T",
              "name": "currentInstance"
            }
          ],
          "annotations": [
            "Override"
          ],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "toServerModel",
          "description": "",
          "returnType": "Set<DayOfWeek>",
          "parameters": [
            {
              "type": "JsonNode",
              "name": "clientValue"
            },
            {
              "type": "T",
              "name": "currentInstance"
            }
          ],
          "annotations": [
            "Override"
          ],
          "isPublic": true,
          "isStatic": false
        }
      ],
      "fields": [],
      "constructors": [],
      "annotations": [],
      "isPublic": true,
      "source": "addon"
    },
    {
      "name": "JsonItemPropertyConverter",
      "packageName": "org.vaadin.stefan.fullcalendar.converters",
      "fullName": "org.vaadin.stefan.fullcalendar.converters.JsonItemPropertyConverter",
      "description": "Converts a server side value to a json value and (optionally) vice versa. Also provides info\nabout the current parsed json item, if available.",
      "type": "interface",
      "methods": [],
      "fields": [],
      "constructors": [],
      "annotations": [],
      "isPublic": true,
      "source": "addon"
    },
    {
      "name": "LocalDateConverter",
      "packageName": "org.vaadin.stefan.fullcalendar.converters",
      "fullName": "org.vaadin.stefan.fullcalendar.converters.LocalDateConverter",
      "description": "@author Stefan Uebe",
      "type": "class",
      "extends": "Entry>",
      "implements": [
        "JsonItemPropertyConverter<LocalDate",
        "T>"
      ],
      "methods": [
        {
          "name": "supports",
          "description": "",
          "returnType": "boolean",
          "parameters": [
            {
              "type": "Object",
              "name": "type"
            }
          ],
          "annotations": [
            "Override"
          ],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "toClientModel",
          "description": "",
          "returnType": "JsonNode",
          "parameters": [
            {
              "type": "LocalDate",
              "name": "serverValue"
            },
            {
              "type": "T",
              "name": "currentInstance"
            }
          ],
          "annotations": [
            "Override"
          ],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "toServerModel",
          "description": "",
          "returnType": "LocalDate",
          "parameters": [
            {
              "type": "JsonNode",
              "name": "clientValue"
            },
            {
              "type": "T",
              "name": "currentInstance"
            }
          ],
          "annotations": [
            "Override"
          ],
          "isPublic": true,
          "isStatic": false
        }
      ],
      "fields": [],
      "constructors": [],
      "annotations": [
        "RequiredArgsConstructor",
        "Getter"
      ],
      "isPublic": true,
      "source": "addon"
    },
    {
      "name": "LocalDateTimeConverter",
      "packageName": "org.vaadin.stefan.fullcalendar.converters",
      "fullName": "org.vaadin.stefan.fullcalendar.converters.LocalDateTimeConverter",
      "description": "@author Stefan Uebe",
      "type": "class",
      "extends": "Entry>",
      "implements": [
        "JsonItemPropertyConverter<LocalDateTime",
        "T>"
      ],
      "methods": [
        {
          "name": "supports",
          "description": "",
          "returnType": "boolean",
          "parameters": [
            {
              "type": "Object",
              "name": "type"
            }
          ],
          "annotations": [
            "Override"
          ],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "toClientModel",
          "description": "",
          "returnType": "JsonNode",
          "parameters": [
            {
              "type": "LocalDateTime",
              "name": "serverValue"
            },
            {
              "type": "T",
              "name": "currentInstance"
            }
          ],
          "annotations": [
            "Override"
          ],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "toServerModel",
          "description": "",
          "returnType": "LocalDateTime",
          "parameters": [
            {
              "type": "JsonNode",
              "name": "clientValue"
            },
            {
              "type": "T",
              "name": "currentInstance"
            }
          ],
          "annotations": [
            "Override"
          ],
          "isPublic": true,
          "isStatic": false
        }
      ],
      "fields": [],
      "constructors": [],
      "annotations": [
        "RequiredArgsConstructor",
        "Getter"
      ],
      "isPublic": true,
      "source": "addon"
    },
    {
      "name": "LocalTimeConverter",
      "packageName": "org.vaadin.stefan.fullcalendar.converters",
      "fullName": "org.vaadin.stefan.fullcalendar.converters.LocalTimeConverter",
      "description": "@author Stefan Uebe",
      "type": "class",
      "extends": "Entry>",
      "implements": [
        "JsonItemPropertyConverter<LocalTime",
        "T>"
      ],
      "methods": [
        {
          "name": "supports",
          "description": "",
          "returnType": "boolean",
          "parameters": [
            {
              "type": "Object",
              "name": "type"
            }
          ],
          "annotations": [
            "Override"
          ],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "toClientModel",
          "description": "",
          "returnType": "JsonNode",
          "parameters": [
            {
              "type": "LocalTime",
              "name": "serverValue"
            },
            {
              "type": "T",
              "name": "currentInstance"
            }
          ],
          "annotations": [
            "Override"
          ],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "toServerModel",
          "description": "",
          "returnType": "LocalTime",
          "parameters": [
            {
              "type": "JsonNode",
              "name": "clientValue"
            },
            {
              "type": "T",
              "name": "currentInstance"
            }
          ],
          "annotations": [
            "Override"
          ],
          "isPublic": true,
          "isStatic": false
        }
      ],
      "fields": [],
      "constructors": [],
      "annotations": [
        "RequiredArgsConstructor",
        "Getter"
      ],
      "isPublic": true,
      "source": "addon"
    },
    {
      "name": "RecurringTimeConverter",
      "packageName": "org.vaadin.stefan.fullcalendar.converters",
      "fullName": "org.vaadin.stefan.fullcalendar.converters.RecurringTimeConverter",
      "description": "@author Stefan Uebe",
      "type": "class",
      "extends": "Entry>",
      "implements": [
        "JsonItemPropertyConverter<RecurringTime",
        "T>"
      ],
      "methods": [
        {
          "name": "supports",
          "description": "",
          "returnType": "boolean",
          "parameters": [
            {
              "type": "Object",
              "name": "type"
            }
          ],
          "annotations": [
            "Override"
          ],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "toClientModel",
          "description": "",
          "returnType": "JsonNode",
          "parameters": [
            {
              "type": "RecurringTime",
              "name": "serverValue"
            },
            {
              "type": "T",
              "name": "currentInstance"
            }
          ],
          "annotations": [
            "Override"
          ],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "toServerModel",
          "description": "",
          "returnType": "RecurringTime",
          "parameters": [
            {
              "type": "JsonNode",
              "name": "clientValue"
            },
            {
              "type": "T",
              "name": "currentInstance"
            }
          ],
          "annotations": [
            "Override"
          ],
          "isPublic": true,
          "isStatic": false
        }
      ],
      "fields": [],
      "constructors": [],
      "annotations": [],
      "isPublic": true,
      "source": "addon"
    },
    {
      "name": "AbstractEntryProvider",
      "packageName": "org.vaadin.stefan.fullcalendar.dataprovider",
      "fullName": "org.vaadin.stefan.fullcalendar.dataprovider.AbstractEntryProvider",
      "description": "Abstract base implementation of the EntryProvider interface.\n@author Stefan Uebe",
      "type": "class",
      "extends": "Entry>",
      "implements": [
        "EntryProvider<T>"
      ],
      "methods": [
        {
          "name": "refreshAll",
          "description": "",
          "returnType": "void",
          "parameters": [],
          "annotations": [
            "Override"
          ],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "refreshItem",
          "description": "",
          "returnType": "void",
          "parameters": [
            {
              "type": "T",
              "name": "item"
            }
          ],
          "annotations": [
            "Override"
          ],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "addEntriesChangeListener",
          "description": "",
          "returnType": "Registration",
          "parameters": [
            {
              "type": "EntriesChangeListener<T>",
              "name": "listener"
            }
          ],
          "annotations": [
            "Override"
          ],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "addEntryRefreshListener",
          "description": "",
          "returnType": "Registration",
          "parameters": [
            {
              "type": "EntryRefreshListener<T>",
              "name": "listener"
            }
          ],
          "annotations": [
            "Override"
          ],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "setCalendar",
          "description": "Sets the calendar. Throws an exception, when there is already a calendar set and it is not the\nsame instance as the given one.",
          "returnType": "void",
          "parameters": [
            {
              "type": "FullCalendar",
              "name": "calendar"
            }
          ],
          "annotations": [
            "Override"
          ],
          "isPublic": true,
          "isStatic": false
        }
      ],
      "fields": [],
      "constructors": [],
      "annotations": [],
      "isPublic": true,
      "source": "addon"
    },
    {
      "name": "CallbackEntryProvider",
      "packageName": "org.vaadin.stefan.fullcalendar.dataprovider",
      "fullName": "org.vaadin.stefan.fullcalendar.dataprovider.CallbackEntryProvider",
      "description": "An EntryProvider using a predefined callback to fetch items when necessary.\n\n@author Stefan Uebe",
      "type": "class",
      "extends": "Entry> extends AbstractEntryProvider<T>",
      "methods": [
        {
          "name": "fetch",
          "description": "",
          "returnType": "Stream<T>",
          "parameters": [
            {
              "type": "EntryQuery",
              "name": "query"
            }
          ],
          "annotations": [
            "Override"
          ],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "fetchById",
          "description": "",
          "returnType": "Optional<T>",
          "parameters": [
            {
              "type": "String",
              "name": "id"
            }
          ],
          "annotations": [
            "Override"
          ],
          "isPublic": true,
          "isStatic": false
        }
      ],
      "fields": [],
      "constructors": [
        {
          "description": "An EntryProvider using a predefined callback to fetch items when necessary.\n\n@author Stefan Uebe",
          "parameters": [
            {
              "type": "SerializableFunction<EntryQuery, Stream<T>>",
              "name": "fetchItems"
            },
            {
              "type": "SerializableFunction<String, T>",
              "name": "fetchSingleItem"
            }
          ],
          "annotations": [],
          "isPublic": true
        }
      ],
      "annotations": [],
      "isPublic": true,
      "source": "addon"
    },
    {
      "name": "EntriesChangeEvent",
      "packageName": "org.vaadin.stefan.fullcalendar.dataprovider",
      "fullName": "org.vaadin.stefan.fullcalendar.dataprovider.EntriesChangeEvent",
      "description": "This event is fired, when then items represents by an EntryProvider are about to change\nand a reaction (e.g. fetch) is necessary.\n@author Stefan Uebe",
      "type": "class",
      "extends": "Entry> extends EventObject",
      "methods": [
        {
          "name": "getSource",
          "description": "",
          "returnType": "EntryProvider<T>",
          "parameters": [],
          "annotations": [
            "SuppressWarnings",
            "Override"
          ],
          "isPublic": true,
          "isStatic": false
        }
      ],
      "fields": [],
      "constructors": [
        {
          "description": "Constructs a prototypical Event.",
          "parameters": [
            {
              "type": "EntryProvider<T>",
              "name": "source"
            }
          ],
          "annotations": [],
          "isPublic": true
        }
      ],
      "annotations": [],
      "isPublic": true,
      "source": "addon"
    },
    {
      "name": "EntryProvider",
      "packageName": "org.vaadin.stefan.fullcalendar.dataprovider",
      "fullName": "org.vaadin.stefan.fullcalendar.dataprovider.EntryProvider",
      "description": "An EntryProvider provides an API to fetch a list of entries based on filter parameters. It orientates\nin its functionality on the Vaadin com.vaadin.flow.data.provider.DataProvider, but is based\non time spans instead of row counts.\n@author Stefan Uebe",
      "type": "interface",
      "extends": "Entry>",
      "methods": [],
      "fields": [],
      "constructors": [],
      "annotations": [],
      "isPublic": true,
      "source": "addon"
    },
    {
      "name": "EntryQuery",
      "packageName": "org.vaadin.stefan.fullcalendar.dataprovider",
      "fullName": "org.vaadin.stefan.fullcalendar.dataprovider.EntryQuery",
      "description": "A class to provide filter parameters for an EntryProvider fetch query.\n@author Stefan Uebe",
      "type": "class",
      "methods": [
        {
          "name": "applyFilter",
          "description": "Convenience implementation to filter a stream based on this query.\n<p></p>\nSimply applies the filter to the given stream and returns a stream containing only entries matching it.\nEntries, that are \"crossing\" the time range border will be included in the stream.\n<p></p>\nReturns the same stream, when this filter is empty.",
          "returnType": "<T extends Entry> Stream<T>",
          "parameters": [
            {
              "type": "Stream<T>",
              "name": "stream"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        }
      ],
      "fields": [],
      "constructors": [
        {
          "description": "A class to provide filter parameters for an EntryProvider fetch query.\n@author Stefan Uebe",
          "parameters": [
            {
              "type": "LocalDateTime",
              "name": "start"
            },
            {
              "type": "LocalDateTime",
              "name": "end"
            }
          ],
          "annotations": [],
          "isPublic": true
        },
        {
          "description": "",
          "parameters": [
            {
              "type": "Instant",
              "name": "start"
            },
            {
              "type": "Instant",
              "name": "end"
            }
          ],
          "annotations": [],
          "isPublic": true
        },
        {
          "description": "",
          "parameters": [
            {
              "type": "Instant",
              "name": "start"
            },
            {
              "type": "Instant",
              "name": "end"
            },
            {
              "type": "AllDay",
              "name": "allDay"
            }
          ],
          "annotations": [],
          "isPublic": true
        }
      ],
      "annotations": [
        "Builder",
        "RequiredArgsConstructor",
        "AllArgsConstructor",
        "Getter"
      ],
      "isPublic": true,
      "source": "addon"
    },
    {
      "name": "EntryRefreshEvent",
      "packageName": "org.vaadin.stefan.fullcalendar.dataprovider",
      "fullName": "org.vaadin.stefan.fullcalendar.dataprovider.EntryRefreshEvent",
      "description": "This event is fired, when a single item shall be refreshed.\n@author Stefan Uebe",
      "type": "class",
      "extends": "Entry> extends EventObject",
      "methods": [
        {
          "name": "getSource",
          "description": "",
          "returnType": "EntryProvider<T>",
          "parameters": [],
          "annotations": [
            "SuppressWarnings",
            "Override"
          ],
          "isPublic": true,
          "isStatic": false
        }
      ],
      "fields": [],
      "constructors": [
        {
          "description": "Constructs a prototypical Event.",
          "parameters": [
            {
              "type": "EntryProvider<T>",
              "name": "source"
            },
            {
              "type": "T",
              "name": "itemToRefresh"
            }
          ],
          "annotations": [],
          "isPublic": true
        }
      ],
      "annotations": [
        "Getter"
      ],
      "isPublic": true,
      "source": "addon"
    },
    {
      "name": "InMemoryEntryProvider",
      "packageName": "org.vaadin.stefan.fullcalendar.dataprovider",
      "fullName": "org.vaadin.stefan.fullcalendar.dataprovider.InMemoryEntryProvider",
      "description": "Basic implementation of an in memory entry provider utilizing a hashmap.\n\n@author Stefan Uebe",
      "type": "class",
      "extends": "Entry> extends AbstractEntryProvider<T>",
      "implements": [
        "EntryProvider<T>"
      ],
      "methods": [
        {
          "name": "from",
          "description": "Creates a lazy loading instance. The given entries are used as initial items. Leave empty, if there\nare no initial entries.",
          "returnType": "<T extends Entry> InMemoryEntryProvider<T>",
          "parameters": [
            {
              "type": "T...",
              "name": "entries"
            }
          ],
          "annotations": [
            "SafeVarargs"
          ],
          "isPublic": true,
          "isStatic": true
        },
        {
          "name": "from",
          "description": "Creates a lazy loading instance. The given entries are used as initial items, but the given iterable\nis not used as the backing collection or similar. It will never be modified by this provider.",
          "returnType": "<T extends Entry> InMemoryEntryProvider<T>",
          "parameters": [
            {
              "type": "Iterable<T>",
              "name": "entries"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": true
        },
        {
          "name": "setCalendar",
          "description": "Connects this instance with the calendar. Not intended to be called manually, the FC will take care of this.\nNOOP when called for the same calendar instance multiple times.",
          "returnType": "void",
          "parameters": [
            {
              "type": "FullCalendar",
              "name": "calendar"
            }
          ],
          "annotations": [
            "Override"
          ],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "fetch",
          "description": "",
          "returnType": "Stream<T>",
          "parameters": [
            {
              "type": "EntryQuery",
              "name": "query"
            }
          ],
          "annotations": [
            "Override"
          ],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "fetchById",
          "description": "",
          "returnType": "Optional<T>",
          "parameters": [
            {
              "type": "String",
              "name": "id"
            }
          ],
          "annotations": [
            "Override"
          ],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "addEntries",
          "description": "Adds a list of entries to the calendar. Noop for already registered entries.",
          "returnType": "void",
          "parameters": [
            {
              "type": "Iterable<T>",
              "name": "iterableEntries"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "removeEntries",
          "description": "Removes the given entries. Noop for not registered entries.",
          "returnType": "void",
          "parameters": [
            {
              "type": "Iterable<T>",
              "name": "iterableEntries"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "updateEntries",
          "description": "Updates the given entries on the client side. Ignores non-registered entries.",
          "returnType": "void",
          "parameters": [
            {
              "type": "Iterable<T>",
              "name": "iterableEntries"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "onEntryUpdate",
          "description": "",
          "returnType": "void",
          "parameters": [
            {
              "type": "T",
              "name": "entry"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "getEntryById",
          "description": "Returns a single entry identified by the given id or an empty optional.",
          "returnType": "Optional<T>",
          "parameters": [
            {
              "type": "String",
              "name": "id"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "getEntries",
          "description": "Returns all entries of this instance.",
          "returnType": "List<T>",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "getEntries",
          "description": "Returns all entries, that lay inside or cross the given timespan.",
          "returnType": "List<T>",
          "parameters": [
            {
              "type": "LocalDateTime",
              "name": "filterStart"
            },
            {
              "type": "LocalDateTime",
              "name": "filterEnd"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "getEntries",
          "description": "Returns all entries, that lay inside or cross the given timespan.",
          "returnType": "List<T>",
          "parameters": [
            {
              "type": "Instant",
              "name": "filterStart"
            },
            {
              "type": "Instant",
              "name": "filterEnd"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "getEntries",
          "description": "Returns all entries registered in this instance which timespan crosses the given date as a new list.",
          "returnType": "List<T>",
          "parameters": [
            {
              "type": "Instant",
              "name": "dateTime"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "getEntries",
          "description": "Returns all entries registered in this instance which timespan crosses the given date as a new list.",
          "returnType": "List<T>",
          "parameters": [
            {
              "type": "LocalDate",
              "name": "date"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "getEntries",
          "description": "Returns all entries registered in this instance which timespan crosses the given date as a new list.",
          "returnType": "List<T>",
          "parameters": [
            {
              "type": "LocalDateTime",
              "name": "dateTime"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "addEntry",
          "description": "Adds an entry to this calendar. Noop if the entry id is already registered.",
          "returnType": "void",
          "parameters": [
            {
              "type": "T",
              "name": "entry"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "addEntries",
          "description": "Adds an array of entries to the calendar. Noop for the entry id is already registered.",
          "returnType": "void",
          "parameters": [
            {
              "type": "T...",
              "name": "arrayOfEntries"
            }
          ],
          "annotations": [
            "SuppressWarnings"
          ],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "removeEntry",
          "description": "Removes the given entry. Noop if the id is not registered.",
          "returnType": "void",
          "parameters": [
            {
              "type": "T",
              "name": "entry"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "removeEntries",
          "description": "Removes the given entries. Noop for not registered entries.",
          "returnType": "void",
          "parameters": [
            {
              "type": "T...",
              "name": "arrayOfEntries"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "removeAllEntries",
          "description": "Remove all entries.",
          "returnType": "void",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        }
      ],
      "fields": [],
      "constructors": [
        {
          "description": "Maps the entry ids to their respective entry instance. Any change to this map reflects directly\nto this instance.",
          "parameters": [],
          "annotations": [],
          "isPublic": true
        },
        {
          "description": "",
          "parameters": [
            {
              "type": "Iterable<T>",
              "name": "entries"
            }
          ],
          "annotations": [],
          "isPublic": true
        }
      ],
      "annotations": [],
      "isPublic": true,
      "source": "addon"
    },
    {
      "name": "AbstractHeaderFooter",
      "packageName": "org.vaadin.stefan.fullcalendar.model",
      "fullName": "org.vaadin.stefan.fullcalendar.model.AbstractHeaderFooter",
      "description": "Abstract base class for FC header and footer",
      "type": "class",
      "methods": [
        {
          "name": "getParts",
          "description": "Returns all parts. Never null",
          "returnType": "Set<HeaderFooterPart>",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "getStart",
          "description": "Convenience method to get the left part of this instance. Creates a new instance on the first call.",
          "returnType": "HeaderFooterPart",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "getCenter",
          "description": "Convenience method to get the center part of this instance. Creates a new instance on the first call.",
          "returnType": "HeaderFooterPart",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "getEnd",
          "description": "Convenience method to get the right part of this instance. Creates a new instance on the first call.",
          "returnType": "HeaderFooterPart",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "toJson",
          "description": "Converts the given object into a json object.",
          "returnType": "ObjectNode",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "addPart",
          "description": "Registers the given part. Overrides any previous set definitions.",
          "returnType": "void",
          "parameters": [
            {
              "type": "HeaderFooterPart",
              "name": "part"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        }
      ],
      "fields": [],
      "constructors": [],
      "annotations": [
        "ToString",
        "EqualsAndHashCode"
      ],
      "isPublic": true,
      "source": "addon"
    },
    {
      "name": "Footer",
      "packageName": "org.vaadin.stefan.fullcalendar.model",
      "fullName": "org.vaadin.stefan.fullcalendar.model.Footer",
      "description": "Definition of footer for a calendar instance.",
      "type": "class",
      "extends": "AbstractHeaderFooter",
      "methods": [],
      "fields": [],
      "constructors": [
        {
          "description": "Creates a new instance.",
          "parameters": [],
          "annotations": [],
          "isPublic": true
        },
        {
          "description": "Creates a new instance with the given parts.",
          "parameters": [
            {
              "type": "Collection<HeaderFooterPart>",
              "name": "parts"
            }
          ],
          "annotations": [],
          "isPublic": true
        }
      ],
      "annotations": [],
      "isPublic": true,
      "source": "addon"
    },
    {
      "name": "Header",
      "packageName": "org.vaadin.stefan.fullcalendar.model",
      "fullName": "org.vaadin.stefan.fullcalendar.model.Header",
      "description": "Definition of header for a calendar instance.",
      "type": "class",
      "extends": "AbstractHeaderFooter",
      "methods": [],
      "fields": [],
      "constructors": [
        {
          "description": "Creates a new instance.",
          "parameters": [],
          "annotations": [],
          "isPublic": true
        },
        {
          "description": "Creates a new instance with the given parts.",
          "parameters": [
            {
              "type": "Collection<HeaderFooterPart>",
              "name": "parts"
            }
          ],
          "annotations": [],
          "isPublic": true
        }
      ],
      "annotations": [],
      "isPublic": true,
      "source": "addon"
    },
    {
      "name": "HeaderFooterItem",
      "packageName": "org.vaadin.stefan.fullcalendar.model",
      "fullName": "org.vaadin.stefan.fullcalendar.model.HeaderFooterItem",
      "description": "A predefined enum of available items for the header / footer parts.",
      "type": "enum",
      "methods": [],
      "fields": [],
      "constructors": [],
      "annotations": [
        "Getter"
      ],
      "isPublic": true,
      "source": "addon"
    },
    {
      "name": "HeaderFooterPart",
      "packageName": "org.vaadin.stefan.fullcalendar.model",
      "fullName": "org.vaadin.stefan.fullcalendar.model.HeaderFooterPart",
      "description": "Definition of a part of the header and footer.",
      "type": "class",
      "methods": [
        {
          "name": "addItem",
          "description": "Item to add to this part.",
          "returnType": "void",
          "parameters": [
            {
              "type": "HeaderFooterItem",
              "name": "item"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "removeItem",
          "description": "Removes the given item from this part. Noop if the item has not been added.",
          "returnType": "void",
          "parameters": [
            {
              "type": "HeaderFooterItem",
              "name": "item"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "removeItems",
          "description": "Removes all items",
          "returnType": "void",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "getPosition",
          "description": "Returns the position of this instance.",
          "returnType": "HeaderFooterPartPosition",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "getItems",
          "description": "Returns all added items.",
          "returnType": "Set<HeaderFooterItem>",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        }
      ],
      "fields": [],
      "constructors": [
        {
          "description": "Creates a new instance for the given position.",
          "parameters": [
            {
              "type": "HeaderFooterPartPosition",
              "name": "position"
            }
          ],
          "annotations": [],
          "isPublic": true
        },
        {
          "description": "Creates a new instance for the given position with the given items to show.",
          "parameters": [
            {
              "type": "HeaderFooterPartPosition",
              "name": "position"
            },
            {
              "type": "Collection<HeaderFooterItem>",
              "name": "items"
            }
          ],
          "annotations": [],
          "isPublic": true
        }
      ],
      "annotations": [
        "ToString",
        "EqualsAndHashCode"
      ],
      "isPublic": true,
      "source": "addon"
    },
    {
      "name": "HeaderFooterPartPosition",
      "packageName": "org.vaadin.stefan.fullcalendar.model",
      "fullName": "org.vaadin.stefan.fullcalendar.model.HeaderFooterPartPosition",
      "description": "Definition of header and footer positions.",
      "type": "enum",
      "methods": [],
      "fields": [],
      "constructors": [],
      "annotations": [
        "Getter"
      ],
      "isPublic": true,
      "source": "addon"
    },
    {
      "name": "EntryDroppedSchedulerEvent",
      "packageName": "org.vaadin.stefan.fullcalendar",
      "fullName": "org.vaadin.stefan.fullcalendar.EntryDroppedSchedulerEvent",
      "description": "",
      "type": "class",
      "extends": "EntryTimeChangedEvent",
      "methods": [
        {
          "name": "applyChangesOnEntry",
          "description": "Applies the changes on the entry including updating a resource change.",
          "returnType": "Entry",
          "parameters": [],
          "annotations": [
            "Override"
          ],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "updateResourcesFromEventResourceDelta",
          "description": "",
          "returnType": "void",
          "parameters": [
            {
              "type": "ResourceEntry",
              "name": "entry"
            },
            {
              "type": "ObjectNode",
              "name": "object"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": true
        },
        {
          "name": "getOldResource",
          "description": "If there has been a change in the resource assignments, this method returns the previous assigned resource.",
          "returnType": "Optional<Resource>",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "getNewResource",
          "description": "If there has been a change in the resource assignments, this method returns the newly assigned resource.",
          "returnType": "Optional<Resource>",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        }
      ],
      "fields": [],
      "constructors": [],
      "annotations": [
        "ToString",
        "DomEvent"
      ],
      "isPublic": true,
      "source": "addon-scheduler"
    },
    {
      "name": "FullCalendarScheduler",
      "packageName": "org.vaadin.stefan.fullcalendar",
      "fullName": "org.vaadin.stefan.fullcalendar.FullCalendarScheduler",
      "description": "",
      "type": "class",
      "extends": "FullCalendar",
      "implements": [
        "Scheduler"
      ],
      "methods": [
        {
          "name": "setSchedulerLicenseKey",
          "description": "",
          "returnType": "void",
          "parameters": [
            {
              "type": "String",
              "name": "schedulerLicenseKey"
            }
          ],
          "annotations": [
            "Override"
          ],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "setResourceAreaHeaderContent",
          "description": "",
          "returnType": "void",
          "parameters": [
            {
              "type": "String",
              "name": "resourceAreaHeaderContent"
            }
          ],
          "annotations": [
            "Override"
          ],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "setResourceAreaWidth",
          "description": "",
          "returnType": "void",
          "parameters": [
            {
              "type": "String",
              "name": "resourceAreaWidth"
            }
          ],
          "annotations": [
            "Override"
          ],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "setSlotMinWidth",
          "description": "",
          "returnType": "void",
          "parameters": [
            {
              "type": "String",
              "name": "slotMinWidth"
            }
          ],
          "annotations": [
            "Override"
          ],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "setResourcesInitiallyExpanded",
          "description": "",
          "returnType": "void",
          "parameters": [
            {
              "type": "boolean",
              "name": "resourcesInitiallyExpanded"
            }
          ],
          "annotations": [
            "Override"
          ],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "setFilterResourcesWithEvents",
          "description": "",
          "returnType": "void",
          "parameters": [
            {
              "type": "boolean",
              "name": "filterResourcesWithEvents"
            }
          ],
          "annotations": [
            "Override"
          ],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "setResourceOrder",
          "description": "",
          "returnType": "void",
          "parameters": [
            {
              "type": "String",
              "name": "resourceOrder"
            }
          ],
          "annotations": [
            "Override"
          ],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "setEntryResourceEditable",
          "description": "",
          "returnType": "void",
          "parameters": [
            {
              "type": "boolean",
              "name": "eventResourceEditable"
            }
          ],
          "annotations": [
            "Override"
          ],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "addResources",
          "description": "",
          "returnType": "void",
          "parameters": [
            {
              "type": "Iterable<Resource>",
              "name": "iterableResource"
            }
          ],
          "annotations": [
            "Override"
          ],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "addResources",
          "description": "",
          "returnType": "void",
          "parameters": [
            {
              "type": "Iterable<Resource>",
              "name": "iterableResource"
            },
            {
              "type": "boolean",
              "name": "scrollToLast"
            }
          ],
          "annotations": [
            "Override"
          ],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "removeResources",
          "description": "",
          "returnType": "void",
          "parameters": [
            {
              "type": "Iterable<Resource>",
              "name": "iterableResources"
            }
          ],
          "annotations": [
            "Override"
          ],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "getResourceById",
          "description": "",
          "returnType": "Optional<Resource>",
          "parameters": [
            {
              "type": "String",
              "name": "id"
            }
          ],
          "annotations": [
            "Override"
          ],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "getResources",
          "description": "",
          "returnType": "Set<Resource>",
          "parameters": [],
          "annotations": [
            "Override"
          ],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "removeAllResources",
          "description": "",
          "returnType": "void",
          "parameters": [],
          "annotations": [
            "Override"
          ],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "setResourceLabelClassNamesCallback",
          "description": "",
          "returnType": "void",
          "parameters": [
            {
              "type": "String",
              "name": "s"
            }
          ],
          "annotations": [
            "Override"
          ],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "setResourceLabelContentCallback",
          "description": "",
          "returnType": "void",
          "parameters": [
            {
              "type": "String",
              "name": "s"
            }
          ],
          "annotations": [
            "Override"
          ],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "setResourceLabelDidMountCallback",
          "description": "",
          "returnType": "void",
          "parameters": [
            {
              "type": "String",
              "name": "s"
            }
          ],
          "annotations": [
            "Override"
          ],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "setResourceLablelWillUnmountCallback",
          "description": "",
          "returnType": "void",
          "parameters": [
            {
              "type": "String",
              "name": "s"
            }
          ],
          "annotations": [
            "Override"
          ],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "setResourceLaneClassNamesCallback",
          "description": "",
          "returnType": "void",
          "parameters": [
            {
              "type": "String",
              "name": "s"
            }
          ],
          "annotations": [
            "Override"
          ],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "setResourceLaneContentCallback",
          "description": "",
          "returnType": "void",
          "parameters": [
            {
              "type": "String",
              "name": "s"
            }
          ],
          "annotations": [
            "Override"
          ],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "setResourceLaneDidMountCallback",
          "description": "",
          "returnType": "void",
          "parameters": [
            {
              "type": "String",
              "name": "s"
            }
          ],
          "annotations": [
            "Override"
          ],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "setResourceLaneWillUnmountCallback",
          "description": "",
          "returnType": "void",
          "parameters": [
            {
              "type": "String",
              "name": "s"
            }
          ],
          "annotations": [
            "Override"
          ],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "setGroupEntriesBy",
          "description": "",
          "returnType": "void",
          "parameters": [
            {
              "type": "GroupEntriesBy",
              "name": "groupEntriesBy"
            }
          ],
          "annotations": [
            "Override"
          ],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "addTimeslotsSelectedListener",
          "description": "",
          "returnType": "Registration",
          "parameters": [
            {
              "type": "ComponentEventListener<? extends TimeslotsSelectedEvent>",
              "name": "listener"
            }
          ],
          "annotations": [
            "SuppressWarnings",
            "Override"
          ],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "addTimeslotsSelectedSchedulerListener",
          "description": "",
          "returnType": "Registration",
          "parameters": [
            {
              "type": "ComponentEventListener<? extends TimeslotsSelectedSchedulerEvent>",
              "name": "listener"
            }
          ],
          "annotations": [
            "SuppressWarnings",
            "Override"
          ],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "addTimeslotClickedListener",
          "description": "",
          "returnType": "Registration",
          "parameters": [
            {
              "type": "ComponentEventListener<? extends TimeslotClickedEvent>",
              "name": "listener"
            }
          ],
          "annotations": [
            "SuppressWarnings",
            "Override"
          ],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "addTimeslotClickedSchedulerListener",
          "description": "",
          "returnType": "Registration",
          "parameters": [
            {
              "type": "ComponentEventListener<? extends TimeslotClickedSchedulerEvent>",
              "name": "listener"
            }
          ],
          "annotations": [
            "SuppressWarnings",
            "Override"
          ],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "addEntryDroppedSchedulerListener",
          "description": "",
          "returnType": "Registration",
          "parameters": [
            {
              "type": "ComponentEventListener<? extends EntryDroppedSchedulerEvent>",
              "name": "listener"
            }
          ],
          "annotations": [
            "SuppressWarnings",
            "Override"
          ],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "setOption",
          "description": "Sets a option for this instance. Passing a null value removes the option.\n<br><br>\nPlease be aware that this method does not check the passed value. Explicit setter\nmethods should be prefered (e.g. #setLocale(Locale)).",
          "returnType": "void",
          "parameters": [
            {
              "type": "SchedulerOption",
              "name": "option"
            },
            {
              "type": "Serializable",
              "name": "value"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "setOption",
          "description": "Sets a option for this instance. Passing a null value removes the option. The third parameter\nmight be used to explicitly store a \"more complex\" variant of the option's value to be returned\nby #getOption(SchedulerOption). It is always stored when not equal to the value except for null.\nIf it is equal to the value or null it will not be stored (old version will be removed from internal cache).\n<pre>\nPlease be aware that this method does not check the passed value. Explicit setter\nmethods should b",
          "returnType": "void",
          "parameters": [
            {
              "type": "SchedulerOption",
              "name": "option"
            },
            {
              "type": "Serializable",
              "name": "value"
            },
            {
              "type": "Object",
              "name": "valueForServerSide"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "getOption",
          "description": "Returns an optional option value or empty, that has been set for that key via one of the setOptions methods.\nIf a server side version of the value has been set\nvia #setOption(SchedulerOption, Serializable, Object), that will be returned instead.\n<br><br>\nIf there is a explicit getter method, it is recommended to use these instead (e.g. #getLocale()).",
          "returnType": "<T> Optional<T>",
          "parameters": [
            {
              "type": "SchedulerOption",
              "name": "option"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "getOption",
          "description": "Returns an optional option value or empty, that has been set for that key via one of the setOptions methods.\nIf the second parameter is false and a server side version of the\nvalue has been set via #setOption(SchedulerOption, Serializable, Object), that will be returned instead.\n<br><br>\nIf there is a explicit getter method, it is recommended to use these instead (e.g. #getLocale()).",
          "returnType": "<T> Optional<T>",
          "parameters": [
            {
              "type": "SchedulerOption",
              "name": "option"
            },
            {
              "type": "boolean",
              "name": "forceClientSideValue"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "lookupViewByClientSideValue",
          "description": "",
          "returnType": "<T extends CalendarView> Optional<T>",
          "parameters": [
            {
              "type": "String",
              "name": "clientSideValue"
            }
          ],
          "annotations": [
            "SuppressWarnings",
            "Override"
          ],
          "isPublic": true,
          "isStatic": false
        }
      ],
      "fields": [
        {
          "name": "FC_SCHEDULER_CLIENT_VERSION",
          "type": "String",
          "description": "",
          "annotations": [],
          "isPublic": true,
          "isStatic": true,
          "isFinal": true
        }
      ],
      "constructors": [
        {
          "description": "Creates a new instance without any settings beside the default locale (CalendarLocale#getDefaultLocale()).",
          "parameters": [],
          "annotations": [],
          "isPublic": true
        },
        {
          "description": "Creates a new instance.\n<br><br>\nExpects the default limit of entries shown per day. This does not affect basic or\nlist views. This value has to be set here and cannot be modified afterwards due to\ntechnical reasons of FC. If set afterwards the entry limit would overwrite settings\nand would show the limit also for basic views where it makes no sense (might change in future).\nPassing a negative number or 0 disabled the entry limit (same as passing no number at all).\n<br><br>\nSets the locale to Ca",
          "parameters": [
            {
              "type": "int",
              "name": "entryLimit"
            }
          ],
          "annotations": [],
          "isPublic": true
        },
        {
          "description": "Creates a new instance with custom initial options. This allows a full override of the default\ninitial options, that the calendar would normally receive. Theoretically you can set all options,\nas long as they are not based on a client side variable (as for instance \"plugins\" or \"locales\").\nComplex objects are possible, too, for instance for view-specific settings.\n Please refer to the official FC documentation regarding potential options.\n<br><br>\nClient side event handlers, that are technically",
          "parameters": [
            {
              "type": "ObjectNode",
              "name": "initialOptions"
            }
          ],
          "annotations": [],
          "isPublic": true
        }
      ],
      "annotations": [
        "Tag",
        "CssImport",
        "JsModule",
        "NpmPackage",
        "NpmPackage",
        "NpmPackage",
        "NpmPackage",
        "NpmPackage"
      ],
      "isPublic": true,
      "source": "addon-scheduler"
    },
    {
      "name": "GroupEntriesBy",
      "packageName": "org.vaadin.stefan.fullcalendar",
      "fullName": "org.vaadin.stefan.fullcalendar.GroupEntriesBy",
      "description": "Enumeration of possible ways of how resource entries should be grouped.",
      "type": "enum",
      "methods": [],
      "fields": [],
      "constructors": [],
      "annotations": [],
      "isPublic": true,
      "source": "addon-scheduler"
    },
    {
      "name": "Resource",
      "packageName": "org.vaadin.stefan.fullcalendar",
      "fullName": "org.vaadin.stefan.fullcalendar.Resource",
      "description": "Represents a resource. ResourceEntries contain these resources (a resource itself does not know anything about\nthe assigned entries). A resource can have sub resources / child resources.",
      "type": "class",
      "methods": [
        {
          "name": "getChildren",
          "description": "Returns the resource's children as unmodifiable set. Empty, when not children are set.",
          "returnType": "Set<Resource>",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "addChild",
          "description": "Adds the given resource as children to this instance. If the given resource has been added to\nother resources before, it will be removed from there. Also the parent is replaced.\n<br><br>\nDoes not update the resource instances on the client side when this instance has been added to the calendar\nbefore. In that case you need to add the child resources manually via Scheduler#addResource(Resource).",
          "returnType": "void",
          "parameters": [
            {
              "type": "Resource",
              "name": "child"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "addChildren",
          "description": "Adds the given resources as children to this instance. If the given resources have been added to\nother resources before, they will be removed from there. Also the parent is replaced.\n<br><br>\nDoes not update the resource instances on the client side when this instance has been added to the calendar\nbefore. In that case you need to add the child resources manually via Scheduler#addResources(Iterable).",
          "returnType": "void",
          "parameters": [
            {
              "type": "Collection<Resource>",
              "name": "children"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "addChildren",
          "description": "Adds the given resources as children to this instance. If the given resources have been added to\nother resources before, they will be removed from there. Also the parent is replaced.\n<br><br>\nDoes not update the resource instances on the client side when this instance has been added to the calendar\nbefore. In that case you need to add the child resources manually via Scheduler#addResources(Resource...).",
          "returnType": "void",
          "parameters": [
            {
              "type": "Resource...",
              "name": "children"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "removeChild",
          "description": "Removes the given resource from this instance. Does not update the resource instance on the client side.\nFor that you need to call Scheduler#removeResource(Resource) manually for the given instance.\n<br><br>\nUnsets the parent, if it matches this instance.",
          "returnType": "void",
          "parameters": [
            {
              "type": "Resource",
              "name": "child"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "removeChildren",
          "description": "Removes the given resources from this instance. Does not update the resource instance on the client side.\nFor that you need to call Scheduler#removeResources(Resource...) manually for the given instance.\n<br><br>\nUnsets the parent, if it matches this instance.",
          "returnType": "void",
          "parameters": [
            {
              "type": "Resource...",
              "name": "children"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "removeChildren",
          "description": "Removes the given resources from this instance. Does not update the resource instance on the client side.\nFor that you need to call Scheduler#removeResources(Resource...) manually for the given instance.\n<br><br>\nUnsets the parent, if it matches this instance.",
          "returnType": "void",
          "parameters": [
            {
              "type": "Collection<Resource>",
              "name": "children"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "addExtendedProps",
          "description": "Add custom element to the extendedProp HashMap. This allow to set custom property to the resource.",
          "returnType": "void",
          "parameters": [
            {
              "type": "String",
              "name": "key"
            },
            {
              "type": "Object",
              "name": "value"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "removeExtendedProps",
          "description": "Remove the custom property based on the name.",
          "returnType": "void",
          "parameters": [
            {
              "type": "String",
              "name": "key"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "removeExtendedProps",
          "description": "remove specific custom property where the name and value match.",
          "returnType": "void",
          "parameters": [
            {
              "type": "String",
              "name": "key"
            },
            {
              "type": "Object",
              "name": "value"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "getParent",
          "description": "Returns the parent resource (or empty if top level).",
          "returnType": "Optional<Resource>",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "getBusinessHours",
          "description": "Returns the first item from businessHoursArray or null if array is empty",
          "returnType": "BusinessHours",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "toString",
          "description": "",
          "returnType": "String",
          "parameters": [],
          "annotations": [
            "Override"
          ],
          "isPublic": true,
          "isStatic": false
        }
      ],
      "fields": [],
      "constructors": [
        {
          "description": "New instance. ID will be generated.",
          "parameters": [],
          "annotations": [],
          "isPublic": true
        },
        {
          "description": "New instance. Awaits id and title. If no id is provided, one will be generated.",
          "parameters": [
            {
              "type": "String",
              "name": "id"
            },
            {
              "type": "String",
              "name": "title"
            },
            {
              "type": "String",
              "name": "color"
            }
          ],
          "annotations": [],
          "isPublic": true
        },
        {
          "description": "New instance. Awaits id and title. If no id is provided, one will be generated.\n<br><br>\nAdds the given resources as children using #addChildren(Collection) if a value != null is passed.",
          "parameters": [
            {
              "type": "String",
              "name": "id"
            },
            {
              "type": "String",
              "name": "title"
            },
            {
              "type": "String",
              "name": "color"
            },
            {
              "type": "Collection<Resource>",
              "name": "children"
            },
            {
              "type": "BusinessHours...",
              "name": "businessHours"
            }
          ],
          "annotations": [],
          "isPublic": true
        }
      ],
      "annotations": [
        "EqualsAndHashCode",
        "Getter"
      ],
      "isPublic": true,
      "source": "addon-scheduler"
    },
    {
      "name": "ResourceEntry",
      "packageName": "org.vaadin.stefan.fullcalendar",
      "fullName": "org.vaadin.stefan.fullcalendar.ResourceEntry",
      "description": "Represents an entry that can be connected with a resource. Needed for timeline views.",
      "type": "class",
      "extends": "Entry",
      "methods": [
        {
          "name": "setCalendar",
          "description": "Sets the calendar for this instance. The given calendar must be implementing Scheduler.",
          "returnType": "void",
          "parameters": [
            {
              "type": "FullCalendar",
              "name": "calendar"
            }
          ],
          "annotations": [
            "Override"
          ],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "getResource",
          "description": "Returns an assigned resource. Is empty if no resource has been assigned yet. This method is mainly intended\nto be used for entries where it is sure, that it only has one resource. For entries with multiple\nresources it might be, that on the next call, the resource change (currently this class uses\na LinkedHashSet, but that might change in future).",
          "returnType": "Optional<Resource>",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "getResourcesOrEmpty",
          "description": "Returns an unmodifiable set of resources or an empty one, if no resources have been defined yet.",
          "returnType": "Set<Resource>",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "getOrCreateResources",
          "description": "Returns the entry's assigned resources. Any changes to this set are reflected to the\nbackend and will be applied to the client on the next entry's update.\n<p></p>\nIn earlier versions this set might have been unmodifiable. This is not the case anymore.",
          "returnType": "Set<Resource>",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "getResources",
          "description": "Returns this instance's resources. Can be null.",
          "returnType": "Set<Resource>",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "getResourcesSize",
          "description": "Returns the amount of assigned resources.",
          "returnType": "int",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "hasResources",
          "description": "Returns, if the entry has any resources assigned.",
          "returnType": "boolean",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "assignResources",
          "description": "Assigns additional resources to this entry. Already assigned resources will be kept.",
          "returnType": "void",
          "parameters": [
            {
              "type": "Resource...",
              "name": "resources"
            }
          ],
          "annotations": [
            "Deprecated"
          ],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "assignResource",
          "description": "Assign an additional resource to this entry. Already assigned resources will be kept.",
          "returnType": "void",
          "parameters": [
            {
              "type": "Resource",
              "name": "resource"
            }
          ],
          "annotations": [
            "Deprecated"
          ],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "addResources",
          "description": "Assigns additional resources to this entry. Already assigned resources will be kept.",
          "returnType": "void",
          "parameters": [
            {
              "type": "Resource...",
              "name": "resources"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "addResources",
          "description": "Assign additional resources to this entry. Already assigned resources will be kept.",
          "returnType": "void",
          "parameters": [
            {
              "type": "Collection<Resource>",
              "name": "resources"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "removeResources",
          "description": "Unassigns the given resources from this entry.",
          "returnType": "void",
          "parameters": [
            {
              "type": "Resource...",
              "name": "resources"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "removeResources",
          "description": "Unassigns the given resources from this entry.",
          "returnType": "void",
          "parameters": [
            {
              "type": "Collection<Resource>",
              "name": "resources"
            }
          ],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "unassignAllResources",
          "description": "Unassigns all resources from this entry.",
          "returnType": "void",
          "parameters": [],
          "annotations": [
            "Deprecated"
          ],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "removeAllResources",
          "description": "Unassigns all resources from this entry.",
          "returnType": "void",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "toJson",
          "description": "",
          "returnType": "ObjectNode",
          "parameters": [],
          "annotations": [
            "Override"
          ],
          "isPublic": true,
          "isStatic": false
        }
      ],
      "fields": [],
      "constructors": [
        {
          "description": "Creates a new entry with the given id. Null will lead to a generated id.\n<br><br>\nPlease be aware, that the ID needs to be unique in the calendar instance. Otherwise it can lead to\nunpredictable results.",
          "parameters": [
            {
              "type": "String",
              "name": "id"
            }
          ],
          "annotations": [],
          "isPublic": true
        }
      ],
      "annotations": [
        "NoArgsConstructor",
        "Setter",
        "Getter"
      ],
      "isPublic": true,
      "source": "addon-scheduler"
    },
    {
      "name": "Scheduler",
      "packageName": "org.vaadin.stefan.fullcalendar",
      "fullName": "org.vaadin.stefan.fullcalendar.Scheduler",
      "description": "Represents functionality for the FullCalendarScheduler.",
      "type": "interface",
      "methods": [],
      "fields": [
        {
          "name": "DEVELOPER_LICENSE_KEY",
          "type": "String",
          "description": "",
          "annotations": [],
          "isPublic": true,
          "isStatic": true,
          "isFinal": true
        },
        {
          "name": "NON_COMMERCIAL_CREATIVE_COMMONS_LICENSE_KEY",
          "type": "String",
          "description": "",
          "annotations": [],
          "isPublic": true,
          "isStatic": true,
          "isFinal": true
        },
        {
          "name": "GPL_V3_LICENSE_KEY",
          "type": "String",
          "description": "",
          "annotations": [],
          "isPublic": true,
          "isStatic": true,
          "isFinal": true
        }
      ],
      "constructors": [],
      "annotations": [],
      "isPublic": true,
      "source": "addon-scheduler"
    },
    {
      "name": "SchedulerView",
      "packageName": "org.vaadin.stefan.fullcalendar",
      "fullName": "org.vaadin.stefan.fullcalendar.SchedulerView",
      "description": "Enumeration of possible scheduler views.",
      "type": "enum",
      "implements": [
        "CalendarView"
      ],
      "methods": [],
      "fields": [],
      "constructors": [],
      "annotations": [],
      "isPublic": true,
      "source": "addon-scheduler"
    },
    {
      "name": "TimeslotClickedSchedulerEvent",
      "packageName": "org.vaadin.stefan.fullcalendar",
      "fullName": "org.vaadin.stefan.fullcalendar.TimeslotClickedSchedulerEvent",
      "description": "This type extends the normal timeslot clicked event by providing the selected resource (if there's one).\n<br><br>\nClient side event: dateClick",
      "type": "class",
      "extends": "TimeslotClickedEvent",
      "methods": [
        {
          "name": "getResource",
          "description": "If the select event has occured in the scheduler, the selected resource will be returned.",
          "returnType": "Optional<Resource>",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        }
      ],
      "fields": [],
      "constructors": [
        {
          "description": "New instance. Awaits the clicked date (time) as iso string (e.g. \"2018-10-23\" or \"2018-10-23T13:30\").",
          "parameters": [
            {
              "type": "FullCalendarScheduler",
              "name": "source"
            },
            {
              "type": "boolean",
              "name": "fromClient"
            }
          ],
          "annotations": [],
          "isPublic": true
        }
      ],
      "annotations": [
        "ToString",
        "DomEvent"
      ],
      "isPublic": true,
      "source": "addon-scheduler"
    },
    {
      "name": "TimeslotsSelectedSchedulerEvent",
      "packageName": "org.vaadin.stefan.fullcalendar",
      "fullName": "org.vaadin.stefan.fullcalendar.TimeslotsSelectedSchedulerEvent",
      "description": "This type extends the normal timeslot selected event by providing the selected resource (if there's one).\n<br><br>\nClient side event: select",
      "type": "class",
      "extends": "TimeslotsSelectedEvent",
      "methods": [
        {
          "name": "getResource",
          "description": "If the select event has occured in the scheduler, the selected resource will be returned.",
          "returnType": "Optional<Resource>",
          "parameters": [],
          "annotations": [],
          "isPublic": true,
          "isStatic": false
        }
      ],
      "fields": [],
      "constructors": [
        {
          "description": "New instance. Awaits the selected dates (time) as iso string (e.g. \"2018-10-23\" or \"2018-10-23T13:30\").",
          "parameters": [
            {
              "type": "FullCalendarScheduler",
              "name": "source"
            },
            {
              "type": "boolean",
              "name": "fromClient"
            }
          ],
          "annotations": [],
          "isPublic": true
        }
      ],
      "annotations": [
        "ToString",
        "DomEvent"
      ],
      "isPublic": true,
      "source": "addon-scheduler"
    },
    {
      "name": "ResourceConverter",
      "packageName": "org.vaadin.stefan.fullcalendar.converter",
      "fullName": "org.vaadin.stefan.fullcalendar.converter.ResourceConverter",
      "description": "@author Stefan Uebe",
      "type": "class",
      "implements": [
        "JsonItemPropertyConverter<Set<Resource>",
        "ResourceEntry>"
      ],
      "methods": [
        {
          "name": "supports",
          "description": "",
          "returnType": "boolean",
          "parameters": [
            {
              "type": "Object",
              "name": "type"
            }
          ],
          "annotations": [
            "Override"
          ],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "toClientModel",
          "description": "",
          "returnType": "JsonNode",
          "parameters": [
            {
              "type": "Set<Resource>",
              "name": "serverValue"
            },
            {
              "type": "ResourceEntry",
              "name": "currentInstance"
            }
          ],
          "annotations": [
            "Override"
          ],
          "isPublic": true,
          "isStatic": false
        },
        {
          "name": "toServerModel",
          "description": "",
          "returnType": "Set<Resource>",
          "parameters": [
            {
              "type": "JsonNode",
              "name": "clientValue"
            },
            {
              "type": "ResourceEntry",
              "name": "currentInstance"
            }
          ],
          "annotations": [
            "Override"
          ],
          "isPublic": true,
          "isStatic": false
        }
      ],
      "fields": [],
      "constructors": [],
      "annotations": [],
      "isPublic": true,
      "source": "addon-scheduler"
    }
  ],
  "examples": [
    {
      "id": "samples-0",
      "title": "Example 1",
      "description": "",
      "code": "// Create a new calendar instance and attach it to our layout\nFullCalendar calendar = FullCalendarBuilder.create().build();\ncalendar.setSizeFull();\ncontainer.add(calendar);\n\n// Create an initial sample entry\nEntry entry = new Entry();\nentry.setTitle(\"Some event\");\nentry.setColor(\"#ff3333\");\n\n// the given times will be interpreted as utc based - useful when the times are fetched from your database\nentry.setStart(LocalDate.now().withDayOfMonth(3).atTime(10, 0));\nentry.setEnd(entry.getStart().plusHours(2));\n\n// FC uses a data provider concept similar to the Vaadin default's one, with some differences\n// By default the FC uses a in-memory data provider, which is sufficient for most basic use cases.\ncalendar.getEntryProvider().asInMemory().addEntries(entry);",
      "language": "java",
      "category": "data-provider",
      "tags": [
        "entry",
        "provider",
        "inmemory",
        "event",
        "builder",
        "create"
      ]
    },
    {
      "id": "samples-1",
      "title": "Example 2",
      "description": "entry.setColor(\"#ff3333\"); // the given times will be interpreted as utc based - useful when the times are fetched from your database entry.setStart(LocalDate.now().withDayOfMonth(3).atTime(10, 0)); entry.setEnd(entry.getStart().plusHours(2)); // FC uses a data provider concept similar to the Vaadin",
      "code": "// ... create a form and binder to provide editable components to the user\nInMemoryEntryProvider<Entry> entryProvider = calendar.getEntryProvider().asInMemory();\n\nHorizontalLayout buttons = new HorizontalLayout();\nButton buttonSave;\nif (newInstance) {\n    buttonSave = new Button(\"Create\", e -> {\n        if (binder.validate().isOk()) {\n            // add the entry to the calendar instance and inform the client to update itself\n            entryProvider.addEntry(entry);\n            entryProvider.refreshAll();\n        }\n    });\n} else {\n    buttonSave = new Button(\"Save\", e -> {\n        if (binder.validate().isOk()) {\n            // update an existing entry in the client side\n            // this will only send changed data\n            entryProvider.refreshItem(entry);\n        }\n   });\n}\nbuttons.add(buttonSave);\n\nif (!newInstance) {\n    Button buttonRemove = new Button(\"Remove\", e -> {\n        entryProvider.removeEntry(entry);\n        entryProvider.refreshAll();\n    });\n    buttons.add(buttonRemove);\n}",
      "language": "java",
      "category": "data-provider",
      "tags": [
        "entry",
        "provider",
        "inmemory",
        "create",
        "update"
      ]
    },
    {
      "id": "samples-2",
      "title": "Example 3",
      "description": "buttons.add(buttonSave); if (!newInstance) {     Button buttonRemove = new Button(\"Remove\", e -> {         entryProvider.removeEntry(entry);         entryProvider.refreshAll();     });     buttons.add(buttonRemove); } ```",
      "code": "/*\n * The day click event listener is called when a user clicks in an empty space inside of the\n * calendar. Depending of if the clicked point was a day or time slot the event will provide the\n * time details of the clicked point. With this info you can show a dialog to create a new entry.\n */\ncalendar.addTimeslotsSelectedListener((event) -> {\n// react on the selected timeslot, for instance create a new instance and let the user edit it\n    Entry entry = new Entry();\n   \n    entry.setStart(event.getStart()); // also event times are always utc based\n    entry.setEnd(event.getEnd());\n    entry.setAllDay(event.isAllDay());\n\n    entry.setColor(\"dodgerblue\");\n\n    // ... show an editor or do something else with the entry\n});\n\n/*\n * The entry click event listener is called when the user clicks on an existing entry.\n * The event provides the clicked event which might be then opened in a dialog.\n */\ncalendar.addEntryClickedListener((event) -> {\n    // react on the clicked entry, for instance let the user edit it\n    Entry entry = event.getEntry();\n\n    // ... show an editor or do something else with the entry\n});",
      "language": "java",
      "category": "events",
      "tags": [
        "entry",
        "event",
        "listener",
        "click",
        "create"
      ]
    },
    {
      "id": "samples-3",
      "title": "Calendar event handling",
      "description": "* The entry click event listener is called when the user clicks on an existing entry.  * The event provides the clicked event which might be then opened in a dialog.  */ calendar.addEntryClickedListener((event) -> {     // react on the clicked entry, for instance let the user edit it     Entry entry",
      "code": "// load items from backend\nList<Entry> entryList = backend.streamEntries().collect(Collectors.toList());\n\n// init lazy loading provider based on given collection - does NOT use the collection as backend as ListDataProvider does\nLazyInMemoryEntryProvider<Entry> entryProvider = EntryProvider.lazyInMemoryFromItems(entryList);\n\n// set entry provider\ncalendar.setEntryProvider(entryProvider);\n\n// CRUD operations\n// to add\nEntry entry = new Entry();          // ... plus some init\nentryProvider.addEntries(entry);    // register in data provider\nentryProvider.refreshAll();         // call refresh to inform the client about the data change and trigger a refetch\n\n// after some change\nentryProvider.refreshItem(entry);   // call refresh to inform the client about the data change and trigger a refetch\n\n// to remove\nentryProvider.removeEntry(entry);\nentryProvider.refreshAll();         // call refresh to inform the client about the data change and trigger a refetch",
      "language": "java",
      "category": "data-provider",
      "tags": [
        "entry",
        "provider",
        "inmemory",
        "event",
        "crud"
      ]
    },
    {
      "id": "samples-4",
      "title": "In memory entry provider",
      "description": "entryProvider.addEntries(entry);    // register in data provider entryProvider.refreshAll();         // call refresh to inform the client about the data change and trigger a refetch // after some change entryProvider.refreshItem(entry);   // call refresh to inform the client about the data change an",
      "code": "// the callback provider uses the given callback to fetch entries when necessary\nCallbackEntryProvider<Entry> entryProvider = EntryProvider.fromCallbacks(\n        query -> backend.streamEntries(query),\n        entryId -> backend.getEntry(entryId).orElse(null)\n);\n\n// set entry provider\ncalendar.setEntryProvider(entryProvider);\n\n// CRUD operations\n// to add\nEntry entry = new Entry();          // ... plus some init\nbackend.addEntry(entry);            // register in your backend\nentryProvider.refreshAll();         // call refresh to inform the client about the data change and trigger a refetch\n\n// after some change\nbackend.updateEntry(entry);         // inform your backend\nentryProvider.refreshItem(entry);   // call refresh to inform the client about the data change and trigger a refetch\n\n// to remove\nbackend.removeEntry(entry);         // remove from your backend\nentryProvider.refreshAll();   // call refresh to inform the client about the",
      "language": "java",
      "category": "data-provider",
      "tags": [
        "entry",
        "provider",
        "callback",
        "crud",
        "update"
      ]
    },
    {
      "id": "samples-5",
      "title": "Using callbacks",
      "description": "entryProvider.refreshAll();         // call refresh to inform the client about the data change and trigger a refetch // after some change backend.updateEntry(entry);         // inform your backend entryProvider.refreshItem(entry);   // call refresh to inform the client about the data change and trig",
      "code": "private static class BackendEntryProvider extends AbstractEntryProvider<Entry> {\n    private final EntryService service;\n\n    public BackendEntryProvider(EntryService service) {\n        this.service = service;\n    }\n\n    @Override\n    public Stream<Entry> fetch(@NonNull EntryQuery query) {\n        return service.streamEntries(query);\n    }\n\n    @Override\n    public Optional<Entry> fetchById(@NonNull String id) {\n        return service.getEntry(id);\n    }\n}",
      "language": "java",
      "category": "data-provider",
      "tags": [
        "entry",
        "provider",
        "callback"
      ]
    },
    {
      "id": "samples-6",
      "title": "Custom implementation",
      "description": "public Stream<Entry> fetch(@NonNull EntryQuery query) {         return service.streamEntries(query);     }     @Override     public Optional<Entry> fetchById(@NonNull String id) {         return service.getEntry(id);     } } ```",
      "code": "calendar.setPrefetchEnabled(false); // disables the prefetch feature",
      "language": "java",
      "category": "general",
      "tags": []
    },
    {
      "id": "samples-7",
      "title": "Prefetch mode",
      "description": "The prefetch mode tries to obtain the necessary period based on the current view range unit. The supported units are \"day\", \"month\" and \"year\". If no range unit could be determined, a warning will show up. If the range unit is not supported, prefetch will not work (in this case the calendar behaves ",
      "code": "// FC allows to show entries in a specifc timezone. Setting a timezone only affects the client side\n// and might be interesting, when editing those entries in some kind of edit form\n\nTimezone tzBerlinGermany = new Timezone(ZoneId.of(\"Europe/Berlin\"));\ncalendar.setTimezone(tzBerlinGermany); // will rerender the client side and show all times 1-2 hours \"later\".\n\n// We can also reset the timezone to default.\ncalendar.setTimezone(Timezone.UTC);\n\n// We can also read the browsers timezone, after the component has been attached to the client side.\n// There are other ways to obtain the browser's timezone, so you are not obliged to use the listener.\ncalendar.addBrowserTimezoneObtainedListener(event -> calendar.setTimezone(event.getTimezone()));\n\n// If you want to let the calendar obtain the browser time zone automatically, you may simply use the builder.\n// In that case as soon as the client connected, it will set it's timezone in the server side instance.\nFullCalendarBuilder.create().withAutoBrowserTimezone().build();\n\n// Entries use internally utc to define times. The LocalDateTime and Instant methods setStart/End have the same effect.\nentry.setStart(Instant.now()); // UTC\nentry.setEnd(LocalDateTime.now()); // UTC\n\n// Entry provides some additional convenience methods to handle the current calendar's timezone's offset, e.g. to allow easy\n// integration into edit forms.\ncalendar.setTimezone(tzBerlinGermany); // times are now 1-2 hours \"ahead\" (depending on daylight saving)\nentry.setStart(LocalDate.of(2000, 1, 1).atStartOfDay());\n\nLocalDateTime utcStart = entry.getStart(); // will be 2000-01-01, 00:00\nLocalDateTime offsetStart = entry.getStartWithOffset(); // will be 2000-01-01, 01:00\n\n// ... modify the offset start, for instance in a date picker\n// e.g. modifiedOffsetStart = offsetStart.plusHours(5);\nLocalDateTime modifiedOffsetStart = offsetStart.plusHours(5);\n\nentry.setStartWithOffset(modifiedOffsetStart); // automatically takes care of conversion back to utc\nutcStart = entry.getStart(); // will be 2000-01-01, 04:00\noffsetStart = entry.getStartWithOffset(); // will be 2000-01-01, 05:00",
      "language": "java",
      "category": "events",
      "tags": [
        "entry",
        "timezone",
        "event",
        "listener",
        "builder",
        "create"
      ]
    },
    {
      "id": "samples-8",
      "title": "Using timezones",
      "description": "LocalDateTime offsetStart = entry.getStartWithOffset(); // will be 2000-01-01, 01:00 // ... modify the offset start, for instance in a date picker // e.g. modifiedOffsetStart = offsetStart.plusHours(5); LocalDateTime modifiedOffsetStart = offsetStart.plusHours(5); entry.setStartWithOffset(modifiedOf",
      "code": "import org.vaadin.stefan.fullcalendar.JsonFactory;\n\n// ...\n\nObjectNode initialOptions = JsonFactory.createObject();\ninitialOptions.put(\"height\", \"100%\");\ninitialOptions.put(\"timeZone\", \"UTC\");\ninitialOptions.put(\"header\", false);\ninitialOptions.put(\"weekNumbers\", true);\ninitialOptions.put(\"eventLimit\", false); // pass an int value to limit the entries per day\ninitialOptions.put(\"navLinks\", true); \ninitialOptions.put(\"selectable\", true);\n\ncalendar = FullCalendarBuilder.create().withScheduler().withInitialOptions(initialOptions).build();",
      "language": "java",
      "category": "timezone",
      "tags": [
        "scheduler",
        "timezone",
        "event",
        "builder",
        "create"
      ]
    },
    {
      "id": "samples-9",
      "title": "Passing custom initial options in Java",
      "description": "initialOptions.put(\"height\", \"100%\"); initialOptions.put(\"timeZone\", \"UTC\"); initialOptions.put(\"header\", false); initialOptions.put(\"weekNumbers\", true); initialOptions.put(\"eventLimit\", false); // pass an int value to limit the entries per day initialOptions.put(\"navLinks\", true);  initialOptions.",
      "code": "calendar.removeThemeVariant(FullCalendarVariant.VAADIN);",
      "language": "java",
      "category": "general",
      "tags": [
        "theme"
      ]
    },
    {
      "id": "samples-10",
      "title": "Vaadin Theming",
      "description": "Please note, that there might be parts, that have been forgotten or not looking as expected.  Also any additional custom stylings may override the Vaadin stylings. If you find anything, that looks suspicious, please create an issue.  To remove the Vaadin theme, simply remove the theme variant, as yo",
      "code": "## Show the current shown time interval (e. g. month) with Vaadin components\n\nYou can use the \"dates rendered event\" to show details about the current shown period in separate elements instead\nof the built-in FullCalendar header.",
      "language": "java",
      "category": "general",
      "tags": [
        "event"
      ]
    },
    {
      "id": "samples-11",
      "title": "Show the current shown time interval (e. g. month) with Vaadin components",
      "description": "padding-right: 6px; } ``` You can use the \"dates rendered event\" to show details about the current shown period in separate elements instead of the built-in FullCalendar header. ```",
      "code": "## Creating a background entry\nA background entry is an entry, that is rendered behind all other entries. It is not clickable and\nhas no tooltip. It is useful for marking a time range, e. g. for marking a vacation.",
      "language": "java",
      "category": "general",
      "tags": [
        "entry",
        "click"
      ]
    },
    {
      "id": "samples-12",
      "title": "Creating a background entry",
      "description": "intervalLabel.setText(formattedInterval);     }); } ``` A background entry is an entry, that is rendered behind all other entries. It is not clickable and has no tooltip. It is useful for marking a time range, e. g. for marking a vacation. ```",
      "code": "## Adding business hours\nYou can define business hours for each day of the week to provide visual feedback to the user, when someone is available\nor not. If you don't define any business hours, the calendar will assume, that the business hours are from 0:00 to 24:00 for each day.\n\nNon-business hours are grayed out in the calendar.",
      "language": "java",
      "category": "general",
      "tags": [
        "entry"
      ]
    },
    {
      "id": "samples-13",
      "title": "Adding business hours",
      "description": "calendar.addEntry(entry); ``` You can define business hours for each day of the week to provide visual feedback to the user, when someone is available or not. If you don't define any business hours, the calendar will assume, that the business hours are from 0:00 to 24:00 for each day. Non-business h",
      "code": "## Using the Scheduler\nThe scheduler is a commercial plugin of the FullCalendar library, that provides some additional features like\nresource related calendar entries and additional views.  \n\n### Activating the Scheduler",
      "language": "java",
      "category": "scheduler",
      "tags": [
        "resource",
        "scheduler",
        "view"
      ]
    },
    {
      "id": "samples-14",
      "title": "Activating the Scheduler",
      "description": "calendar.setBusinessHours(BusinessHours.allDays().start(9)); ``` The scheduler is a commercial plugin of the FullCalendar library, that provides some additional features like resource related calendar entries and additional views.   ```",
      "code": "### Adding a resource to a calendar and link it with entries",
      "language": "java",
      "category": "scheduler",
      "tags": [
        "resource",
        "scheduler"
      ]
    },
    {
      "id": "samples-15",
      "title": "Adding a resource to a calendar and link it with entries",
      "description": "```java FullCalendar calendar = FullCalendarBuilder.create().withScheduler().build(); // scheduler options ((Scheduler) calendar).setSchedulerLicenseKey(\"YourFullCalendarSchedulerKey\"); ``` ```",
      "code": "### Handling change of an entry's assigned resource by drag and drop",
      "language": "java",
      "category": "scheduler",
      "tags": [
        "entry",
        "resource",
        "drop"
      ]
    },
    {
      "id": "samples-16",
      "title": "Handling change of an entry's assigned resource by drag and drop",
      "description": "// When we want to link an entry with a resource, we need to use ResourceEntry // (a subclass of Entry) ResourceEntry entry = new ResourceEntry(null, title, start.atStartOfDay(), start.plusDays(days).atStartOfDay(), true, true, color, \"Some description...\"); entry.setResource(resource); calendar.add",
      "code": "### Switching to a timeline view",
      "language": "java",
      "category": "scheduler",
      "tags": [
        "entry",
        "resource",
        "drop",
        "view"
      ]
    },
    {
      "id": "samples-17",
      "title": "Switching to a timeline view",
      "description": "Set<Resource> resources = ((ResourceEntry) entry).getResources();         if(!resources.isEmpty()) {             // do something with the resource info         }     } }); ``` ```",
      "code": "### Activate vertical resource view",
      "language": "java",
      "category": "scheduler",
      "tags": [
        "resource",
        "view"
      ]
    },
    {
      "id": "samples-18",
      "title": "Activate vertical resource view",
      "description": "}); ``` ```java calendar.changeView(SchedulerView.TIMELINE_DAY); ``` ```",
      "code": "### Creating a resource based background entry",
      "language": "java",
      "category": "scheduler",
      "tags": [
        "entry",
        "resource",
        "view"
      ]
    },
    {
      "id": "samples-19",
      "title": "Creating a resource based background entry",
      "description": "calendar.changeView(SchedulerView.TIMELINE_DAY); ``` ```java calendar.setGroupEntriesBy(GroupEntriesBy.RESOURCE_DATE); ``` ```",
      "code": "### Creating hierarchical resources",
      "language": "java",
      "category": "scheduler",
      "tags": [
        "entry",
        "resource"
      ]
    },
    {
      "id": "samples-20",
      "title": "Creating hierarchical resources",
      "description": "```java ResourceEntry entry = new ResourceEntry(); // ... setup entry details, including addResource() entry.setDisplayMode(DisplayMode.BACKGROUND); calendar.addEntry(entry); ``` ```",
      "code": "### Making a resource entry draggable between resources",
      "language": "java",
      "category": "scheduler",
      "tags": [
        "entry",
        "resource"
      ]
    },
    {
      "id": "samples-21",
      "title": "Making a resource entry draggable between resources",
      "description": "parent.addChild(child); calendar.addResource(child); // this will update the client side // or remove them from already registered ones calendar.removeResource(child);  parent.removeChild(child);  ``` ```",
      "code": "## Using tippy.js for description tooltips\nBy default the calendar does not provide tooltips for entries. However, you can easily integrate any type of\ntooltip mechanism or library, for instance by simply applying an html title or using a matured tooltip library\nlike tippy.js.\n\nThis sample shows how to easy integrate tippy.js into a custom subclass of FullCalendar to show an entry's description\nas a tooltip when hovering the entry inside the FC. Please customize the example as needed.\n\n1. Create a new TypeScript file inside the frontend folder of your project. It needs to extend either FullCalendar or\n   FullCalendarScheduler. This example utilized FullCalendarScheduler. If you want to use the normal FC, simply remove\n   all the -Scheduler parts. You may also have a simply JavaScript file, in that case you need to change the\n   following script a bit.\n\nfull-calendar-with-tooltips.ts",
      "language": "java",
      "category": "scheduler",
      "tags": [
        "entry",
        "resource",
        "scheduler",
        "create"
      ]
    },
    {
      "id": "samples-22",
      "title": "Using tippy.js for description tooltips",
      "description": "as a tooltip when hovering the entry inside the FC. Please customize the example as needed. 1. Create a new TypeScript file inside the frontend folder of your project. It needs to extend either FullCalendar or    FullCalendarScheduler. This example utilized FullCalendarScheduler. If you want to use ",
      "code": "2. Now create a simple JavaClass, that utilizes your js file. This Java class also imports the needed CSS files.",
      "language": "java",
      "category": "general",
      "tags": [
        "create"
      ]
    },
    {
      "id": "samples-23",
      "title": "Using tippy.js for description tooltips",
      "description": "} } customElements.define(\"full-calendar-with-tooltip\", FullCalendarWithTooltip); ``` 2. Now create a simple JavaClass, that utilizes your js file. This Java class also imports the needed CSS files. ```",
      "code": "As shown in the subclass sample, you may also use the FullCalendarBuilder to create your custom class.\n\n## Customize the entry content\n\nFC allows you to modify the content of an entry. The given string will be interpreted as js function on client side\nand attached as `eventContent` callback. See https://fullcalendar.io/docs/content-injection (\"...a function\") for\ndetails.",
      "language": "java",
      "category": "general",
      "tags": [
        "entry",
        "callback",
        "event",
        "builder",
        "create"
      ]
    },
    {
      "id": "samples-24",
      "title": "Customize the entry content",
      "description": "As shown in the subclass sample, you may also use the FullCalendarBuilder to create your custom class. FC allows you to modify the content of an entry. The given string will be interpreted as js function on client side and attached as `eventContent` callback. See https://fullcalendar.io/docs/content",
      "code": "Inside the javascript callback you may access the entry's default properties or custom ones, that\nyou can set beforehand, using the custom property api (e. g.`setCustomProperty(String, Object)`).\nIn the callback you can access the custom property in a similar way, using `getCustomProperty(key)`\nor `getCustomProperty(key, defaultValue)`.\n\nPlease be aware, that the entry content callback has to be set before the client side is attached. Setting it afterwards\nhas no effect.\n\nAlso make sure, that your callback function does not contain any harmful code or allow cross side scripting.",
      "language": "java",
      "category": "general",
      "tags": [
        "entry",
        "callback"
      ]
    },
    {
      "id": "samples-25",
      "title": "Customize the entry content",
      "description": "you can set beforehand, using the custom property api (e. g.`setCustomProperty(String, Object)`). In the callback you can access the custom property in a similar way, using `getCustomProperty(key)` or `getCustomProperty(key, defaultValue)`. Please be aware, that the entry content callback has to be ",
      "code": "## Use native javascript events for entries\nSometimes the available events are not enough. For that purpose, we added native event listeners for calendar entries. \nThese allow you to setup JavaScript events for each entry, e.g. a mouse over event handler. Inside these event handlers \nyou may also access the created entry dom element.\n\nCustom native event handlers are added to the FullCalender object. They will then be applied to each created\nentry object (using the entryDidMount callback).\n\nTo add an event handler, simply call the method `addEntryNativeEventListener` on the calendar. The first parameter\nis the JavaScript event name (e.g. \"mouseover\"), the second parameter is the callback, that shall be used for\nthat event. Please be aware, that we do NOT check or sanitize the given JavaScript. It is up to you to prevent\nmalicious code from being sent to your users.\n\nInside the event callback, you may access the entryDidMount argument object, that contains additional information\nabout the current entry. See the official docs (https://fullcalendar.io/docs/event-render-hooks)\nfor more details about which details it provide.",
      "language": "java",
      "category": "events",
      "tags": [
        "entry",
        "callback",
        "event",
        "listener",
        "create"
      ]
    },
    {
      "id": "samples-26",
      "title": "Use native javascript events for entries",
      "description": "To add an event handler, simply call the method `addEntryNativeEventListener` on the calendar. The first parameter is the JavaScript event name (e.g. \"mouseover\"), the second parameter is the callback, that shall be used for that event. Please be aware, that we do NOT check or sanitize the given Jav",
      "code": "Please be aware, that due to the design of the used library, these event handlers have to be setup before the\ncalendar is initialized on the client side.\n\nThis sample will change the element style, when the mouse moves over it and changes back, when leaving the element.",
      "language": "java",
      "category": "events",
      "tags": [
        "event",
        "style"
      ]
    },
    {
      "id": "samples-27",
      "title": "Use native javascript events for entries",
      "description": "add(calendar); ``` Please be aware, that due to the design of the used library, these event handlers have to be setup before the calendar is initialized on the client side. This sample will change the element style, when the mouse moves over it and changes back, when leaving the element. ```",
      "code": "You can also access the client side dom to utilize other elements, like the parents. With this you may for instance\ncall a server side method.\n\nThe following sample shows, how a client callable method in the current view, containing the FullCalendar object, can\nbe called, when right clicking the entry. With this info you can for instance open a custom popup as a context menu.",
      "language": "java",
      "category": "events",
      "tags": [
        "entry",
        "event",
        "click",
        "view"
      ]
    },
    {
      "id": "samples-28",
      "title": "Use native javascript events for entries",
      "description": "calendar.addEntryNativeEventListener(\"mouseout\", \"e => info.el.style.opacity = ''\"); ``` You can also access the client side dom to utilize other elements, like the parents. With this you may for instance call a server side method. The following sample shows, how a client callable method in the curr",
      "code": "You can combine the event handlers with a custom entryDidMount callback, if you want additional customizations\nof the entries. The FC will take care of combining the event handlers and you EDM callback",
      "language": "java",
      "category": "events",
      "tags": [
        "entry",
        "callback",
        "event"
      ]
    },
    {
      "id": "samples-29",
      "title": "Use native javascript events for entries",
      "description": "System.out.println(e);         System.out.println(pointerX);         System.out.println(pointerY);     } }  ``` You can combine the event handlers with a custom entryDidMount callback, if you want additional customizations of the entries. The FC will take care of combining the event handlers and you",
      "code": "The following sample shows how to utilize the entryDidMount callback, the native event handlers and the\n[Popup addon](https://vaadin.com/directory/component/popup) to show a context menu. In this sample, the context\nmenu is based on a ListBox.",
      "language": "java",
      "category": "events",
      "tags": [
        "entry",
        "callback",
        "event"
      ]
    },
    {
      "id": "samples-30",
      "title": "Use native javascript events for entries",
      "description": "calendar.addEntryNativeEventListener(\"mouseover\", \"e => info.el.style.opacity = '0.5'\"); calendar.addEntryNativeEventListener(\"mouseout\", \"e => info.el.style.opacity = ''\"); ``` The following sample shows how to utilize the entryDidMount callback, the native event handlers and the [Popup addon](http",
      "code": "## Creating a subclass of FullCalendar for custom mods\nThe FullCalendar itself is just a simple Vaadin component on the server and client side, that can be extended\nand customized beyond the default behavior - be aware, that anything you do here is on your own risk and that\nsupport for this use case is limited. \n\nThe client side has the following methods, that you can override / extend to customize the behavior. There are\nothers, but they should normally not be overridden - except for you know what you do ;) \n\n* connectedCallback() - called when the component is attached to the dom\n* initCalendar() - called when the calendar is initialized - only called once\n* createInitOptions(initialOptions) - called when the calendar is initialized. You can modify the initial options here.\n* createEventHandlers() - called when the calendar is initialized. You can modify the event handlers here.\n\nBe aware, that during `connectedCallback()` and before calling `initCalendar()` no internal calendar\nobject is available. Calling `this.calendar` will automatically infer `initCalendar()` and thus can lead\nto unwanted side effects. Therefore, if you want to set options, add entries or do other things with the\ncalendar object, do it after `super.initCalendar()` has been called.\n\nIf you want to modifiy options, that are passed into the calendar object, you can extend the method\n`createInitOptions(initialOptions)` and return a modified options object.\n\nIf you want to modify or extend the event handlers, you can override the method `createEventHandlers()`-\n\nWe recommend to use the `override` modifier on overridden methods to make sure, that the method is\nalways up-to-date.\n\n1. Create a custom web component\n   Create a custom component, that extends FullCalendar or FullCalendarScheduler.",
      "language": "java",
      "category": "events",
      "tags": [
        "callback",
        "scheduler",
        "event",
        "create"
      ]
    },
    {
      "id": "samples-31",
      "title": "Creating a subclass of FullCalendar for custom mods",
      "description": "If you want to modify or extend the event handlers, you can override the method `createEventHandlers()`- We recommend to use the `override` modifier on overridden methods to make sure, that the method is always up-to-date. 1. Create a custom web component    Create a custom component, that extends F",
      "code": "2. Create a subclass of FullCalendar",
      "language": "java",
      "category": "general",
      "tags": [
        "create"
      ]
    },
    {
      "id": "samples-32",
      "title": "Creating a subclass of FullCalendar for custom mods",
      "description": "return super.createEventHandlers();     } } customElements.define(\"my-full-calendar\", MyFullCalendar); ``` 2. Create a subclass of FullCalendar ```",
      "code": "3. Use this class in your code",
      "language": "java",
      "category": "general",
      "tags": []
    },
    {
      "id": "samples-33",
      "title": "Creating a subclass of FullCalendar for custom mods",
      "description": "public class MyFullCalendar extends FullCalendar {     public MyFullCalendar() {     } } ``` 3. Use this class in your code ```",
      "code": "You can even use the FullCalendarBuilder to create your custom class. Be aware, that your\ncustom class needs to provide all constructors, that the extended FullCalendar has.",
      "language": "java",
      "category": "general",
      "tags": [
        "builder",
        "create"
      ]
    },
    {
      "id": "samples-34",
      "title": "Creating a subclass of FullCalendar for custom mods",
      "description": "3. Use this class in your code ```java calendar = new MyFullCalendar(); ``` You can even use the FullCalendarBuilder to create your custom class. Be aware, that your custom class needs to provide all constructors, that the extended FullCalendar has. ```",
      "code": "// directly apply the changes\ncalendar.addEntryDroppedListener(event -> {\n    event.applyChangesOnEntry(); // includes now the allDay attribute if sent by client\n});\n\n// create a copy to do some business logic checks\ncalendar.addEntryDroppedListener(event -> {\n    Entry copy = event.createCopyBasedOnChanges();\n\n    if(copy.getStartAsLocalDate().isBefore(someRequiredMinimalDate) /* do some background checks on the changed data */) {\n        event.applyChangesOnEntry();\n        event.getSource().getEntryProvider().refreshItem(event.getEntry()); // refresh the entry to update the UI\n    }\n});",
      "language": "java",
      "category": "data-provider",
      "tags": [
        "entry",
        "provider",
        "event",
        "listener",
        "drop",
        "create",
        "update"
      ]
    },
    {
      "id": "samples-35",
      "title": "Handling data changes in events",
      "description": "// create a copy to do some business logic checks calendar.addEntryDroppedListener(event -> {     Entry copy = event.createCopyBasedOnChanges();     if(copy.getStartAsLocalDate().isBefore(someRequiredMinimalDate) /* do some background checks on the changed data */) {         event.applyChangesOnEntr",
      "code": "Entry tmpEntry = entry.copy(); // create a temporary copy\n// you may also call copyAsType to allow the copy to be of a different type\n\nBinder<Entry> binder = new Binder<>();\n\n// ... init binder\n\nbinder.setBean(tmpEntry); // you can of course also use the read/writeBean api\n\n// modify the bound fields\n\nif (binder.validate().isOk()) {\n    entry.copyFrom(tmpEntry); // this will overwrite the entry with the values of the tmpEntry\n    // ... update the backend as needed, e.g. by calling refreshItem on the entry provider\n}",
      "language": "java",
      "category": "events",
      "tags": [
        "entry",
        "provider",
        "event",
        "create",
        "update"
      ]
    },
    {
      "id": "samples-36",
      "title": "Create a temporary copy",
      "description": "binder.setBean(tmpEntry); // you can of course also use the read/writeBean api // modify the bound fields if (binder.validate().isOk()) {     entry.copyFrom(tmpEntry); // this will overwrite the entry with the values of the tmpEntry     // ... update the backend as needed, e.g. by calling refreshIte",
      "code": "Entry tmpEntry = entry.copy(); // create a temporary copy\n\n// ... modify the temporary copy\n\n// return a new copy at the end without changing the initial entry\nreturn tmpEntry.copy();",
      "language": "java",
      "category": "general",
      "tags": [
        "entry",
        "create"
      ]
    },
    {
      "id": "demo-democalendarwithbackgroundevent",
      "title": "Demo Calendar With Background Event",
      "description": "Demo: DemoCalendarWithBackgroundEvent",
      "code": "package org.vaadin.stefan.ui.view.demos.backgroundevent;\n\nimport com.vaadin.flow.component.orderedlayout.VerticalLayout;\nimport com.vaadin.flow.router.Route;\n\nimport org.vaadin.stefan.fullcalendar.*;\nimport org.vaadin.stefan.fullcalendar.DisplayMode;\nimport org.vaadin.stefan.ui.layouts.MainLayout;\nimport org.vaadin.stefan.ui.menu.MenuItem;\n\nimport java.time.LocalDate;\nimport java.time.temporal.ChronoUnit;\nimport java.util.Locale;\n\n@Route(value = \"demobackgroundevent\", layout = MainLayout.class)\n@MenuItem(label = \"Background Events\")\npublic class DemoCalendarWithBackgroundEvent extends VerticalLayout {\n    private static final long serialVersionUID = 1L;\n    \n    private FullCalendar calendar;\n\n    public DemoCalendarWithBackgroundEvent() {\n    \tinitView();\n\n        createCalendarInstance();\n        addBackgroundEvent(DisplayMode.BACKGROUND, 4, \"This special holiday\");\n        addBackgroundEvent(DisplayMode.BACKGROUND, 6, \"\");\n\n        add(calendar);\n        setFlexGrow(1, calendar);\n    }\n    \n    private void initView() {\n    \tsetSizeFull();\n        setDefaultHorizontalComponentAlignment(Alignment.STRETCH);\n    }\n\n\n    private void createCalendarInstance() {\n        calendar = FullCalendarBuilder.create().withScheduler().build();\n        ((FullCalendarScheduler) calendar).setSchedulerLicenseKey(Scheduler.GPL_V3_LICENSE_KEY);\n        ((FullCalendarScheduler) calendar).setSlotMinWidth(\"150\");\n        calendar.setLocale(Locale.ENGLISH);\n\n        calendar.changeView(SchedulerView.TIMELINE_MONTH);\n    }\n\n    private void addBackgroundEvent(DisplayMode displayMode, int offset, String title) {\n        LocalDate now = LocalDate.now();\n        \n        ResourceEntry entry = new ResourceEntry();\n        \n        entry.setTitle(title);\n        entry.setStart(now.withDayOfMonth(offset));\n        entry.setEnd(entry.getStart().plus(1, ChronoUnit.DAYS));\n        entry.setAllDay(true);\n        entry.setColor(\"red\");\n        entry.setDisplayMode(displayMode);\n        entry.setResourceEditable(true);\n        \n        calendar.getEntryProvider().asInMemory().addEntry(entry);\n    }\n}",
      "language": "java",
      "category": "data-provider",
      "tags": [
        "entry",
        "provider",
        "inmemory",
        "resource",
        "scheduler",
        "event",
        "view",
        "builder",
        "create"
      ]
    },
    {
      "id": "demo-basicdemo",
      "title": "Basic Demo",
      "description": "Demo: BasicDemo",
      "code": "package org.vaadin.stefan.ui.view.demos.basic;\n\nimport com.vaadin.flow.router.Route;\nimport org.vaadin.stefan.ui.dialogs.DemoDialog;\nimport org.vaadin.stefan.ui.view.AbstractCalendarView;\nimport org.vaadin.stefan.fullcalendar.*;\nimport org.vaadin.stefan.ui.layouts.MainLayout;\nimport org.vaadin.stefan.ui.menu.MenuItem;\nimport org.vaadin.stefan.ui.view.demos.entryproviders.EntryService;\nimport tools.jackson.databind.node.ObjectNode;\n\nimport java.util.Collections;\n\n@Route(value = \"basic-demo\", layout = MainLayout.class)\n@MenuItem(label = \"Basic Demo\")\npublic class BasicDemo extends AbstractCalendarView {\n\n    @Override\n    protected FullCalendar createCalendar(ObjectNode defaultInitialOptions) {\n        EntryService<Entry> simpleInstance = EntryService.createSimpleInstance();\n\n        return FullCalendarBuilder.create()\n                .withInitialOptions(defaultInitialOptions)\n                .withInitialEntries(simpleInstance.getEntries())\n                .withEntryLimit(3)\n                .build();\n    }\n\n    @Override\n    protected String createDescription() {\n        return \"A simple demo, showing the basic interaction events with the calendar and allow basic modification of entries.\";\n    }\n\n    @Override\n    protected void onEntryClick(EntryClickedEvent event) {\n        System.out.println(event.getClass().getSimpleName() + \": \" + event);\n\n        if (event.getEntry().getDisplayMode() != DisplayMode.BACKGROUND && event.getEntry().getDisplayMode() != DisplayMode.INVERSE_BACKGROUND) {\n            DemoDialog dialog = new DemoDialog(event.getEntry(), false);\n            dialog.setSaveConsumer(this::onEntryChanged);\n            dialog.setDeleteConsumer(e -> onEntriesRemoved(Collections.singletonList(e)));\n            dialog.open();\n        }\n    }\n\n    @Override\n    protected void onTimeslotsSelected(TimeslotsSelectedEvent event) {\n        super.onTimeslotsSelected(event);\n\n        ResourceEntry entry = new ResourceEntry();\n\n        entry.setStart(event.getStart());\n        entry.setEnd(event.getEnd());\n        entry.setAllDay(event.isAllDay());\n        entry.setCalendar(event.getSource());\n\n        DemoDialog dialog = new DemoDialog(entry, true);\n        dialog.setSaveConsumer(e -> onEntriesCreated(Collections.singletonList(e)));\n        dialog.setDeleteConsumer(e -> onEntriesRemoved(Collections.singletonList(e)));\n        dialog.open();\n    }\n}\n",
      "language": "java",
      "category": "data-provider",
      "tags": [
        "entry",
        "provider",
        "resource",
        "event",
        "click",
        "view",
        "builder",
        "create",
        "delete"
      ]
    },
    {
      "id": "demo-democustomproperties",
      "title": "Demo Custom Properties",
      "description": "Demo: DemoCustomProperties",
      "code": "package org.vaadin.stefan.ui.view.demos.customproperties;\n\nimport java.time.LocalDate;\nimport java.time.LocalTime;\nimport java.util.UUID;\n\nimport org.vaadin.stefan.fullcalendar.CalendarViewImpl;\nimport org.vaadin.stefan.fullcalendar.Entry;\nimport org.vaadin.stefan.fullcalendar.FullCalendar;\nimport org.vaadin.stefan.fullcalendar.FullCalendarBuilder;\nimport org.vaadin.stefan.ui.layouts.MainLayout;\nimport org.vaadin.stefan.ui.menu.MenuItem;\n\nimport com.vaadin.flow.component.orderedlayout.VerticalLayout;\nimport com.vaadin.flow.router.Route;\n\n@Route(value = \"demoextendedprops\", layout = MainLayout.class)\n@MenuItem(label = \"Custom Properties\")\npublic class DemoCustomProperties extends VerticalLayout {\n\tprivate static final long serialVersionUID = -117988331031719049L;\n\n\tprivate FullCalendar calendar;\n\t\n\tprivate Entry selected;\n\n    public DemoCustomProperties() {\n    \tcreateCalendarInstance();\n    \taddDemoEntrys();\n\n        setSizeFull();\n        add(calendar);\n        setDefaultHorizontalComponentAlignment(Alignment.STRETCH);\n        setFlexGrow(1, calendar);\n    }\n    \n    private void createCalendarInstance() {\n    \tcalendar = FullCalendarBuilder.create()\n                .build();\n    \t\n    \tcalendar.changeView(CalendarViewImpl.DAY_GRID_MONTH);\n\n        calendar.setEntryDidMountCallback(\"function (info) {\" +\n                \"info.el.style.backgroundColor = info.event.getCustomProperty('selected', false) ? 'lightblue' : 'lightgreen';\" +\n                \"}\");\n\n        calendar.addEntryClickedListener(e -> {\n            Entry oldSelected = this.selected;\n            if (oldSelected != null) {\n                oldSelected.setCustomProperty(\"selected\", false);\n            }\n\n            var entryProvider = calendar.getEntryProvider().asInMemory();\n\n            this.selected = e.getEntry();\n            this.selected.setCustomProperty(\"selected\", true);\n            if (oldSelected != null) {\n                entryProvider.removeEntries(oldSelected, this.selected);\n                entryProvider.addEntries(oldSelected, this.selected);\n\n            } else {\n                entryProvider.removeEntries(this.selected);\n                entryProvider.addEntries(this.selected);\n            }\n        });\n\n        calendar.setHeightByParent();\n    }\n    \n    private void addDemoEntrys() {\n    \tfor (int i = 1; i < 10; i++) {\n            LocalDate now = LocalDate.now();\n            LocalDate start = now.withDayOfMonth((int)(Math.random() * 28) + 1);\n            LocalDate end = start.plusDays(1);\n            Entry entry = new Entry(UUID.randomUUID().toString());\n            entry.setColor(\"lightgreen\");\n            entry.setTitle(\"Entry \" + i);\n            entry.setStart(start.atStartOfDay());\n            entry.setEnd(end.atTime(LocalTime.MAX));\n            if (i == 1) {\n                entry.setCustomProperty(\"selected\", true);\n                selected = entry;\n            }\n            calendar.getEntryProvider().asInMemory().addEntry(entry);\n        }\n    }\n    \n\n}\n",
      "language": "java",
      "category": "data-provider",
      "tags": [
        "entry",
        "provider",
        "callback",
        "inmemory",
        "event",
        "listener",
        "click",
        "style",
        "view",
        "builder",
        "create"
      ]
    },
    {
      "id": "demo-anonymouscustomviewdemo",
      "title": "Anonymous Custom View Demo",
      "description": "Demo: AnonymousCustomViewDemo",
      "code": "package org.vaadin.stefan.ui.view.demos.customtimeline;\n\nimport org.vaadin.stefan.fullcalendar.*;\nimport org.vaadin.stefan.ui.view.AbstractSchedulerView;\nimport org.vaadin.stefan.ui.view.demos.entryproviders.EntryService;\nimport tools.jackson.databind.node.ObjectNode;\n\nimport java.util.List;\n\n// not a registered route since it shall only provide some sample code for the \"old\" way of adding custom views\npublic class AnonymousCustomViewDemo extends AbstractSchedulerView {\n\n    private SomeCalendarView calendarView;\n\n    @Override\n    protected FullCalendar createCalendar(ObjectNode defaultInitialOptions) {\n        calendarView = new SomeCalendarView(28);\n        FullCalendar calendar = FullCalendarBuilder.create()\n                .withScheduler(Scheduler.GPL_V3_LICENSE_KEY)\n                .withAutoBrowserLocale()\n                .withInitialOptions(calendarView.getInitialOptions())\n                .build();\n\n        List<Entry> entries = EntryService.createRandomInstance().getEntries();\n        calendar.getEntryProvider().asInMemory().addEntries(entries);\n\n        return calendar;\n    }\n\n    @Override\n    protected void postConstruct(FullCalendar calendar) {\n        calendar.changeView(calendarView);\n    }\n\n    @Override\n    protected String createDescription() {\n        return \"This demo shows how the calendar handles the \\\"old\\\" way of adding custom views. \" +\n                \"The custom view is the same as in the Custom View Demo, but the view is created using the initial options.\";\n    }\n\n    @Override\n    protected String createTitle() {\n        return \"Anonymous Custom View Demo\";\n    }\n\n\n    private static class SomeCalendarView implements CalendarView {\n        private final int numberOfDays;\n\n        public SomeCalendarView(int numberOfDays) {\n            this.numberOfDays = numberOfDays;\n        }\n\n        @Override\n        public String getClientSideValue() {\n            return \"fixedDaysResourceTimelineAnonymous\";\n        }\n\n        public ObjectNode getInitialOptions() {\n            ObjectNode initialOptions = JsonFactory.createObject();\n\n            ObjectNode durationHolder = JsonFactory.createObject();\n            durationHolder.set(\"days\", JsonFactory.create(numberOfDays));\n\n            ObjectNode customViewHolder = JsonFactory.createObject();\n            customViewHolder.set(\"type\", JsonFactory.create(\"resourceTimeline\"));\n            customViewHolder.set(\"duration\", durationHolder);\n\n            ObjectNode viewsHolder = JsonFactory.createObject();\n            viewsHolder.set(getClientSideValue(), customViewHolder);\n\n            initialOptions.set(\"views\", viewsHolder);\n\n            return initialOptions;\n        }\n\n        @Override\n        public String getName() {\n            return \"Fixed Days Resource Timeline (anonymous)\";\n        }\n    }\n\n    @Override\n    protected boolean isToolbarViewChangeable() {\n        return false;\n    }\n}",
      "language": "java",
      "category": "data-provider",
      "tags": [
        "entry",
        "provider",
        "inmemory",
        "resource",
        "scheduler",
        "view",
        "builder",
        "create"
      ]
    },
    {
      "id": "demo-customviewdemo",
      "title": "Custom View Demo",
      "description": "Demo: CustomViewDemo",
      "code": "package org.vaadin.stefan.ui.view.demos.customtimeline;\n\nimport com.vaadin.flow.router.Route;\n\nimport org.vaadin.stefan.fullcalendar.*;\nimport org.vaadin.stefan.ui.layouts.MainLayout;\nimport org.vaadin.stefan.ui.menu.MenuItem;\nimport org.vaadin.stefan.ui.view.AbstractSchedulerView;\nimport org.vaadin.stefan.ui.view.demos.entryproviders.EntryService;\nimport tools.jackson.databind.node.ObjectNode;\n\nimport java.util.List;\n\n@Route(value = \"custom-view\", layout = MainLayout.class)\n@MenuItem(label = \"Custom View\")\npublic class CustomViewDemo extends AbstractSchedulerView {\n\n    private FixedDaysCalendarView calendarView;\n\n    @Override\n    protected FullCalendar createCalendar(ObjectNode defaultInitialOptions) {\n        calendarView = new FixedDaysCalendarView(28);\n\n        // test for duplicat registration (anonymous and named)\n//        ObjectNode initialOptions = Json.createObject();\n//        ObjectNode views = Json.createObject();\n//        views.put(calendarView.getClientSideValue(), new FixedDaysCalendarView(5).getViewSettings());\n//        initialOptions.put(\"views\", views);\n\n        FullCalendar calendar = FullCalendarBuilder.create()\n                .withScheduler(Scheduler.GPL_V3_LICENSE_KEY)\n//                .withInitialOptions(initialOptions)\n                .withCustomCalendarViews(calendarView)\n                .withAutoBrowserLocale()\n                .build();\n\n        List<Entry> entries = EntryService.createRandomInstance().getEntries();\n        calendar.getEntryProvider().asInMemory().addEntries(entries);\n\n        return calendar;\n    }\n\n    @Override\n    protected void postConstruct(FullCalendar calendar) {\n        calendar.changeView(calendarView);\n    }\n\n    @Override\n    protected String createDescription() {\n        return \"This demo shows how to create a custom view. The view is based on the timeline view, but only shows a\" +\n                \" fixed number of days. The view is configured to show 28 days.\";\n    }\n\n    @Override\n    protected String createTitle() {\n        return \"Custom View Demo\";\n    }\n\n    @Override\n    protected boolean isToolbarViewChangeable() {\n        return false;\n    }\n\n\n}",
      "language": "java",
      "category": "data-provider",
      "tags": [
        "entry",
        "provider",
        "inmemory",
        "scheduler",
        "view",
        "builder",
        "create"
      ]
    },
    {
      "id": "demo-abstractentryproviderdemo",
      "title": "Abstract Entry Provider Demo",
      "description": "Demo: AbstractEntryProviderDemo",
      "code": "package org.vaadin.stefan.ui.view.demos.entryproviders;\n\nimport com.vaadin.flow.component.notification.Notification;\nimport lombok.AccessLevel;\nimport lombok.Getter;\nimport org.vaadin.stefan.fullcalendar.*;\nimport org.vaadin.stefan.fullcalendar.dataprovider.EntryProvider;\nimport org.vaadin.stefan.ui.dialogs.DemoDialog;\nimport org.vaadin.stefan.ui.view.AbstractCalendarView;\nimport org.vaadin.stefan.ui.view.CalendarViewToolbar;\nimport tools.jackson.databind.node.ObjectNode;\n\nimport java.util.Collections;\n\n/**\n * An abstract demo class for the different entry provider variants. Does not provide much functionality\n * beside the loading and displayment of entries plus some simple click, dropped and resized listeners.\n * <p></p>\n * Also delegates CRUD operations of the toolbar and the calendar to the entry service and refreshes\n * the entry provider based on the modifications.\n * <p></p>\n * The entry service is always instantiated with random data.\n * @author Stefan Uebe\n */\n@Getter(AccessLevel.PROTECTED)\npublic abstract class AbstractEntryProviderDemo extends AbstractCalendarView {\n\n    private EntryService entryService;\n    private EntryProvider<Entry> entryProvider;\n\n    @Override\n    protected FullCalendar createCalendar(ObjectNode defaultInitialOptions) {\n        entryService = EntryService.createRandomInstance();\n        entryProvider = createEntryProvider(entryService);\n\n        return FullCalendarBuilder.create()\n                .withEntryProvider(entryProvider)\n                .withInitialOptions(defaultInitialOptions)\n                .withEntryLimit(3)\n                .build();\n    }\n\n    @Override\n    protected CalendarViewToolbar createToolbar(CalendarViewToolbar.CalendarViewToolbarBuilder toolbarBuilder) {\n        return super.createToolbar(toolbarBuilder.allowAddingRandomItemsInitially(false));\n    }\n\n    /**\n     * Creates the demo's specific entry provider and initializes it with the necessary data.\n     * @param entryService entry service\n     * @return entry provider\n     */\n    protected abstract EntryProvider<Entry> createEntryProvider(EntryService<Entry> entryService);\n\n    @Override\n    protected void onTimeslotsSelected(TimeslotsSelectedEvent event) {\n        Entry entry = createNewEntry();\n\n        entry.setStart(event.getStart());\n        entry.setEnd(event.getEnd());\n        entry.setAllDay(event.isAllDay());\n\n        entry.setColor(\"green\");\n        entry.setCalendar(event.getSource());\n        DemoDialog dialog = new DemoDialog(entry, true);\n        dialog.setSaveConsumer(e -> onEntriesCreated(Collections.singletonList(e)));\n        dialog.open();\n    }\n\n    protected abstract Entry createNewEntry();\n\n    @Override\n    protected void onEntryClick(EntryClickedEvent event) {\n        DemoDialog dialog = new DemoDialog(event.getEntry(), false);\n        dialog.setSaveConsumer(this::onEntryChanged);\n        dialog.setDeleteConsumer(e -> onEntriesRemoved(Collections.singletonList(e)));\n        dialog.open();\n    }\n\n    @Override\n    protected void onEntryDropped(EntryDroppedEvent event) {\n        super.onEntryDropped(event);\n        Notification.show(\"Dropped entry \" + event.getEntry().getId());\n    }\n\n    @Override\n    protected void onEntryResized(EntryResizedEvent event) {\n        super.onEntryResized(event);\n        Notification.show(\"Resized entry \" + event.getEntry().getId());\n    }\n}\n",
      "language": "java",
      "category": "data-provider",
      "tags": [
        "entry",
        "provider",
        "event",
        "listener",
        "click",
        "drop",
        "resize",
        "view",
        "builder",
        "crud",
        "create",
        "delete"
      ]
    },
    {
      "id": "demo-backendentryproviderdemo",
      "title": "Backend Entry Provider Demo",
      "description": "This demo shows an EntryProvider implementation, that fetches its data from\na simulated database. Items are created temporary based on the respective backend entities.\n@author Stefan Uebe",
      "code": "package org.vaadin.stefan.ui.view.demos.entryproviders;\n\nimport com.vaadin.flow.router.Route;\nimport lombok.NonNull;\nimport org.vaadin.stefan.fullcalendar.*;\nimport org.vaadin.stefan.fullcalendar.dataprovider.AbstractEntryProvider;\nimport org.vaadin.stefan.fullcalendar.dataprovider.EntryProvider;\nimport org.vaadin.stefan.fullcalendar.dataprovider.EntryQuery;\nimport org.vaadin.stefan.ui.layouts.MainLayout;\n\nimport java.util.Collection;\nimport java.util.Optional;\nimport java.util.stream.Stream;\n\n/**\n * This demo shows an EntryProvider implementation, that fetches its data from\n * a simulated database. Items are created temporary based on the respective backend entities.\n * @author Stefan Uebe\n */\n@Route(value = \"backend-entry-provider\", layout = MainLayout.class)\n@org.vaadin.stefan.ui.menu.MenuItem(label = \"Backend Entry Provider\")\npublic class BackendEntryProviderDemo extends AbstractEntryProviderDemo {\n\n    @Override\n    protected EntryProvider<Entry> createEntryProvider(EntryService<Entry> entryService) {\n        return new BackendEntryProvider(entryService);\n    }\n\n    @Override\n    protected Entry createNewEntry() {\n        return getEntryService().createNewInstance();\n    }\n\n    @Override\n    protected void onEntriesCreated(Collection<Entry> entries) {\n        getEntryService().addEntries(entries);\n        getEntryProvider().refreshAll();\n    }\n\n    protected void onEntryChanged(Entry entry) {\n        getEntryService().updateEntry(entry);\n        getEntryProvider().refreshItem(entry);\n    }\n\n    @Override\n    protected void onEntriesRemoved(Collection<Entry> entries) {\n        getEntryService().removeEntries(entries);\n        getEntryProvider().refreshAll();\n    }\n\n    @Override\n    protected String createDescription() {\n        return \"This demo shows an EntryProvider implementation, that fetches its data from \" +\n                \"a simulated database. Items are created temporary based on the respective backend entities.\";\n    }\n\n    private static class BackendEntryProvider extends AbstractEntryProvider<Entry> {\n\n        private final EntryService service;\n\n        public BackendEntryProvider(EntryService service) {\n            this.service = service;\n        }\n\n        @Override\n        public Stream<Entry> fetch(@NonNull EntryQuery query) {\n            return service.streamEntries(query);\n        }\n\n        @Override\n        public Optional<Entry> fetchById(@NonNull String id) {\n            return service.getEntry(id);\n        }\n    }\n\n}\n",
      "language": "java",
      "category": "data-provider",
      "tags": [
        "entry",
        "provider",
        "view",
        "create",
        "update"
      ]
    },
    {
      "id": "demo-callbackentryproviderdemo",
      "title": "Callback Entry Provider Demo",
      "description": "This sample shows the usage of the CallbackEntryProvider. This variant can be instantiated on the\nfly providing a single callback to stream entries for the requested timespan.\n@author Stefan Uebe",
      "code": "package org.vaadin.stefan.ui.view.demos.entryproviders;\n\nimport com.vaadin.flow.router.Route;\nimport org.vaadin.stefan.fullcalendar.*;\nimport org.vaadin.stefan.fullcalendar.dataprovider.CallbackEntryProvider;\nimport org.vaadin.stefan.fullcalendar.dataprovider.EntryProvider;\nimport org.vaadin.stefan.ui.layouts.MainLayout;\n\nimport java.util.Collection;\n\n/**\n * This sample shows the usage of the CallbackEntryProvider. This variant can be instantiated on the\n * fly providing a single callback to stream entries for the requested timespan.\n * @author Stefan Uebe\n */\n@Route(value = \"callback-entry-provider\", layout = MainLayout.class)\n@org.vaadin.stefan.ui.menu.MenuItem(label = \"Callback Entry Provider\")\npublic class CallbackEntryProviderDemo extends AbstractEntryProviderDemo {\n\n    @Override\n    protected EntryProvider<Entry> createEntryProvider(EntryService<Entry> entryService) {\n        // Variant A - the backend service takes care of filtering the entries before returning them\n        CallbackEntryProvider<Entry> entryProvider = EntryProvider.fromCallbacks(\n                query -> entryService.streamEntries(query),\n                entryId -> entryService.getEntry(entryId).orElse(null)\n        );\n        // Variant B - the backend service returns a plain stream an the callback takes care of filtering the returned entries (may be less performant)\n        // entryProvider = EntryProvider.fromCallbacks(query -> {\n        //     Stream<Entry> stream = entryService.streamEntries();\n        //     stream = query.applyFilter(stream); // a query built in method to filter entry streams based on the query\n        //     return stream;\n        // }, entryId -> entryService.getEntry(entryId).orElse(null));\n\n        return entryProvider;\n    }\n\n    @Override\n    protected Entry createNewEntry() {\n        return getEntryService().createNewInstance();\n    }\n\n    @Override\n    protected void onEntriesCreated(Collection<Entry> entries) {\n        getEntryService().addEntries(entries);\n        getEntryProvider().refreshAll();\n    }\n\n    @Override\n    protected void onEntryChanged(Entry entry) {\n        getEntryService().updateEntry(entry);\n        getEntryProvider().refreshItem(entry);\n    }\n\n    @Override\n    protected void onEntriesRemoved(Collection<Entry> entries) {\n        getEntryService().removeEntries(entries);\n        getEntryProvider().refreshAll();\n    }\n\n    @Override\n    protected String createDescription() {\n        return \"This sample shows the usage of the CallbackEntryProvider. This variant can be instantiated on the \" +\n                \"fly providing a single callback to stream entries for the requested timespan.\";\n    }\n}\n",
      "language": "java",
      "category": "data-provider",
      "tags": [
        "entry",
        "provider",
        "callback",
        "view",
        "create",
        "update"
      ]
    },
    {
      "id": "demo-inmemoryentryproviderdemo",
      "title": "In Memory Entry Provider Demo",
      "description": "This demo shows the usage of the InMemoryEntryProvider. It stores all its data on the server side\nwhile the client only receives the necessary data. This allows a mixture of easy in memory editing\nvia the CRUD API without a heavy memory impact on the client.\n@author Stefan Uebe",
      "code": "package org.vaadin.stefan.ui.view.demos.entryproviders;\n\nimport com.vaadin.flow.router.Route;\nimport org.vaadin.stefan.fullcalendar.Entry;\nimport org.vaadin.stefan.fullcalendar.dataprovider.EntryProvider;\nimport org.vaadin.stefan.fullcalendar.dataprovider.InMemoryEntryProvider;\nimport org.vaadin.stefan.ui.layouts.MainLayout;\n\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\n/**\n * This demo shows the usage of the InMemoryEntryProvider. It stores all its data on the server side\n * while the client only receives the necessary data. This allows a mixture of easy in memory editing\n * via the CRUD API without a heavy memory impact on the client.\n *\n * @author Stefan Uebe\n */\n@Route(value = \"in-memory-entry-provider\", layout = MainLayout.class)\n@org.vaadin.stefan.ui.menu.MenuItem(label = \"In Memory Entry Provider\")\npublic class InMemoryEntryProviderDemo extends AbstractEntryProviderDemo {\n\n\n    @Override\n    protected EntryProvider<Entry> createEntryProvider(EntryService<Entry> entryService) {\n        List<Entry> entries = entryService.streamEntries().collect(Collectors.toList());\n\n        // The list is used to initialize the in memory provider, but different to the ListDataProvider it is\n        // not used as the backing collection.\n        return EntryProvider.inMemoryFrom(entries);\n    }\n\n    @Override\n    protected Entry createNewEntry() {\n        return new Entry();\n    }\n\n    @Override\n    protected void onEntriesCreated(Collection<Entry> entries) {\n        // The lazy in memory provider provides API to modify its internal cache. To inform the client about\n        // the change a refresh call is necessary.\n        InMemoryEntryProvider<Entry> provider = getEntryProvider();\n        provider.addEntries(entries);\n        provider.refreshAll();\n    }\n\n    @Override\n    protected void onEntriesRemoved(Collection<Entry> entries) {\n        // The lazy in memory provider provides API to modify its internal cache. To inform the client about\n        // the change a refresh call is necessary.\n        InMemoryEntryProvider<Entry> provider = getEntryProvider();\n        provider.removeEntries(entries);\n        provider.refreshAll();\n    }\n\n    @Override\n    protected void onEntryChanged(Entry entry) {\n        // To inform the client about the change a refresh call is necessary.\n        getEntryProvider().refreshItem(entry);\n    }\n\n    @Override\n    protected InMemoryEntryProvider<Entry> getEntryProvider() {\n        return (InMemoryEntryProvider<Entry>) super.getEntryProvider();\n    }\n\n    @Override\n    protected String createDescription() {\n        return \"This demo shows the usage of the InMemoryEntryProvider. It stores all its data on the server side \" +\n                \"while the client only receives the necessary data. This allows a mixture of easy in memory editing \" +\n                \"via the CRUD API without a heavy memory impact on the client.\";\n    }\n}\n",
      "language": "java",
      "category": "data-provider",
      "tags": [
        "entry",
        "provider",
        "inmemory",
        "view",
        "crud",
        "create"
      ]
    },
    {
      "id": "demo-fulldemo",
      "title": "Full Demo",
      "description": "Demo: FullDemo",
      "code": "/*\n * Copyright 2020, Stefan Uebe\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\n * documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial portions\n * of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE\n * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\npackage org.vaadin.stefan.ui.view.demos.full;\n\nimport com.vaadin.flow.component.ClientCallable;\nimport com.vaadin.flow.component.dependency.CssImport;\nimport com.vaadin.flow.component.listbox.ListBox;\nimport com.vaadin.flow.component.notification.Notification;\nimport com.vaadin.flow.component.popover.Popover;\nimport com.vaadin.flow.router.Route;\nimport org.vaadin.stefan.fullcalendar.*;\nimport org.vaadin.stefan.ui.dialogs.DemoDialog;\nimport org.vaadin.stefan.ui.layouts.MainLayout;\nimport org.vaadin.stefan.ui.view.AbstractSchedulerView;\nimport org.vaadin.stefan.util.EntryManager;\nimport org.vaadin.stefan.util.ResourceManager;\nimport tools.jackson.databind.node.ObjectNode;\n\nimport java.time.DayOfWeek;\nimport java.time.LocalDate;\nimport java.time.LocalDateTime;\nimport java.time.LocalTime;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\n\n@Route(value = \"\", layout = MainLayout.class)\n@org.vaadin.stefan.ui.menu.MenuItem(label = \"Playground\")\npublic class FullDemo extends AbstractSchedulerView {\n\n    private Popover popup;\n\n    @Override\n    protected FullCalendar createCalendar(ObjectNode initialOptions) {\n//        initialOptions.put(\"eventContent\",\n//                \"function(arg, createElement) {\" +\n//                \" console.warn('hello');\" +\n//                \"  return 'WORLD';\" +\n//                \"}\");\n\n        FullCalendar calendar = FullCalendarBuilder.create()\n                .withAutoBrowserTimezone()\n                .withAutoBrowserLocale()\n//                .withEntryContent(\"\"\"\n//                        function(arg) {\n//                            let italicEl = document.createElement('i');\n//                            if (arg.event.getCustomProperty('isUrgent', false)) {\n//                                italicEl.innerHTML = 'urgent event';\n//                            } else {\n//                                italicEl.innerHTML = 'normal event';\n//                            }\n//                            let arrayOfDomNodes = [ italicEl ];\n//                            return { domNodes: arrayOfDomNodes }\n//                        }\"\"\")\n                .withInitialOptions(initialOptions)\n                .withEntryLimit(3)\n                .withScheduler(Scheduler.GPL_V3_LICENSE_KEY)\n                .build();\n\n        FullCalendarScheduler scheduler = (FullCalendarScheduler) calendar;\n        scheduler.setResourceAreaWidth(\"15%\");\n        scheduler.setSlotMinWidth(\"100\");\n        scheduler.setResourcesInitiallyExpanded(false);\n\n        calendar.setNowIndicatorShown(true);\n        calendar.setTimeslotsSelectable(true);\n\n        calendar.setNumberClickable(true);\n        calendar.addDayNumberClickedListener(event -> {\n            calendar.changeView(CalendarViewImpl.TIME_GRID_DAY);\n            calendar.gotoDate(event.getDate());\n        });\n\n        calendar.addWeekNumberClickedListener(event -> {\n            calendar.changeView(CalendarViewImpl.TIME_GRID_WEEK);\n            calendar.gotoDate(event.getDate());\n        });\n\n        // initally change the view and go to a specific date - attention: this will not fire listeners as the client side is not initialized yet\n//        calendar.changeView(CalendarViewImpl.TIME_GRID_WEEK);\n//        calendar.gotoDate(LocalDate.of(2023, Month.JUNE, 1));\n\n        calendar.setSlotMinTime(LocalTime.of(7, 0));\n        calendar.setSlotMaxTime(LocalTime.of(17, 0));\n\n        calendar.setBusinessHours(\n                BusinessHours.businessWeek().start(9).end(17),\n                BusinessHours.of(DayOfWeek.SATURDAY).start(12).end(15),\n                BusinessHours.of(DayOfWeek.SUNDAY).start(12).end(13)\n        );\n\n        calendar.addBrowserTimezoneObtainedListener(event -> {\n            getToolbar().setTimezone(event.getTimezone());\n        });\n\n        LocalDate now = LocalDate.now();\n        EntryManager.createDayEntry(calendar, \"Test 1\", now.withDayOfMonth(12), 2, \"lightgreen\")\n                .setCustomProperty(\"count\", \"3\");\n        EntryManager.createDayEntry(calendar, \"Test 2\", now.withDayOfMonth(12), 2, \"tomato\")\n                .setCustomProperty(\"count\", \"2\");\n        EntryManager.createDayEntry(calendar, \"Test 3\", now.withDayOfMonth(12), 2, \"lightblue\")\n                .setCustomProperty(\"count\", \"1\");\n\n        scheduler.setEntryResourceEditable(false);\n\n//        calendar.setEntryClassNamesCallback(\"function(arg) {\\n\" +\n//                \"    return [ 'hello','world' ]\\n\" +\n//                \"}\");\n//        calendar.setEntryContentCallback(\"\" +\n//                \"function(arg, createElement) {\" +\n//                \" console.warn('hello');\" +\n//                \"  return 'WORLD';\" +\n//                \"}\");\n\n\n\n//        calendar.addEntryNativeEventListener(\"mouseover\", \"e => info.el.style.opacity = '0.5'\");\n//        calendar.addEntryNativeEventListener(\"mouseout\", \"e => info.el.style.opacity = ''\");\n//        calendar.addEntryNativeEventListener(\"contextmenu\", \"e => console.warn('just a context menu event')\");\n\n        calendar.addEntryNativeEventListener(\"contextmenu\",\n                \"e => {\" +\n                \"   e.preventDefault(); \" +\n                \"   this.el.parentElement.$server.openContextMenu(info.event.id);\" +\n                \"}\");\n//        calendar.setEntryDidMountCallback(\"\"\"\n//                function(info) {\n//                    info.el.id = \"entry-\" + info.event.id;\n//                }\"\"\");\n\n//\n//        scheduler.setResourceLabelContentCallback(\n//                \"function(arg, createElement) {\" +\n//                \" console.warn('hello');\" +\n//                \"  return 'Hello';\" +\n//                \"}\");\n//\n//        scheduler.setResourceLaneContentCallback(\n//                \"function(arg, createElement) {\" +\n//                \" console.warn('world');\" +\n//                \"  return 'World';\" +\n//                \"}\");\n\n        createTestEntries(calendar);\n\n//        calendar.changeView(CalendarViewImpl.MULTI_MONTH);\n//        calendar.gotoDate(LocalDate.now().plusYears(1));\n\n\n        return calendar;\n    }\n\n    private void initPopup() {\n        if (popup == null) {\n            popup = new Popover();\n//            popup.setFocusTrap(true);\n            add(popup);\n        }\n    }\n\n    @ClientCallable\n    public void openContextMenu(String id) {\n        initPopup();\n\n        popup.removeAll();\n\n        ListBox<String> listBox = new ListBox<>();\n        listBox.setItems(\"Option A\", \"Option B\", \"Option C\");\n        listBox.addValueChangeListener(event -> {\n            Notification.show(\"Selected \" + event.getValue());\n            popup.close();\n        });\n\n        popup.add(listBox);\n        popup.setFor(\"entry-\" + id);\n\n        popup.open();\n    }\n\n    private void createTestEntries(FullCalendar calendar) {\n        LocalDate now = LocalDate.now();\n\n        Resource meetingRoomRed = ResourceManager.createResource((Scheduler) calendar, \"Meetingroom Red\", \"#ff0000\");\n        Resource meetingRoomGreen = ResourceManager.createResource((Scheduler) calendar, \"Meetingroom Green\", \"green\");\n        Resource meetingRoomBlue = ResourceManager.createResource((Scheduler) calendar, \"Meetingroom Blue\", \"blue\");\n        Resource meetingRoomOrange = ResourceManager.createResource((Scheduler) calendar, \"Meetingroom Orange\", \"orange\", null,\n                BusinessHours.businessWeek().start(9).end(17));\n\n        Resource computer1A = ResourceManager.createResource((Scheduler) calendar, \"Computer 1A\", \"lightbrown\");\n        Resource computer1B = ResourceManager.createResource((Scheduler) calendar, \"Computer 1B\", \"lightbrown\");\n        Resource computer1C = ResourceManager.createResource((Scheduler) calendar, \"Computer 1C\", \"lightbrown\");\n\n        ResourceManager.createResource((Scheduler) calendar, \"Computer room 1\", \"brown\", Arrays.asList(computer1A, computer1B, computer1C));\n\n        Resource computerRoom2 = ResourceManager.createResource((Scheduler) calendar, \"Computer room 2\", \"brown\");\n        // here we must NOT use createResource, since they are added to the calendar later\n        Resource computer2A = new Resource(null, \"Computer 2A\", \"lightbrown\");\n        Resource computer2B = new Resource(null, \"Computer 2B\", \"lightbrown\");\n        Resource computer2C = new Resource(null, \"Computer 2C\", \"lightbrown\");\n\n        // not realistic, just a demonstration of automatic recursive adding\n        computer2A.addChild(new Resource(null, \"Mouse\", \"orange\"));\n        computer2A.addChild(new Resource(null, \"Screen\", \"orange\"));\n        computer2A.addChild(new Resource(null, \"Keyboard\", \"orange\"));\n\n        List<Resource> computerRoom2Children = Arrays.asList(computer2A, computer2B, computer2C);\n        computerRoom2.addChildren(computerRoom2Children);\n        ((Scheduler) calendar).addResources(computerRoom2Children);\n\n        EntryManager.createTimedEntry(calendar, \"Meeting 1\", now.withDayOfMonth(3).atTime(10, 0), 120, null, meetingRoomBlue, meetingRoomGreen, meetingRoomRed);\n\n        EntryManager.createTimedEntry(calendar, \"Meeting 2\", now.withDayOfMonth(3).atTime(10, 0), 120, null, meetingRoomOrange);\n        EntryManager.createTimedEntry(calendar, \"Meeting 3\", now.withDayOfMonth(7).atTime(11, 30), 120, null, meetingRoomRed);\n\n        HashMap<String, Object> extendedProps = new HashMap<>();\n        HashMap<String, Object> cursors = new HashMap<>();\n        cursors.put(\"enabled\", \"pointer\");\n        cursors.put(\"disabled\", \"not-allowed\");\n        extendedProps.put(\"cursors\", cursors);\n\n        EntryManager.createTimedEntry(calendar, \"Meeting 4\", now.withDayOfMonth(12).atTime(9, 0), 120, null, extendedProps, meetingRoomGreen);\n        EntryManager.createTimedEntry(calendar, \"Meeting 5\", now.withDayOfMonth(13).atTime(10, 0), 120, null, meetingRoomGreen);\n        EntryManager.createTimedEntry(calendar, \"Meeting 6\", now.withDayOfMonth(17).atTime(11, 30), 120, null, meetingRoomBlue);\n        EntryManager.createTimedEntry(calendar, \"Meeting 7\", now.withDayOfMonth(22).atTime(9, 0), 120, null, meetingRoomRed);\n        EntryManager.createTimedEntry(calendar, \"Meeting 8\", now.withDayOfMonth(4).atTime(10, 0), 120, null);\n\n        EntryManager.createTimedBackgroundEntry(calendar, now.withDayOfMonth(3).atTime(10, 0), 120, null);\n        EntryManager.createTimedEntry(calendar, \"Meeting 9\", now.withDayOfMonth(7).atTime(11, 30), 120, \"mediumseagreen\");\n        EntryManager.createTimedEntry(calendar, \"Meeting 10\", now.withDayOfMonth(15).atTime(9, 0), 120, \"mediumseagreen\");\n        EntryManager.createTimedEntry(calendar, \"Meeting 11\", now.withDayOfMonth(18).atTime(10, 0), 120, \"mediumseagreen\");\n        EntryManager.createTimedEntry(calendar, \"Meeting 12\", now.withDayOfMonth(17).atTime(11, 30), 120, \"mediumseagreen\");\n        EntryManager.createTimedEntry(calendar, \"Meeting 13\", now.withDayOfMonth(24).atTime(9, 0), 120, \"mediumseagreen\");\n\n        EntryManager.createTimedEntry(calendar, \"Grocery Store\", now.withDayOfMonth(7).atTime(17, 30), 45, \"violet\");\n        EntryManager.createTimedEntry(calendar, \"Dentist\", now.withDayOfMonth(20).atTime(11, 30), 60, \"violet\");\n        EntryManager.createTimedEntry(calendar, \"Cinema\", now.withDayOfMonth(10).atTime(20, 30), 140, \"dodgerblue\");\n        EntryManager.createDayEntry(calendar, \"Short trip\", now.withDayOfMonth(17), 2, \"dodgerblue\");\n        EntryManager.createDayEntry(calendar, \"John's Birthday\", now.withDayOfMonth(23), 1, \"gray\");\n        EntryManager.createDayEntry(calendar, \"This special holiday\", now.withDayOfMonth(4), 1, \"gray\");\n\n        EntryManager.createTimedEntry(calendar, \"Not editable\", now.withDayOfMonth(5).atTime(10, 0), 60, \"lightgray\")\n                .setEditable(false);\n\n        ResourceEntry startOnly = EntryManager.createTimedEntry(calendar, \"Only start editable\",\n                now.withDayOfMonth(5).atTime(11, 0), 60, \"lightgray\");\n        startOnly.setEditable(false);\n        startOnly.setStartEditable(true);\n\n        ResourceEntry durationOnly = EntryManager.createTimedEntry(calendar, \"Only duration editable\",\n                now.withDayOfMonth(5).atTime(12, 0), 60, \"lightgray\");\n        durationOnly.setEditable(false);\n        durationOnly.setDurationEditable(true);\n\n        EntryManager.createDayEntry(calendar, \"Multi 1\", now.withDayOfMonth(12), 2, \"tomato\");\n        EntryManager.createDayEntry(calendar, \"Multi 2\", now.withDayOfMonth(12), 2, \"tomato\");\n        EntryManager.createDayEntry(calendar, \"Multi 3\", now.withDayOfMonth(12), 2, \"tomato\");\n        EntryManager.createDayEntry(calendar, \"Multi 4\", now.withDayOfMonth(12), 2, \"tomato\");\n        EntryManager.createDayEntry(calendar, \"Multi 5\", now.withDayOfMonth(12), 2, \"tomato\");\n        EntryManager.createDayEntry(calendar, \"Multi 6\", now.withDayOfMonth(12), 2, \"tomato\");\n        EntryManager.createDayEntry(calendar, \"Multi 7\", now.withDayOfMonth(12), 2, \"tomato\");\n        EntryManager.createDayEntry(calendar, \"Multi 8\", now.withDayOfMonth(12), 2, \"tomato\");\n        EntryManager.createDayEntry(calendar, \"Multi 9\", now.withDayOfMonth(12), 2, \"tomato\");\n        EntryManager.createDayEntry(calendar, \"Multi 10\", now.withDayOfMonth(12), 2, \"tomato\");\n\n\n        EntryManager.createDayBackgroundEntry(calendar, now.withDayOfMonth(4), 6, \"#B9FFC3\");\n        EntryManager.createDayBackgroundEntry(calendar, now.withDayOfMonth(19), 2, \"#CEE3FF\");\n        EntryManager.createTimedBackgroundEntry(calendar, now.withDayOfMonth(20).atTime(11, 0), 150, \"#ff0000\");\n\n        EntryManager.createRecurringEvents(calendar);\n    }\n\n    @Override\n    protected String createDescription() {\n        return \"Welcome to the FullCalendar demo playground. In this instance you see a basic set of different calendar entry types to play around with. \" +\n                \"You may also create new ones or delete them. Have fun :)\";\n    }\n\n    @Override\n    protected void onTimeslotsSelected(TimeslotsSelectedEvent event) {\n//        super.onTimeslotsSelected(event); // this is handled by onTimeslotSelectedScheduler\n        System.out.println(event.getClass().getSimpleName() + \": \" + event);\n    }\n\n    @Override\n    protected void onDayNumberClicked(DayNumberClickedEvent event) {\n        super.onDayNumberClicked(event);\n        System.out.println(event.getClass().getSimpleName() + \": \" + event);\n    }\n\n    @Override\n    protected void onWeekNumberClicked(WeekNumberClickedEvent event) {\n        super.onWeekNumberClicked(event);\n        System.out.println(event.getClass().getSimpleName() + \": \" + event);\n    }\n\n    @Override\n    protected void onViewSkeletonRendered(ViewSkeletonRenderedEvent event) {\n        super.onViewSkeletonRendered(event);\n        System.out.println(event.getClass().getSimpleName() + \": \" + event);\n    }\n\n    @Override\n    protected void onEntryResized(EntryResizedEvent event) {\n        super.onEntryResized(event);\n        System.out.println(event.getClass().getSimpleName() + \": \" + event);\n    }\n\n    @Override\n    protected void onEntryDropped(EntryDroppedEvent event) {\n//        super.onEntryDropped(event); this is handled by onEntryDroppedScheduler\n        System.out.println(event.getClass().getSimpleName() + \": \" + event);\n    }\n\n    @Override\n    protected void onEntryClick(EntryClickedEvent event) {\n        System.out.println(event.getClass().getSimpleName() + \": \" + event);\n\n        if (event.getEntry().getDisplayMode() != DisplayMode.BACKGROUND && event.getEntry().getDisplayMode() != DisplayMode.INVERSE_BACKGROUND) {\n            DemoDialog dialog = new DemoDialog(event.getEntry(), false);\n            dialog.setSaveConsumer(this::onEntryChanged);\n            dialog.setDeleteConsumer(e -> onEntriesRemoved(Collections.singletonList(e)));\n            dialog.open();\n        }\n    }\n\n    @Override\n    protected void onBrowserTimezoneObtained(BrowserTimezoneObtainedEvent event) {\n        super.onBrowserTimezoneObtained(event);\n        System.out.println(event.getClass().getSimpleName() + \": \" + event);\n    }\n\n    @Override\n    protected void onDatesRendered(DatesRenderedEvent event) {\n        super.onDatesRendered(event);\n        System.out.println(event.getClass().getSimpleName() + \": \" + event);\n    }\n\n    @Override\n    protected void onMoreLinkClicked(MoreLinkClickedEvent event) {\n        super.onMoreLinkClicked(event);\n        System.out.println(event.getClass().getSimpleName() + \": \" + event);\n    }\n\n    @Override\n    protected void onTimeslotClicked(TimeslotClickedEvent event) {\n//        super.onTimeslotClicked(event); // this is handled by onTimeslotClickedScheduler\n        System.out.println(event.getClass().getSimpleName() + \": \" + event);\n    }\n\n    @Override\n    protected void onEntryDroppedScheduler(EntryDroppedSchedulerEvent event) {\n        super.onEntryDroppedScheduler(event);\n        System.out.println(event.getClass().getSimpleName() + \": \" + event);\n    }\n\n    @Override\n    protected void onTimeslotClickedScheduler(TimeslotClickedSchedulerEvent event) {\n        super.onTimeslotClickedScheduler(event);\n        System.out.println(event.getClass().getSimpleName() + \": \" + event);\n    }\n\n    @Override\n    protected void onTimeslotsSelectedScheduler(TimeslotsSelectedSchedulerEvent event) {\n        super.onTimeslotsSelectedScheduler(event);\n        System.out.println(event.getClass().getSimpleName() + \": \" + event);\n\n        System.out.println( \"ZoneId: \" + event.getSource().getTimezone().getZoneId() );\n        LocalDateTime startDate = event.getStart();\n        System.out.println( \"getStart(): \" + event.getStart() );\n        System.out.println( \"getStartWithOffset():  \" + event.getStartWithOffset() );\n\n        ResourceEntry entry = new ResourceEntry();\n\n        entry.setStart(event.getStart());\n        entry.setEnd(event.getEnd());\n        entry.setAllDay(event.isAllDay());\n\n        entry.setCalendar(event.getSource());\n\n        DemoDialog dialog = new DemoDialog(entry, true);\n        dialog.setSaveConsumer(e -> onEntriesCreated(Collections.singletonList(e)));\n        dialog.setDeleteConsumer(e -> onEntriesRemoved(Collections.singletonList(e)));\n        dialog.open();\n    }\n}",
      "language": "java",
      "category": "events",
      "tags": [
        "entry",
        "callback",
        "resource",
        "scheduler",
        "timezone",
        "recurring",
        "event",
        "listener",
        "click",
        "drop",
        "resize",
        "style",
        "view",
        "builder",
        "create",
        "delete"
      ]
    },
    {
      "id": "demo-inlinecalendardemo",
      "title": "Inline Calendar Demo",
      "description": "@author Stefan Uebe",
      "code": "package org.vaadin.stefan.ui.view.demos.multimonthselection;\n\nimport com.vaadin.flow.component.dependency.JsModule;\nimport com.vaadin.flow.component.dependency.StyleSheet;\nimport com.vaadin.flow.component.orderedlayout.VerticalLayout;\nimport com.vaadin.flow.router.Route;\nimport org.vaadin.stefan.fullcalendar.*;\nimport org.vaadin.stefan.fullcalendar.dataprovider.EntryProvider;\nimport org.vaadin.stefan.fullcalendar.dataprovider.InMemoryEntryProvider;\nimport org.vaadin.stefan.ui.layouts.MainLayout;\nimport org.vaadin.stefan.ui.menu.MenuItem;\nimport org.vaadin.stefan.ui.view.AbstractCalendarView;\nimport org.vaadin.stefan.ui.view.demos.entryproviders.CallbackEntryProviderDemo;\nimport org.vaadin.stefan.ui.view.demos.entryproviders.EntryService;\n\nimport java.time.LocalDate;\nimport java.time.LocalDateTime;\nimport java.time.Period;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.stream.Collectors;\n\n/**\n * @author Stefan Uebe\n */\n@Route(value = \"inline-calendar\", layout = MainLayout.class)\n@MenuItem(label = \"Inline Calendar\")\n@JsModule(\"./multi-month-selection-utils.js\")\n@StyleSheet(\"inline-calendar.css\")\npublic class InlineCalendarDemo extends VerticalLayout {\n\n    // basic constructor with full sized items\n    public InlineCalendarDemo() {\n        setSizeFull();\n        setAlignItems(Alignment.STRETCH);\n\n        FullCalendar calendar = FullCalendarBuilder.create()\n                .withAutoBrowserLocale()\n                .build();\n        calendar.addClassName(\"inline-calendar\");\n\n        // activate cross month selection\n        calendar.setTimeslotsSelectable(false); // important\n        calendar.addAttachListener(event -> // refire things, when reattached\n            calendar.getElement()\n                .executeJs(\"window.Vaadin.Flow.multiMonthCrossSelectionUtils.register(this.calendar)\")\n                .then(jsonValue -> calendar.changeView(CalendarViewImpl.MULTI_MONTH))\n        );\n\n        addAndExpand(calendar);\n\n        InMemoryEntryProvider<Entry> entryProvider = calendar.getEntryProvider().asInMemory();\n        calendar.addTimeslotsSelectedListener(event -> {\n            // fetch entries from the entryprovider using the event start and end date and map them to their start date\n            LocalDateTime start = event.getStart();\n            LocalDateTime end = event.getEnd();\n\n            System.out.println(\"start: \" + start);\n            System.out.println(\"end: \" + end);\n\n            Map<LocalDate, Entry> map = entryProvider\n                    .fetch(start, end)\n                    .collect(Collectors.toMap(entry -> entry.getStartAsLocalDate(), entry -> entry));\n\n            // calculate amount of days between event start and end\n            int days = Period.between(start.toLocalDate(), end.toLocalDate()).getDays();\n            if (days == map.size()) {\n                // unmark all days that are covered by the event period\n                entryProvider.removeEntries(map.values());\n                entryProvider.refreshAll();\n            } else {\n                // iterate over the event period and create an entry for each day, that is not in the map\n                LocalDate startDate = start.toLocalDate();\n                LocalDate endDate = end.toLocalDate();\n                LocalDate date = startDate;\n\n                while (date.isBefore(endDate)) {\n                    if (!map.containsKey(date)) {\n                        Entry entry = new Entry();\n                        entry.setStart(date.atStartOfDay());\n                        entry.setEnd(date.plusDays(1).atStartOfDay());\n                        entry.setAllDay(true);\n                        entry.setDisplayMode(DisplayMode.BACKGROUND);\n                        entryProvider.addEntry(entry);\n                    }\n\n                    date = date.plusDays(1);\n                }\n\n                entryProvider.refreshAll();\n            }\n\n            calendar.clearSelection();\n        });\n\n    }\n\n}\n",
      "language": "java",
      "category": "data-provider",
      "tags": [
        "entry",
        "provider",
        "callback",
        "inmemory",
        "event",
        "listener",
        "style",
        "view",
        "builder",
        "create"
      ]
    },
    {
      "id": "demo-multimonthcrossmonthselectiondemo",
      "title": "Multi Month Cross Month Selection Demo",
      "description": "@author Stefan Uebe",
      "code": "package org.vaadin.stefan.ui.view.demos.multimonthselection;\n\nimport com.vaadin.flow.component.dependency.JsModule;\nimport com.vaadin.flow.router.Route;\nimport org.vaadin.stefan.fullcalendar.CalendarViewImpl;\nimport org.vaadin.stefan.fullcalendar.FullCalendar;\nimport org.vaadin.stefan.ui.layouts.MainLayout;\nimport org.vaadin.stefan.ui.menu.MenuItem;\nimport org.vaadin.stefan.ui.view.demos.entryproviders.CallbackEntryProviderDemo;\n\n/**\n * @author Stefan Uebe\n */\n@Route(value = \"multi-month-cross-month-selection\", layout = MainLayout.class)\n@MenuItem(label = \"Multi Month Cross Selection\")\n@JsModule(\"./multi-month-selection-utils.js\")\npublic class MultiMonthCrossMonthSelectionDemo extends CallbackEntryProviderDemo {\n\n    @Override\n    protected boolean isToolbarViewChangeable() {\n        return false;\n    }\n\n    @Override\n    protected void postConstruct(FullCalendar calendar) {\n        calendar.setTimeslotsSelectable(false); // important\n\n        calendar.addAttachListener(event -> // refire things, when reattached\n            calendar.getElement()\n                .executeJs(\"window.Vaadin.Flow.multiMonthCrossSelectionUtils.register(this.calendar)\")\n                .then(jsonValue -> calendar.changeView(CalendarViewImpl.MULTI_MONTH))\n        );\n    }\n\n    @Override\n    protected String createTitle() {\n        return \"Multi Month View - Cross Month Selection\";\n    }\n\n    @Override\n    protected String createDescription() {\n        return \"This demo shows a sample on how to implement cross month selection for the multi month view. This feature is currently not available\" +\n                \" in the library itself and thus integrated via a custom java script\";\n    }\n}\n",
      "language": "java",
      "category": "data-provider",
      "tags": [
        "entry",
        "provider",
        "callback",
        "event",
        "listener",
        "view",
        "create"
      ]
    },
    {
      "id": "demo-demowithtooltip",
      "title": "Demo With Tooltip",
      "description": "Demo: DemoWithTooltip",
      "code": "/*\n * Copyright 2020, Stefan Uebe\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\n * documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial portions\n * of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE\n * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\npackage org.vaadin.stefan.ui.view.demos.tooltip;\n\nimport com.vaadin.flow.router.PageTitle;\nimport com.vaadin.flow.router.Route;\nimport org.vaadin.stefan.fullcalendar.Entry;\nimport org.vaadin.stefan.fullcalendar.FullCalendar;\nimport org.vaadin.stefan.fullcalendar.FullCalendarBuilder;\nimport org.vaadin.stefan.fullcalendar.dataprovider.InMemoryEntryProvider;\nimport org.vaadin.stefan.ui.layouts.MainLayout;\nimport org.vaadin.stefan.ui.menu.MenuItem;\nimport org.vaadin.stefan.ui.view.AbstractCalendarView;\nimport org.vaadin.stefan.ui.view.demos.entryproviders.EntryService;\nimport tools.jackson.databind.node.ObjectNode;\n\n@Route(value = \"tooltip\", layout = MainLayout.class)\n@PageTitle(\"FC with Tooltips\")\n@MenuItem(label = \"Tooltips\")\npublic class DemoWithTooltip extends AbstractCalendarView {\n    private static final long serialVersionUID = 1L;\n    private InMemoryEntryProvider<Entry> entryProvider;\n\n\n    @Override\n    protected FullCalendar createCalendar(ObjectNode defaultInitialOptions) {\n        EntryService entryService = EntryService.createSimpleInstance();\n\n        FullCalendar calendar = FullCalendarBuilder.create()\n                .withCustomType(FullCalendarWithTooltip.class) // create a new instance with a custom type\n                .withInitialOptions(defaultInitialOptions)\n                .withEntryLimit(3)\n                .withInitialEntries(entryService.getEntries()) // init with some sample data\n                .build();\n\n        return calendar;\n    }\n\n    @Override\n    protected String createDescription() {\n        return \"This demo shows the integration of the Tippy tooltip library. Every calendar entry will show a tooltip based on the entry's description. The integration \" +\n                \"is done in a simple client side extension of the base javascript class of the FullCalendar.\";\n    }\n}\n",
      "language": "java",
      "category": "data-provider",
      "tags": [
        "entry",
        "provider",
        "inmemory",
        "event",
        "view",
        "builder",
        "create"
      ]
    }
  ],
  "entryProperties": [
    {
      "name": "PROPERTIES",
      "type": "static final Set<BeanProperties<Entry>>",
      "description": "The PROPERTIES property of the entry",
      "defaultValue": "BeanProperties.read(Entry.class)",
      "clientUpdatable": false
    },
    {
      "name": "id",
      "type": "final String",
      "description": "The id property of the entry",
      "clientUpdatable": false
    },
    {
      "name": "groupId",
      "type": "String",
      "description": "The groupId property of the entry",
      "clientUpdatable": false
    },
    {
      "name": "title",
      "type": "String",
      "description": "The title property of the entry",
      "clientUpdatable": false
    },
    {
      "name": "start",
      "type": "LocalDateTime",
      "description": "The start property of the entry",
      "clientUpdatable": true
    },
    {
      "name": "end",
      "type": "LocalDateTime",
      "description": "The end property of the entry",
      "clientUpdatable": true
    },
    {
      "name": "allDay",
      "type": "boolean",
      "description": "The allDay property of the entry",
      "clientUpdatable": true
    },
    {
      "name": "editable",
      "type": "boolean",
      "description": "The editable property of the entry",
      "defaultValue": "true",
      "clientUpdatable": false
    },
    {
      "name": "startEditable",
      "type": "Boolean",
      "description": "The startEditable property of the entry",
      "clientUpdatable": false
    },
    {
      "name": "durationEditable",
      "type": "Boolean",
      "description": "The durationEditable property of the entry",
      "clientUpdatable": false
    },
    {
      "name": "color",
      "type": "String",
      "description": "The color property of the entry",
      "clientUpdatable": false
    },
    {
      "name": "constraint",
      "type": "String",
      "description": "The constraint property of the entry",
      "clientUpdatable": false
    },
    {
      "name": "backgroundColor",
      "type": "String",
      "description": "The backgroundColor property of the entry",
      "clientUpdatable": false
    },
    {
      "name": "borderColor",
      "type": "String",
      "description": "The borderColor property of the entry",
      "clientUpdatable": false
    },
    {
      "name": "textColor",
      "type": "String",
      "description": "The textColor property of the entry",
      "clientUpdatable": false
    },
    {
      "name": "overlap",
      "type": "boolean",
      "description": "The overlap property of the entry",
      "defaultValue": "true",
      "clientUpdatable": false
    },
    {
      "name": "displayMode",
      "type": "DisplayMode",
      "description": "The displayMode property of the entry",
      "defaultValue": "DisplayMode.AUTO",
      "jsonName": "display",
      "clientUpdatable": false
    },
    {
      "name": "recurringStartDate",
      "type": "LocalDate",
      "description": "The recurringStartDate property of the entry",
      "jsonName": "startRecur",
      "clientUpdatable": false
    },
    {
      "name": "recurringEndDate",
      "type": "LocalDate",
      "description": "The recurringEndDate property of the entry",
      "jsonName": "endRecur",
      "clientUpdatable": false
    },
    {
      "name": "recurringStartTime",
      "type": "RecurringTime",
      "description": "The recurringStartTime property of the entry",
      "jsonName": "startTime",
      "clientUpdatable": false
    },
    {
      "name": "recurringEndTime",
      "type": "RecurringTime",
      "description": "The recurringEndTime property of the entry",
      "jsonName": "endTime",
      "clientUpdatable": false
    },
    {
      "name": "recurringDaysOfWeek",
      "type": "Set<DayOfWeek>",
      "description": "The recurringDaysOfWeek property of the entry",
      "jsonName": "daysOfWeek",
      "clientUpdatable": false
    },
    {
      "name": "classNames",
      "type": "Set<String>",
      "description": "The classNames property of the entry",
      "clientUpdatable": false
    },
    {
      "name": "knownToTheClient",
      "type": "boolean",
      "description": "The knownToTheClient property of the entry",
      "clientUpdatable": false
    },
    {
      "name": "startAsInstant",
      "type": "Instant",
      "description": "Converts the given instance to a json object representing its inner state. This json is intended to be\ntransported to and interpreted by the client and thus should not be modified manually, except for concrete\nreasons.\n\n/\n    \n    public ObjectNode toJson() {\n        // The toJson is implemented in a dynamic fashion to not need to extend it every time a\n        // new property comes out.\n\n        ObjectNode json = JsonFactory.createObject();\n\n        streamProperties().forEach(def -> {\n            // Use cached annotation data from BeanProperties for performance\n            if (!def.isJsonIgnored()) {\n                Object value = def.getGetter().apply(this);\n\n                JsonNode jsonValue;\n\n                JsonItemPropertyConverter converter = def.getConverter();\n\n                if (converter != null && converter.supports(value)) {\n                    jsonValue = converter.toClientModel(value, this);\n                } else {\n                    jsonValue = JsonUtils.toJsonNode(value);\n                }\n\n                if (jsonValue != null && !(jsonValue instanceof NullNode)) {\n                    json.set(def.getJsonName(), jsonValue);\n                }\n            }\n        });\n\n        return json;\n    }\n\n    /**\nUpdates this instance with the given json object. Only fields, that are updateable will be overwritten.\nThrows an exception, when the given json object has not the same id as this instance.\n\n/\n    public void updateFromJson(ObjectNode jsonObject) {\n        updateFromJson(jsonObject, true);\n    }\n\n    /**\nUpdates this instance with the given json object. Only fields, that are updateable will be overwritten.\nBased on the boolean parameter, the id will be either ignored (false) or has to be the same as this instance's one\n(true), otherwise an exception will be thrown\n\n\n/\n    \n    public void updateFromJson(ObjectNode jsonObject, boolean requiresMatchingId) {\n        if (requiresMatchingId) {\n            if (!jsonObject.hasNonNull(Fields.ID)) {\n                throw new IllegalArgumentException(\"JsonObject has no id. Id matching is required.\");\n            }\n\n            String idString = jsonObject.get(Fields.ID).asString();\n            if (!id.equals(idString)) {\n                throw new IllegalArgumentException(\"Id matching is required. This id is \" + id + \" but the json object provided \" + idString);\n            }\n        }\n\n        streamProperties().forEach(def -> {\n            // Use cached annotation data from BeanProperties for performance\n            if (!def.isJsonIgnored() && def.isJsonUpdateAllowed()) {\n                String name = def.getName();\n\n                Setter<Entry, Object> setter = def.getSetter()\n                        .orElseThrow(() -> new UnsupportedOperationException(\"No setter found for field \" + name));\n\n                String jsonName = def.getJsonName();\n\n                if (jsonObject.hasNonNull(jsonName)) {\n                    JsonItemPropertyConverter converter = def.getConverter();\n\n                    Object newValue;\n                    JsonNode jsonValue = jsonObject.get(jsonName);\n\n                    if (converter != null) {\n                        newValue = converter.toServerModel(jsonValue, this);\n                    } else {\n                        newValue = JsonUtils.ofJsonNode(jsonValue);\n                    }\n\n                    setter.accept(this, newValue);\n                }\n            }\n        });\n    }\n\n    /**\nChecks whether the given json object is a valid source to update this instance.\n\n\n/\n    protected boolean isValidJsonSource(ObjectNode jsonObject) {\n        return jsonObject.hasNonNull(Fields.ID) && Objects.equals(jsonObject.get(Fields.ID).asString(), getId());\n    }\n\n    /**\nCreates a copy of this instance. Collection, Map and Array values are copied (but their values are taken\nas they are, so no deep copy).\n\n\n/\n    public <T extends Entry> T copy() {\n        try {\n            T copy = (T) getClass().getConstructor(String.class).newInstance(getId());\n            copy(this, copy, false);\n\n            return copy;\n        } catch (ReflectiveOperationException e) {\n            throw new RuntimeException(\"Failed to create copy of entry\", e);\n        }\n    }\n\n    /**\nCreates a copy of this instance. Collection, Map and Array values are copied (but their values are taken\nas they are, so no deep copy).\n<p></p>\nPlease make sure, that both types are compatible in their properties. Any property, that exists in the source\nbut not the target type might lead to an exception. Also the target type must have a public constructor, taking\nthe id as the parameter.\n\n\n/\n    public <T extends Entry> T copyAsType(Class<T> targetType) {\n        try {\n            T copy = (T) targetType.getConstructor(String.class).newInstance(getId());\n            copy(this, copy, true);\n\n            return copy;\n        } catch (ReflectiveOperationException e) {\n            throw new RuntimeException(\"Failed to create copy of entry as type \" + targetType.getName(), e);\n        }\n    }\n\n    public void copyFrom(Entry source) {\n        copyFrom(source, false);\n    }\n\n    public void copyFrom(Entry source, boolean ignoreId) {\n        if (!ignoreId && !source.getId().equals(getId())) {\n            throw new IllegalArgumentException(\"IDs must match\");\n        }\n        copy(source, this, false);\n    }\n\n    /**\nCopies all values from source to target (except for the id). When the boolean is set to false,\nboth objects have to be of the <b>same</b> type. Otherwise it is up to the developer to guarantee,\nthat the target can take all properties of the source.<br>\nProperties without a setter are ignored.\n\n\n\n/\n    \n    public static void copy(Entry source, Entry target, boolean ignoreTypeDifference) {\n        if (!ignoreTypeDifference && !source.getClass().equals(target.getClass())) {\n            throw new IllegalArgumentException(\"Both parameters must be of the SAME class.\");\n        }\n\n        source.streamProperties().forEach(def -> {\n            ValueProvider getter = def.getGetter();\n            def.getSetter().ifPresent(setter -> {\n                try {\n                    Object value = getter.apply(source);\n\n                    if (value instanceof Collection) {\n                        // fails on unmodifiable\n                        Collection collection = newInstance((Collection) value);\n                        collection.addAll((Collection) value);\n                        value = collection;\n                    } else if (value instanceof Map) {\n                        // fails on unmodifiable\n                        Map map = newInstance((Map) value);\n                        map.putAll((Map) value);\n                        value = map;\n                    } else if (value instanceof Object[]) {\n                        value = ((Object[]) value).clone();\n                    }\n\n                    setter.accept(target, value);\n                } catch (ReflectiveOperationException e) {\n                    throw new RuntimeException(\"Property \" + def.getName() + \" threw an exception during copy\", e);\n                }\n            });\n        });\n    }\n\n    \n    private static <T> T newInstance(T value) throws ReflectiveOperationException {\n        try {\n            return (T) value.getClass().getConstructor().newInstance();\n        } catch (NoSuchMethodException e) {\n            if (value instanceof Set) {\n                return (T) new LinkedHashSet<>();\n            }\n\n            if (value instanceof Collection) {\n                return (T) new ArrayList<>();\n            }\n\n            if (value instanceof Map) {\n                return (T) new HashMap<>();\n            }\n\n            throw new IllegalArgumentException(\"Type \" + value.getClass() + \" has no public no-args constructor and no fallback.\");\n        }\n    }\n\n    protected Stream<BeanProperties<Entry>> streamProperties() {\n        return PROPERTIES.stream();\n    }\n\n    /**\nStreams all properties, that are updateable. A property counts as updateable, if it is not annotated with\n{\n\n/\n    protected Stream<BeanProperties<Entry>> streamUpdateableProperties() {\n        return streamProperties().filter(def ->\n                !def.isJsonIgnored()\n                        && def.isJsonUpdateAllowed()\n                        && def.getSetter().isPresent()\n        );\n    }\n\n    /**\nConverts this instance to a json object, that only contains the id. This still represents\nthis item but without any data.\n\n/\n    public ObjectNode toJsonWithIdOnly() {\n        ObjectNode jsonObject = JsonFactory.createObject();\n        jsonObject.put(Fields.ID, getId());\n        return jsonObject;\n    }\n\n    /**\nReturns the entry's start as an {\n{",
      "clientUpdatable": false
    },
    {
      "name": "startAsLocalDate",
      "type": "LocalDate",
      "description": "Returns the entry's start date.",
      "clientUpdatable": false
    },
    {
      "name": "startWithTimezone",
      "type": "ZonedDateTime",
      "description": "Returns the start time as a zoned date time using this entry's start time zone. By default this is\nthe calendar's timezone or, if no calendar is set yet, UTC.\n<p></p>\nCalling {",
      "clientUpdatable": false
    },
    {
      "name": "startWithOffset",
      "type": "LocalDateTime",
      "description": "Returns the start time as a local date time after applying the timezone's offset to\nthe utc based start date ({\nthe calendar's timezone or, if no calendar is set yet, UTC.\n<p></p>\nTo get a {\n{",
      "clientUpdatable": false
    },
    {
      "name": "endAsInstant",
      "type": "Instant",
      "description": "Returns the start time as a local date time after applying the timezone's offset to\nthe utc based start date ({\n<p></p>\nThis method is intended to be used for new entrys that have not yet been added to the\ncalender and thus have no reference to its timezone.\n<p></p>\nTo get a {\n{\n\n/\n    public LocalDateTime getStartWithOffset(Timezone timezone) {\n        return timezone.applyTimezoneOffset(getStart());\n    }\n\n    /**\nSets the entry's start. The given date time will be interpreted as the UTC start time of this entry.\n\n/\n    public void setStart(LocalDateTime start) {\n        this.start = start;\n    }\n\n    /**\nSets the entry's start. The given instant will be interpreted as the UTC start time of this entry.\n\n/\n    public void setStart(Instant start) {\n        setStart(start != null ? LocalDateTime.ofInstant(start, Timezone.ZONE_ID_UTC) : null);\n    }\n\n    /**\nSets the given local date as start using the start of the day as time (utc based).\n\n/\n    public void setStart(LocalDate start) {\n        setStart(start != null ? start.atStartOfDay() : null);\n    }\n\n    /**\nSets the entry's start based on the zoned date time instance. The given date time will be converted to UTC.\n<p></p>\nFor instance, when passing an instance with ...T01:00 and the timezone is Europe/Berlin in winter,\nthe resulting start time will be ...T00:00.\n<p></p>\n\n/\n    public void setStartWithTimezone(ZonedDateTime startWithTimezone) {\n        setStart(startWithTimezone != null ? startWithTimezone.withZoneSameInstant(Timezone.ZONE_ID_UTC).toLocalDateTime() : null);\n    }\n\n    /**\nSets the entry's start. The given date time will be interpreted as having the offset of the\nstart time zone applied. The time will be converted to UTC.\n<p></p>\nFor instance, when passing an instance with ...T01:00 and the timezone is Europe/Berlin in winter,\nthe resulting start time will be ...T00:00.\n<p></p>\nThis method is intended to be used in cases where the start time is edited in relation to\nthe current time zone (like a calendar entry editor).\n<p></p>\n\n/\n    public void setStartWithOffset(LocalDateTime startWithTimezone) {\n        setStartWithOffset(startWithTimezone, getStartTimezone());\n    }\n\n    /**\nSets the entry's start. The given date time will be interpreted as having the offset of the\ngiven time zone applied. The time will be converted to UTC.\n<p></p>\nFor instance, when passing an instance with ...T01:00 and the timezone is Europe/Berlin in winter,\nthe resulting start time will be ...T00:00.\n<p></p>\nThis method is intended to be used in cases where entry is not yet added to the calender and thus\ncannot use its timezone to interpret the offset.\n<p></p>\n\n\n/\n    public void setStartWithOffset(LocalDateTime startWithTimezone, Timezone timezone) {\n        setStart(timezone.removeTimezoneOffset(startWithTimezone));\n    }\n\n    /**\nClears the current start time. Convenience method to prevent unnecessary casting when using\nsetStart(null).\n/\n    public void clearStart() {\n        setStart((LocalDateTime) null);\n    }\n\n    /**\nReturns the entry's end as an {\n{",
      "clientUpdatable": false
    },
    {
      "name": "endAsLocalDate",
      "type": "LocalDate",
      "description": "Returns the entry's end date.",
      "clientUpdatable": false
    },
    {
      "name": "endWithTimezone",
      "type": "ZonedDateTime",
      "description": "Returns the end time as a zoned date time using this entry's end time zone. By default this is\nthe calendar's timezone or, if no calendar is set yet, UTC.\n<p></p>\nCalling {",
      "clientUpdatable": false
    },
    {
      "name": "endWithOffset",
      "type": "LocalDateTime",
      "description": "Returns the end time as a local date time after applying the timezone's offset to\nthe utc based end date ({\nthe calendar's timezone or, if no calendar is set yet, UTC.\n<p></p>\nTo get a {\n{",
      "clientUpdatable": false
    },
    {
      "name": "startTimezone",
      "type": "Timezone",
      "description": "Returns the end time as a local date time after applying the timezone's offset to\nthe utc based end date ({\n<p></p>\nThis method is intended to be used for new entrys that have not yet been added to the\ncalender and thus have no reference to its timezone.\n<p></p>\nTo get a {\n{\n\n/\n    public LocalDateTime getEndWithOffset(Timezone timezone) {\n        return timezone.applyTimezoneOffset(getEnd());\n    }\n\n    /**\nSets the entry's end. The given date time will be interpreted as the UTC end time of this entry.\n\n/\n    public void setEnd(LocalDateTime end) {\n        this.end = end;\n    }\n\n    /**\nSets the entry's end. The given instant will be interpreted as the UTC end time of this entry.\n\n/\n    public void setEnd(Instant end) {\n        setEnd(end != null ? LocalDateTime.ofInstant(end, Timezone.ZONE_ID_UTC) : null);\n    }\n\n    /**\nSets the given local date as end using the end of the day as time (utc based).\n\n/\n    public void setEnd(LocalDate end) {\n        setEnd(end != null ? end.atStartOfDay() : null);\n    }\n\n    /**\nSets the entry's end based on the zoned date time instance. The given date time will be converted to UTC.\n<p></p>\nFor instance, when passing an instance with ...T01:00 and the timezone is Europe/Berlin in winter,\nthe resulting end time will be ...T00:00.\n<p></p>\n\n/\n    public void setEndWithTimezone(ZonedDateTime endWithTimezone) {\n        setEnd(endWithTimezone != null ? endWithTimezone.withZoneSameInstant(Timezone.ZONE_ID_UTC).toLocalDateTime() : null);\n    }\n\n    /**\nSets the entry's end. The given date time will be interpreted as having the offset of the\nend time zone applied. The time will be converted to UTC.\n<p></p>\nFor instance, when passing an instance with ...T01:00 and the timezone is Europe/Berlin in winter,\nthe resulting end time will be ...T00:00.\n<p></p>\nThis method is intended to be used in cases where the end time is edited in relation to\nthe current time zone (like a calendar entry editor).\n<p></p>\n\n/\n    public void setEndWithOffset(LocalDateTime endWithTimezone) {\n        setEnd(getEndTimezone().removeTimezoneOffset(endWithTimezone));\n    }\n\n    /**\nSets the entry's end. The given date time will be interpreted as having the offset of the\ngiven time zone applied. The time will be converted to UTC.\n<p></p>\nFor instance, when passing an instance with ...T01:00 and the timezone is Europe/Berlin in winter,\nthe resulting end time will be ...T00:00.\n<p></p>\nThis method is intended to be used in cases where entry is not yet added to the calender and thus\ncannot use its timezone to interpret the offset.\n<p></p>\n\n\n/\n    public void setEndWithOffset(LocalDateTime endWithTimezone, Timezone timezone) {\n        setEnd(timezone.removeTimezoneOffset(endWithTimezone));\n    }\n\n    /**\nClears the current end time. Convenience method to prevent unnecessary casting when using\nsetEnd(null).\n/\n    public void clearEnd() {\n        setEnd((LocalDateTime) null);\n    }\n\n    /**\nMoves the entry by the given delta. Negative deltas will result in moving the entry to the past.\n\n/\n    public void moveStartEnd(Delta delta) {\n        moveStart(delta);\n        moveEnd(delta);\n    }\n\n    /**\nMoves the entry's start by the given delta without modifying the end.\nNegative deltas will result in moving the start to the past.\n\n/\n    public void moveStart(Delta delta) {\n        setStart(delta.applyOn(getStart()));\n    }\n\n    /**\nMoves the entry's end by the given delta without modifying the start.\nNegative deltas will result in moving the end to the past.\n\n/\n    public void moveEnd(Delta delta) {\n        setEnd(delta.applyOn(getEnd()));\n    }\n\n    /**\nReturns the timezone which is used on the client side. It is used to convert the internal utc timestamp\nto the client side timezone. By default UTC.",
      "clientUpdatable": false
    },
    {
      "name": "endTimezone",
      "type": "Timezone",
      "description": "Returns the timezone which is used on the client side. It is used to convert the internal utc timestamp\nto the client side timezone. By default UTC.",
      "clientUpdatable": false
    },
    {
      "name": "orCreateClassNames",
      "type": "Set<String>",
      "description": "Returns the set of class names or creates a new, empty one, if none exists yet. The returned set is\nthe same as used internally, therefore any changes to it will be reflected to the client side on the\nnext refresh.",
      "clientUpdatable": false
    },
    {
      "name": "classNamesSize",
      "type": "int",
      "description": "Assign an additional className to this entry. Already assigned classNames will be kept.\n\n\n\n/\n    \n    public void assignClassName(String className) {\n        assignClassNames(Objects.requireNonNull(className));\n    }\n\n    /**\nAssign additional classNames to this entry. Already assigned classNames will be kept.\n\n\n\n/\n    \n    public void assignClassNames(String... classNames) {\n        assignClassNames(Arrays.asList(classNames));\n    }\n\n    /**\nAssign additional classNames to this entry. Already assigned classNames will be kept.\n\n\n\n/\n    \n    public void assignClassNames(Collection<String> classNames) {\n        Objects.requireNonNull(classNames);\n        getOrCreateClassNames().addAll(classNames);\n    }\n\n    /**\nAdds css class names to this entry. Duplicates will automatically be filtered out.\n\n\n/\n    public void addClassNames(String... classNames) {\n        assignClassNames(Arrays.asList(classNames));\n    }\n\n    /**\nAdds css class names to this entry. Duplicates will automatically be filtered out.\n\n\n/\n    public void addClassNames(Collection<String> classNames) {\n        Objects.requireNonNull(classNames);\n        getOrCreateClassNames().addAll(classNames);\n    }\n\n    /**\nUnassigns the given className from this entry.\n\n\n\n/\n    \n    public void unassignClassName(String className) {\n        unassignClassNames(Objects.requireNonNull(className));\n    }\n\n    /**\nUnassigns the given classNames from this entry.\n\n\n\n/\n    \n    public void unassignClassNames(String... classNames) {\n        unassignClassNames(Arrays.asList(classNames));\n    }\n\n    /**\nUnassigns the given classNames from this entry.\n\n\n\n/\n    \n    public void unassignClassNames(Collection<String> classNamesToRemove) {\n        removeClassNames(classNamesToRemove);\n    }\n\n    /**\nUnassigns all classNames from this entry.\n\n/\n    \n    public void unassignAllClassNames() {\n        removeClassNames();\n    }\n\n    /**\nRemoves the given classNames from this entry.\n\n\n/\n    public void removeClassNames(String... classNames) {\n        removeClassNames(Arrays.asList(classNames));\n    }\n\n    /**\nRemoves the given classNames from this entry.\n\n\n/\n    public void removeClassNames(Collection<String> classNamesToRemove) {\n        Set<String> classNames = getClassNames();\n        if (classNames != null) {\n            classNames.removeAll(classNamesToRemove);\n        }\n    }\n\n    /**\nRemoves the class names from this entry. Copies of the internal class name set will be unaffected;\n/\n    public void removeClassNames() {\n        setClassNames(null);\n    }\n\n    /**\nReturns the amount of assigned classNames.",
      "clientUpdatable": false
    },
    {
      "name": "overlapAllowed",
      "type": "boolean",
      "description": "Returns, if the entry has any class name assigned.\n\n/\n    public boolean hasClassNames() {\n        Set<String> classNames = getClassNames();\n        return classNames != null && !classNames.isEmpty();\n    }\n\n    /**\nSame as {",
      "clientUpdatable": false
    },
    {
      "name": "description",
      "type": "String",
      "description": "Sets the entry Constraint.\nNull or empty string resets the color to the FC's default.\n\n/\n    public void setConstraint(String constraint) {\n        this.constraint = StringUtils.trimToNull(constraint);\n    }\n\n    /**\nSets the color for this entry. This is interpreted as background and border color on the client side.\nNull or empty string resets the color to the FC's default.\n\n/\n    public void setColor(String color) {\n        this.color = StringUtils.trimToNull(color);\n    }\n\n    /**\nSets the background color for this entry. Null or empty string resets the color to the FC's default.\n\n/\n    public void setBackgroundColor(String backgroundColor) {\n        this.backgroundColor = StringUtils.trimToNull(backgroundColor);\n    }\n\n    /**\nSets the text color for this entry. Null or empty string resets the color to the FC's default.\n\n/\n    public void setTextColor(String textColor) {\n        this.textColor = StringUtils.trimToNull(textColor);\n    }\n\n    /**\nSets the border color for this entry. Null or empty string resets the color to the FC's default.\n\n/\n    public void setBorderColor(String borderColor) {\n        this.borderColor = StringUtils.trimToNull(borderColor);\n    }\n\n    /**\nReturns the description of this entry. Since the description is a <b>custom property</b>, it will\nnot automatically be shown on the entry.",
      "clientUpdatable": false
    },
    {
      "name": "recurring",
      "type": "boolean",
      "description": "Sets the description of this entry. Since the description is a <b>custom property</b>, it will\nnot automatically be shown on the entry.\n\n/\n    public void setDescription(String description) {\n        setCustomProperty(EntryCustomProperties.DESCRIPTION, description);\n    }\n\n    /**\nSets the display mode for this entry. Passing null will reset it to the default.\n\n/\n    public void setDisplayMode(DisplayMode displayMode) {\n        this.displayMode = displayMode != null ? displayMode : DisplayMode.AUTO;\n    }\n\n    /**\nIndicates, if this entry is recurring. This is indicated by having any \"recurring\" property set (e.g.\n{",
      "clientUpdatable": false
    },
    {
      "name": "recurringStartTimeAsLocalTime",
      "type": "LocalTime",
      "description": "Returns the recurring start time as a local time.<br>\nSince the FC allows recurring times to be above the normal 24h span of a day, using a LocalTime can lead to\nissues, as it does not support times of 24h or above.",
      "clientUpdatable": false
    },
    {
      "name": "recurringEndTimeAsLocalTime",
      "type": "LocalTime",
      "description": "Returns the recurring end time as a local time.<br>\nSince the FC allows recurring times to be above the normal 24h span of a day, using a LocalTime can lead to\nissues, as it does not support times of 24h or above.",
      "clientUpdatable": false
    },
    {
      "name": "recurringStart",
      "type": "LocalDateTime",
      "description": "Sets the end time for a recurring entry. Passing a non null value automatically marks this entry\nas recurring. Passing null may remove the recurrence or let the recurring entry extend to the\nend of day.\n\n\n/\n    public void setRecurringEndTime(RecurringTime end) {\n        this.recurringEndTime = end;\n    }\n\n    /**\nSets the end time for a recurring entry. Passing a non null value automatically marks this entry\nas recurring. Passing null may remove the recurrence or let the recurring entry extend to the\nend of day.\n\n\n/\n    public void setRecurringEndTime(LocalTime end) {\n        setRecurringEndTime(end != null ? RecurringTime.of(end) : null);\n    }\n\n    /**\nReturns the recurring start. This method is a shortcut for combining {\nand {\nWill return null, when no recurrence date is defined. When only\na start date is defined, the returned date time will be at the start of that day.\n<br>\nIn case that the recurring start time is 24h or greater, the date part will shift depending on the\nresulting additional days. See {",
      "clientUpdatable": false
    },
    {
      "name": "recurringEnd",
      "type": "LocalDateTime",
      "description": "Returns the recurring end. This method is a shortcut for combining {\nand {\nWill return null, when no recurrence date is defined. When only a\nend date is defined, the returned date time will be at the end of that day (23:59:99).<br>\n<br>\nIn case that the recurring end time is 24h or greater, the date part will shift depending on the\nresulting additional days. See {",
      "clientUpdatable": false
    },
    {
      "name": "customPropertiesOrEmpty",
      "type": "Map<String, Object>",
      "description": "Returns the custom properties map or an empty one, if none has yet been created. The map is not writable.",
      "clientUpdatable": false
    },
    {
      "name": "orCreateCustomProperties",
      "type": "Map<String, Object>",
      "description": "Returns the map of the custom properties of this instance. This map is editable and any changes\nwill be sent to the client when the entry provider is refreshed.\n<p></p>\nCreates and registers a new map, if none is there yet.\n<p></p>\nBe aware, that any non standard property you\nset via \"set(..., ...)\" is not automatically put into this map, but this is done by the client later.",
      "clientUpdatable": false
    }
  ],
  "calendarViews": [
    {
      "name": "D",
      "enumValue": "D",
      "description": "Calendar view: D",
      "isSchedulerView": false
    },
    {
      "name": "Day Grid Month",
      "enumValue": "DAY_GRID_MONTH",
      "description": "Monthly view with days displayed in a grid",
      "isSchedulerView": false
    },
    {
      "name": "T",
      "enumValue": "T",
      "description": "Calendar view: T",
      "isSchedulerView": false
    },
    {
      "name": "Time Grid Day",
      "enumValue": "TIME_GRID_DAY",
      "description": "Single day view with time slots displayed vertically",
      "isSchedulerView": false
    },
    {
      "name": "T",
      "enumValue": "T",
      "description": "Calendar view: T",
      "isSchedulerView": false
    },
    {
      "name": "Time Grid Week",
      "enumValue": "TIME_GRID_WEEK",
      "description": "Weekly view with time slots displayed vertically",
      "isSchedulerView": false
    },
    {
      "name": "D",
      "enumValue": "D",
      "description": "Calendar view: D",
      "isSchedulerView": false
    },
    {
      "name": "Day Grid Day",
      "enumValue": "DAY_GRID_DAY",
      "description": "Single day view displayed in a grid format",
      "isSchedulerView": false
    },
    {
      "name": "D",
      "enumValue": "D",
      "description": "Calendar view: D",
      "isSchedulerView": false
    },
    {
      "name": "Day Grid Week",
      "enumValue": "DAY_GRID_WEEK",
      "description": "Weekly view with days displayed in a grid",
      "isSchedulerView": false
    },
    {
      "name": "D",
      "enumValue": "D",
      "description": "Calendar view: D",
      "isSchedulerView": false
    },
    {
      "name": "Day Grid Year",
      "enumValue": "DAY_GRID_YEAR",
      "description": "Yearly view with days displayed in a grid",
      "isSchedulerView": false
    },
    {
      "name": "E",
      "enumValue": "E",
      "description": "Calendar view: E",
      "isSchedulerView": false
    },
    {
      "name": "List Week",
      "enumValue": "LIST_WEEK",
      "description": "Weekly list view of events",
      "isSchedulerView": false
    },
    {
      "name": "E",
      "enumValue": "E",
      "description": "Calendar view: E",
      "isSchedulerView": false
    },
    {
      "name": "List Day",
      "enumValue": "LIST_DAY",
      "description": "Daily list view of events",
      "isSchedulerView": false
    },
    {
      "name": "E",
      "enumValue": "E",
      "description": "Calendar view: E",
      "isSchedulerView": false
    },
    {
      "name": "List Month",
      "enumValue": "LIST_MONTH",
      "description": "Monthly list view of events",
      "isSchedulerView": false
    },
    {
      "name": "E",
      "enumValue": "E",
      "description": "Calendar view: E",
      "isSchedulerView": false
    },
    {
      "name": "List Year",
      "enumValue": "LIST_YEAR",
      "description": "Yearly list view of events",
      "isSchedulerView": false
    },
    {
      "name": "S",
      "enumValue": "S",
      "description": "Calendar view: S",
      "isSchedulerView": false
    },
    {
      "name": "Multi Month",
      "enumValue": "MULTI_MONTH",
      "description": "Multiple months displayed at once",
      "isSchedulerView": false
    },
    {
      "name": "D",
      "enumValue": "D",
      "description": "Calendar view: D",
      "isSchedulerView": true
    },
    {
      "name": "Timeline Day",
      "enumValue": "TIMELINE_DAY",
      "description": "Timeline view for a single day with resources",
      "isSchedulerView": true
    },
    {
      "name": "W",
      "enumValue": "W",
      "description": "Calendar view: W",
      "isSchedulerView": true
    },
    {
      "name": "Timeline Week",
      "enumValue": "TIMELINE_WEEK",
      "description": "Timeline view for a week with resources",
      "isSchedulerView": true
    },
    {
      "name": "M",
      "enumValue": "M",
      "description": "Calendar view: M",
      "isSchedulerView": true
    },
    {
      "name": "Timeline Month",
      "enumValue": "TIMELINE_MONTH",
      "description": "Timeline view for a month with resources",
      "isSchedulerView": true
    },
    {
      "name": "Y",
      "enumValue": "Y",
      "description": "Calendar view: Y",
      "isSchedulerView": true
    },
    {
      "name": "Timeline Year",
      "enumValue": "TIMELINE_YEAR",
      "description": "Timeline view for a year with resources",
      "isSchedulerView": true
    },
    {
      "name": "D",
      "enumValue": "D",
      "description": "Calendar view: D",
      "isSchedulerView": true
    },
    {
      "name": "Resource Timeline Day",
      "enumValue": "RESOURCE_TIMELINE_DAY",
      "description": "Calendar view: RESOURCE_TIMELINE_DAY",
      "isSchedulerView": true
    },
    {
      "name": "W",
      "enumValue": "W",
      "description": "Calendar view: W",
      "isSchedulerView": true
    },
    {
      "name": "Resource Timeline Week",
      "enumValue": "RESOURCE_TIMELINE_WEEK",
      "description": "Calendar view: RESOURCE_TIMELINE_WEEK",
      "isSchedulerView": true
    },
    {
      "name": "M",
      "enumValue": "M",
      "description": "Calendar view: M",
      "isSchedulerView": true
    },
    {
      "name": "Resource Timeline Month",
      "enumValue": "RESOURCE_TIMELINE_MONTH",
      "description": "Calendar view: RESOURCE_TIMELINE_MONTH",
      "isSchedulerView": true
    },
    {
      "name": "Y",
      "enumValue": "Y",
      "description": "Calendar view: Y",
      "isSchedulerView": true
    },
    {
      "name": "Resource Timeline Year",
      "enumValue": "RESOURCE_TIMELINE_YEAR",
      "description": "Calendar view: RESOURCE_TIMELINE_YEAR",
      "isSchedulerView": true
    },
    {
      "name": "D",
      "enumValue": "D",
      "description": "Calendar view: D",
      "isSchedulerView": true
    },
    {
      "name": "Resource Time Grid Day",
      "enumValue": "RESOURCE_TIME_GRID_DAY",
      "description": "Calendar view: RESOURCE_TIME_GRID_DAY",
      "isSchedulerView": true
    },
    {
      "name": "Agenda Day",
      "enumValue": "AGENDA_DAY",
      "description": "Calendar view: AGENDA_DAY",
      "isSchedulerView": true
    },
    {
      "name": "W",
      "enumValue": "W",
      "description": "Calendar view: W",
      "isSchedulerView": true
    },
    {
      "name": "Resource Time Grid Week",
      "enumValue": "RESOURCE_TIME_GRID_WEEK",
      "description": "Calendar view: RESOURCE_TIME_GRID_WEEK",
      "isSchedulerView": true
    },
    {
      "name": "Agenda Week",
      "enumValue": "AGENDA_WEEK",
      "description": "Calendar view: AGENDA_WEEK",
      "isSchedulerView": true
    }
  ],
  "eventTypes": [
    {
      "name": "BrowserTimezoneObtainedEvent",
      "description": "This event gets fired when the client side reported the browser's timezone to the server. Since this is\ndone after the element has been attached to the client, it will be fired after all UI attach events.",
      "properties": [],
      "source": "core"
    },
    {
      "name": "DateEvent",
      "description": "An abstract class for date events, that are not directly entry related. They are always whole day events.",
      "properties": [],
      "source": "core"
    },
    {
      "name": "DateTimeEvent",
      "description": "An abstract class for date events, that are not directly entry related.",
      "properties": [
        {
          "name": "dateTimeAsInstant",
          "type": "Instant",
          "description": "An abstract class for date events, that are not directly entry related.\n/\n\n\npublic abstract class DateTimeEvent extends ComponentEvent<FullCalendar> {\n\n    /**\nIf the event has occurred for a day slot. False means, it has been for a time slot inside a day.\n/\n    private final boolean allDay;\n\n    /**\nThe utc based date time related to this event. For day slots the time will be at start of the day.\n/\n    private final LocalDateTime dateTime;\n\n    /**\nNew instance. Awaits the date (time) as iso string (e.g. \"2018-10-23\" or \"2018-10-23T13:30\").\n\n\n\n\n/\n    public DateTimeEvent(FullCalendar source, boolean fromClient, String dateString, boolean allDay) {\n        super(source, fromClient);\n\n        this.allDay = allDay;\n        dateTime = JsonUtils.parseClientSideDateTime(dateString);\n    }\n\n    /**\nThe utc based date time related to this event. For day slots the time will be at start of the day."
        },
        {
          "name": "dateTimeWithOffset",
          "type": "LocalDateTime",
          "description": "The date time related to this event including the calendar timezone's offset.\nFor day slots the time will be at start of the day and ignore the timezone."
        },
        {
          "name": "date",
          "type": "LocalDate",
          "description": "Returns only the date part of the contained local date time. This method is intended to be used on\nall day entry related events."
        }
      ],
      "source": "core"
    },
    {
      "name": "EntryEvent",
      "description": "Simple event that occurred for a specific calendar item.",
      "properties": [],
      "source": "core"
    },
    {
      "name": "MultipleEntriesEvent",
      "description": "Simple event that occurred for multiple calendar items.",
      "properties": [
        {
          "name": "entries",
          "type": "Collection<Entry>",
          "description": "Simple event that occurred for multiple calendar items.\n/\n\n\npublic abstract class MultipleEntriesEvent extends ComponentEvent<FullCalendar> {\n\n    /**\nThe entry, for which the event occurred.\n/\n    private final Set<Entry> entries;\n\n    /**\nNew instance. Awaits the entry id.\n\n\n\n/\n    public MultipleEntriesEvent(FullCalendar source, boolean fromClient, Collection<String> entryIds) {\n        super(source, fromClient);\n\n        if (entryIds == null || entryIds.isEmpty()) {\n            throw new IllegalArgumentException(\"IDs parameter must not be null nor empty\");\n        }\n\n        this.entries = entryIds\n                .stream()\n                .map(id -> {\n                    Optional<Entry> entry = source.getCachedEntryFromFetch(id);\n                    if (!entry.isPresent()) {\n                        throw new IllegalArgumentException(\"No item found with id \" + id);\n                    }\n                    return entry;\n                })\n                .map(Optional::get)\n                .collect(Collectors.toSet());\n    }\n\n    /**\nReturns the entries for which this event occurred. Never null nor empty."
        }
      ],
      "source": "core"
    },
    {
      "name": "TimeslotsSelectedEvent",
      "description": "Occurs when the user selects one or multiple timeslots on the calendar. The selected timeslots may contain\nentries.\n<br><br>\nClient side event: select",
      "properties": [
        {
          "name": "startAsInstant",
          "type": "Instant",
          "description": "Occurs when the user selects one or multiple timeslots on the calendar. The selected timeslots may contain\nentries.\n<br><br>\nClient side event: select\n/\n\n\n\npublic class TimeslotsSelectedEvent extends ComponentEvent<FullCalendar> {\n\n    /**\nIf the selection has been for day slots. False means, it has been a selection on time slots inside a day.\n/\n    private final boolean allDay;\n\n    /**\nReturns the start of the event as local date time. Represents the UTC date time this event starts, which\nmeans the time is the same as when calling {\n/\n    private final LocalDateTime start;\n\n    /**\nReturns the end of the event as local date time. Represents the UTC date time this event ends, which\nmeans the time is the same as when calling {\n/\n    private final LocalDateTime end;\n\n    /**\nNew instance. Awaits the selected dates (time) as iso string (e.g. \"2018-10-23\" or \"2018-10-23T13:30\").\n\n\n\n\n\n/\n    public TimeslotsSelectedEvent(FullCalendar source, boolean fromClient, \n        super(source, fromClient);\n\n        Timezone timezone = source.getTimezone();\n        this.allDay = allDay;\n        this.start = JsonUtils.parseClientSideDateTime(start);\n        this.end = JsonUtils.parseClientSideDateTime(end);\n    }\n\n    /**\nReturns the entry's start as an {\n{"
        },
        {
          "name": "endAsInstant",
          "type": "Instant",
          "description": "Returns the entry's end as an {\n{"
        },
        {
          "name": "startWithOffset",
          "type": "LocalDateTime",
          "description": "Returns the start time as a local date time after applying the timezone's offset to\nthe utc based start date ({\nthe calendar's timezone or, if no calendar is set yet, UTC.\n<p></p>"
        },
        {
          "name": "endWithOffset",
          "type": "LocalDateTime",
          "description": "Returns the end time as a local date time after applying the timezone's offset to\nthe utc based end date ({\nthe calendar's timezone or, if no calendar is set yet, UTC."
        },
        {
          "name": "startDate",
          "type": "LocalDate",
          "description": "Returns the start of the event as local date."
        },
        {
          "name": "endDate",
          "type": "LocalDate",
          "description": "Returns the end of the event as local date."
        }
      ],
      "source": "core"
    },
    {
      "name": "ViewRenderEvent",
      "description": "Basic event for view render events. Provides information about the shown timespan.\n<br><br>\nThe values are always daybased, regardless of the current view.",
      "properties": [
        {
          "name": "calendarView",
          "type": "Optional<CalendarView>",
          "description": "Basic event for view render events. Provides information about the shown timespan.\n<br><br>\nThe values are always daybased, regardless of the current view.\n/\n\n\npublic abstract class ViewRenderEvent extends ComponentEvent<FullCalendar> {\n\n    /**\nThe client side name of the view.\n/\n    private final String viewName;\n\n    /**\nThe current shown interval's start date.\n/\n    private final LocalDate intervalStart;\n\n    /**\nThe current shown interval's end date.\n/\n    private final LocalDate intervalEnd;\n\n    /**\nThe first visible date. In month-view, this value is often before\nthe 1st day of the month, because most months do not begin on the first\nday-of-week.\n/\n    private final LocalDate start;\n\n    /**\nThe last visible date. In month-view, this value is often after\nthe last day of the month, because most months do not end on the last day of the week\n/\n    private final LocalDate end;\n\n\n    private final CalendarView calendarView;\n\n    /**\nCreates a new event using the given source and indicator whether the\nevent originated from the client side or the server side.\n\n\n/\n    public ViewRenderEvent(FullCalendar source, boolean fromClient, ObjectNode eventData) {\n        super(source, fromClient);\n\n        this.viewName = eventData.get(\"name\").asString();\n\n        this.calendarView = source.lookupViewByClientSideValue(viewName).orElse(null);\n\n        this.intervalStart = parseClientSideDate(eventData.get(\"intervalStart\").asString());\n        this.intervalEnd = parseClientSideDate(eventData.get(\"intervalEnd\").asString());\n        this.start = parseClientSideDate(eventData.get(\"start\").asString());\n        this.end = parseClientSideDate(eventData.get(\"end\").asString());\n    }\n\n    /**\nSame as {\n\n\n/\n    \n    public String getName() {\n        return viewName;\n    }\n\n    /**\nThe calendar view of this event. Empty, if the view name could not be matched with one of the predefined\nviews (e.g. in case of a custom view)."
        }
      ],
      "source": "core"
    },
    {
      "name": "EntryDroppedSchedulerEvent",
      "description": "Scheduler event: entry dropped scheduler event",
      "properties": [
        {
          "name": "oldResource",
          "type": "Optional<Resource>",
          "description": "New instance. Awaits the changed data object for the entry plus the json object for the delta information.\n\n\n\n\n/\n    public EntryDroppedSchedulerEvent(FullCalendarScheduler source, boolean fromClient,\n                                      \n                                      \n        super(source, fromClient, jsonEntry, jsonDelta);\n\n        if(jsonEntry.hasNonNull(\"oldResource\")) {\n            this.oldResource = source.getResourceById(jsonEntry.get(\"oldResource\").asString()).orElseThrow(IllegalArgumentException::new);\n        } else {\n            this.oldResource = null;\n        }\n\n        if(jsonEntry.has(\"newResource\")) {\n            this.newResource = source.getResourceById(jsonEntry.get(\"newResource\").asString()).orElseThrow(IllegalArgumentException::new);\n        } else {\n            this.newResource = null;\n        }\n    }\n\n    /**\nApplies the changes on the entry including updating a resource change.\n\n/\n    \n    public Entry applyChangesOnEntry() {\n        ResourceEntry entry = (ResourceEntry) super.applyChangesOnEntry();\n        ObjectNode object = getJsonObject();\n\n        updateResourcesFromEventResourceDelta(entry, object);\n\n        return entry;\n    }\n\n    public static void updateResourcesFromEventResourceDelta(ResourceEntry entry, ObjectNode object) {\n        entry.getCalendar().map(c -> (Scheduler) c).ifPresent(calendar -> {\n            Optional.ofNullable(object.get(\"oldResource\"))\n                    .filter(JsonNode::isString)\n                    .map(JsonNode::asString)\n                    .flatMap(calendar::getResourceById)\n                    .map(Collections::singleton)\n                    .ifPresent(entry::removeResources);\n\n            Optional.ofNullable(object.get(\"newResource\"))\n                    .filter(JsonNode::isString)\n                    .map(JsonNode::asString)\n                    .flatMap(calendar::getResourceById)\n                    .map(Collections::singleton)\n                    .ifPresent(entry::addResources);\n        });\n    }\n\n    /**\nIf there has been a change in the resource assignments, this method returns the previous assigned resource."
        },
        {
          "name": "newResource",
          "type": "Optional<Resource>",
          "description": "If there has been a change in the resource assignments, this method returns the newly assigned resource."
        }
      ],
      "source": "scheduler"
    },
    {
      "name": "TimeslotClickedSchedulerEvent",
      "description": "This type extends the normal timeslot clicked event by providing the selected resource (if there's one).\n<br><br>\nClient side event: dateClick",
      "properties": [
        {
          "name": "resource",
          "type": "Optional<Resource>",
          "description": "This type extends the normal timeslot clicked event by providing the selected resource (if there's one).\n<br><br>\nClient side event: dateClick\n/\n\n\npublic class TimeslotClickedSchedulerEvent extends TimeslotClickedEvent {\n\n    private Resource resource;\n\n    /**\nNew instance. Awaits the clicked date (time) as iso string (e.g. \"2018-10-23\" or \"2018-10-23T13:30\").\n\n\n\n\n\n/\n    public TimeslotClickedSchedulerEvent(FullCalendarScheduler source, boolean fromClient, \n        super(source, fromClient, date, allDay);\n\n        if (resourceId != null) {\n            this.resource = source.getResourceById(resourceId).orElseThrow(IllegalArgumentException::new);\n        }\n    }\n\n    /**\nIf the select event has occured in the scheduler, the selected resource will be returned."
        }
      ],
      "source": "scheduler"
    },
    {
      "name": "TimeslotsSelectedSchedulerEvent",
      "description": "This type extends the normal timeslot selected event by providing the selected resource (if there's one).\n<br><br>\nClient side event: select",
      "properties": [
        {
          "name": "resource",
          "type": "Optional<Resource>",
          "description": "This type extends the normal timeslot selected event by providing the selected resource (if there's one).\n<br><br>\nClient side event: select\n/\n\n\npublic class TimeslotsSelectedSchedulerEvent extends TimeslotsSelectedEvent {\n\n    private Resource resource;\n\n    /**\nNew instance. Awaits the selected dates (time) as iso string (e.g. \"2018-10-23\" or \"2018-10-23T13:30\").\n\n\n\n\n\n\n/\n    public TimeslotsSelectedSchedulerEvent(FullCalendarScheduler source, boolean fromClient, \n        super(source, fromClient, start, end, allDay);\n\n        if (resourceId != null) {\n            this.resource = source.getResourceById(resourceId).orElseThrow(IllegalArgumentException::new);\n        }\n    }\n\n    /**\nIf the select event has occured in the scheduler, the selected resource will be returned."
        }
      ],
      "source": "scheduler"
    }
  ],
  "version": "7.0.1-SNAPSHOT",
  "extractedAt": "2026-01-26T09:04:16.373Z"
}